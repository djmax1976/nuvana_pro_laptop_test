// Generate to backend/node_modules for backend code
generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

// Generate to root/node_modules for test files
generator clientRoot {
  provider = "prisma-client-js"
  output   = "../../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  user_id                 String                 @id @default(uuid()) @db.Uuid
  email                   String                 @unique @db.VarChar(255)
  name                    String                 @db.VarChar(255)
  auth_provider_id        String?                @unique @db.VarChar(255)
  status                  String                 @default("ACTIVE") @db.VarChar(50)
  created_at              DateTime               @default(now()) @db.Timestamptz(6)
  updated_at              DateTime               @default(now()) @updatedAt @db.Timestamptz(6)
  password_hash           String?                @db.VarChar(255)
  public_id               String                 @unique @db.VarChar(30)
  is_client_user          Boolean                @default(false)
  audit_logs              AuditLog[]
  owned_companies         Company[]              @relation("CompanyOwner")
  shifts_opened           Shift[]                @relation("ShiftOpener")
  shifts_approved         Shift[]                @relation("ShiftApprover")
  transactions            Transaction[]          @relation("TransactionCashier")
  assigned_roles          UserRole[]             @relation("UserRoleAssigner")
  user_roles              UserRole[]
  client_role_permissions ClientRolePermission[] @relation("ClientRolePermissionOwner")
  roles_created           Role[]                 @relation("RoleCreator")
  roles_deleted           Role[]                 @relation("RoleDeleter")
  company_roles_assigned  CompanyAllowedRole[]   @relation("CompanyAllowedRoleAssigner")
  bulk_import_jobs        BulkImportJob[]        @relation("BulkImportJobUser")
  cashiers_created        Cashier[]              @relation("CashierCreatedBy")
  cashiers_updated        Cashier[]              @relation("CashierUpdatedBy")

  @@index([email])
  @@index([status])
  @@index([public_id])
  @@index([is_client_user])
  @@map("users")
}

model Company {
  company_id    String               @id @default(uuid()) @db.Uuid
  name          String               @db.VarChar(255)
  address       String?              @db.VarChar(500)
  status        String               @default("ACTIVE") @db.VarChar(50)
  created_at    DateTime             @default(now()) @db.Timestamptz(6)
  updated_at    DateTime             @default(now()) @updatedAt @db.Timestamptz(6)
  owner_user_id String               @db.Uuid
  public_id     String               @unique @db.VarChar(30)
  owner         User                 @relation("CompanyOwner", fields: [owner_user_id], references: [user_id], onDelete: Cascade)
  stores        Store[]
  user_roles    UserRole[]
  allowed_roles CompanyAllowedRole[] @relation("CompanyAllowedRoleCompany")

  @@index([owner_user_id])
  @@index([status])
  @@index([public_id])
  @@map("companies")
}

model Store {
  store_id      String        @id @default(uuid()) @db.Uuid
  company_id    String        @db.Uuid
  name          String        @db.VarChar(255)
  location_json Json?
  timezone      String        @default("America/New_York") @db.VarChar(50)
  status        String        @default("ACTIVE") @db.VarChar(50)
  created_at    DateTime      @default(now()) @db.Timestamptz(6)
  updated_at    DateTime      @default(now()) @updatedAt @db.Timestamptz(6)
  configuration Json?
  public_id     String        @unique @db.VarChar(30)
  pos_terminals POSTerminal[]
  shifts        Shift[]
  cashiers      Cashier[]
  company       Company       @relation(fields: [company_id], references: [company_id], onDelete: Cascade)
  transactions  Transaction[]
  user_roles    UserRole[]

  @@index([company_id])
  @@index([status])
  @@index([public_id])
  @@map("stores")
}

/// Cashier model with soft-delete semantics
/// 
/// SOFT-DELETE SEMANTICS:
/// - disabled_at IS NULL = cashier is active (authoritative field for filtering)
/// - disabled_at IS NOT NULL = cashier is soft-deleted
/// - is_active is a denormalized boolean for quick checks and backward compatibility
/// 
/// RULES:
/// - When disabling: set is_active=false AND disabled_at=now() atomically
/// - When re-enabling: set is_active=true AND disabled_at=NULL atomically
/// - All queries MUST filter by disabled_at IS NULL (not is_active) to ensure consistency
/// - is_active should be kept in sync with disabled_at for backward compatibility
model Cashier {
  cashier_id              String    @id @default(uuid()) @db.Uuid
  store_id                String    @db.Uuid
  employee_id             String    @db.VarChar(4) // 4-digit zero-padded, unique per store
  name                    String    @db.VarChar(255)
  pin_hash                String    @db.VarChar(255) // bcrypt hashed
  sha256_pin_fingerprint  String?   @db.VarChar(64) // SHA-256 hex digest for fast uniqueness checks
  is_active               Boolean   @default(true) // Denormalized: true when disabled_at IS NULL, false when disabled_at IS NOT NULL
  hired_on                DateTime  @db.Date
  termination_date        DateTime? @db.Date
  created_at              DateTime  @default(now()) @db.Timestamptz(6)
  updated_at              DateTime  @default(now()) @updatedAt @db.Timestamptz(6)
  disabled_at             DateTime? @db.Timestamptz(6) // Authoritative: NULL = active, NOT NULL = soft-deleted
  created_by              String    @db.Uuid
  updated_by              String?   @db.Uuid

  store    Store    @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  creator  User     @relation("CashierCreatedBy", fields: [created_by], references: [user_id])
  updater  User?    @relation("CashierUpdatedBy", fields: [updated_by], references: [user_id])
  shifts   Shift[]

  @@unique([store_id, employee_id])
  @@unique([store_id, pin_hash])
  @@unique([store_id, sha256_pin_fingerprint])
  @@index([store_id])
  @@index([employee_id])
  @@index([is_active])
  @@index([disabled_at])
  @@index([created_by])
  @@index([updated_by])
  @@map("cashiers")
}

model Role {
  role_id                 String                 @id @default(uuid()) @db.Uuid
  scope                   String                 @db.VarChar(50)
  code                    String                 @unique @db.VarChar(100)
  description             String?
  is_system_role          Boolean                @default(false) // Protects core roles from deletion
  created_by              String?                @db.Uuid // Super Admin who created this role
  deleted_at              DateTime?              @db.Timestamptz(6) // Soft delete timestamp (NULL = active)
  deleted_by              String?                @db.Uuid // Super Admin who deleted this role
  created_at              DateTime               @default(now()) @db.Timestamptz(6)
  updated_at              DateTime               @default(now()) @updatedAt @db.Timestamptz(6)
  role_permissions        RolePermission[]
  user_roles              UserRole[]
  client_role_permissions ClientRolePermission[] @relation("ClientRolePermissionRole")
  company_allowed_roles   CompanyAllowedRole[]   @relation("CompanyAllowedRoleRole")
  creator                 User?                  @relation("RoleCreator", fields: [created_by], references: [user_id])
  deleter                 User?                  @relation("RoleDeleter", fields: [deleted_by], references: [user_id])

  @@index([scope])
  @@index([code])
  @@index([deleted_at])
  @@index([is_system_role])
  @@map("roles")
}

model Permission {
  permission_id           String                 @id @default(uuid()) @db.Uuid
  code                    String                 @unique @db.VarChar(100)
  description             String?
  created_at              DateTime               @default(now()) @db.Timestamptz(6)
  role_permissions        RolePermission[]
  client_role_permissions ClientRolePermission[] @relation("ClientRolePermissionPermission")

  @@index([code])
  @@map("permissions")
}

model UserRole {
  user_role_id String   @id @default(uuid()) @db.Uuid
  user_id      String   @db.Uuid
  role_id      String   @db.Uuid
  company_id   String?  @db.Uuid
  store_id     String?  @db.Uuid
  assigned_by  String?  @db.Uuid
  assigned_at  DateTime @default(now()) @db.Timestamptz(6)
  status       String   @default("ACTIVE") @db.VarChar(50)
  assigner     User?    @relation("UserRoleAssigner", fields: [assigned_by], references: [user_id])
  company      Company? @relation(fields: [company_id], references: [company_id], onDelete: Cascade)
  role         Role     @relation(fields: [role_id], references: [role_id], onDelete: Cascade)
  store        Store?   @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  user         User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@unique([user_id, role_id, company_id, store_id])
  @@index([user_id])
  @@index([company_id])
  @@index([store_id])
  @@index([status])
  @@map("user_roles")
}

model RolePermission {
  role_id       String     @db.Uuid
  permission_id String     @db.Uuid
  permission    Permission @relation(fields: [permission_id], references: [permission_id], onDelete: Cascade)
  role          Role       @relation(fields: [role_id], references: [role_id], onDelete: Cascade)

  @@id([role_id, permission_id])
  @@index([role_id])
  @@index([permission_id])
  @@map("role_permissions")
}

/// Client Role Permission - Allows Client Owners to customize STORE scope role permissions
/// Overrides the system default RolePermission settings for the client's users
/// Tenant isolation is enforced via owner_user_id (client owner's user_id)
model ClientRolePermission {
  client_role_permission_id String   @id @default(uuid()) @db.Uuid
  owner_user_id             String   @db.Uuid // Client owner's user_id for tenant isolation
  role_id                   String   @db.Uuid // STORE scope role being customized
  permission_id             String   @db.Uuid // Permission being toggled
  is_enabled                Boolean  @default(true) // Override state: true = granted, false = revoked
  created_at                DateTime @default(now()) @db.Timestamptz(6)
  updated_at                DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  owner      User       @relation("ClientRolePermissionOwner", fields: [owner_user_id], references: [user_id], onDelete: Cascade)
  role       Role       @relation("ClientRolePermissionRole", fields: [role_id], references: [role_id], onDelete: Cascade)
  permission Permission @relation("ClientRolePermissionPermission", fields: [permission_id], references: [permission_id], onDelete: Cascade)

  @@unique([owner_user_id, role_id, permission_id])
  @@index([owner_user_id])
  @@index([role_id])
  @@map("client_role_permissions")
}

/// Company Allowed Role - Controls which roles are available to each company
/// Super Admin assigns roles to companies - Client Owner can only see/customize allowed roles
/// This enables role access control at the company level
model CompanyAllowedRole {
  company_allowed_role_id String   @id @default(uuid()) @db.Uuid
  company_id              String   @db.Uuid
  role_id                 String   @db.Uuid
  assigned_by             String   @db.Uuid // Super Admin who granted access
  assigned_at             DateTime @default(now()) @db.Timestamptz(6)

  company  Company @relation("CompanyAllowedRoleCompany", fields: [company_id], references: [company_id], onDelete: Cascade)
  role     Role    @relation("CompanyAllowedRoleRole", fields: [role_id], references: [role_id], onDelete: Cascade)
  assigner User    @relation("CompanyAllowedRoleAssigner", fields: [assigned_by], references: [user_id])

  @@unique([company_id, role_id])
  @@index([company_id])
  @@index([role_id])
  @@map("company_allowed_roles")
}

model AuditLog {
  log_id     String   @id @default(uuid()) @db.Uuid
  user_id    String?  @db.Uuid
  action     String   @db.VarChar(50)
  table_name String   @db.VarChar(100)
  record_id  String   @db.Uuid
  old_values Json?
  new_values Json?
  reason     String?
  ip_address String?  @db.VarChar(45)
  user_agent String?
  timestamp  DateTime @default(now()) @db.Timestamptz(6)
  user       User?    @relation(fields: [user_id], references: [user_id])

  @@index([user_id])
  @@index([table_name])
  @@index([timestamp])
  @@map("audit_logs")
}

enum ShiftStatus {
  NOT_STARTED
  OPEN
  ACTIVE
  CLOSING
  RECONCILING
  CLOSED
  VARIANCE_REVIEW
}

enum POSConnectionType {
  NETWORK
  API
  WEBHOOK
  FILE
  MANUAL
}

enum POSVendorType {
  GENERIC
  SQUARE
  CLOVER
  TOAST
  LIGHTSPEED
  CUSTOM
}

enum POSTerminalStatus {
  ACTIVE
  INACTIVE
  PENDING
  ERROR
}

enum SyncStatus {
  NEVER
  SUCCESS
  FAILED
  IN_PROGRESS
}

model Shift {
  shift_id        String        @id @default(uuid()) @db.Uuid
  store_id        String        @db.Uuid
  opened_by       String        @db.Uuid
  cashier_id      String        @db.Uuid
  pos_terminal_id String?       @db.Uuid
  opened_at       DateTime      @default(now()) @db.Timestamptz(6)
  closed_at       DateTime?     @db.Timestamptz(6)
  opening_cash    Decimal       @default(0) @db.Decimal(10, 2)
  expected_cash   Decimal?      @db.Decimal(10, 2)
  closing_cash    Decimal?      @db.Decimal(10, 2)
  variance        Decimal?      @db.Decimal(10, 2)
  variance_reason String?       @db.VarChar(500)
  status          ShiftStatus   @default(NOT_STARTED)
  approved_by     String?       @db.Uuid
  approved_at     DateTime?     @db.Timestamptz(6)
  created_at      DateTime      @default(now()) @db.Timestamptz(6)
  updated_at      DateTime      @default(now()) @updatedAt @db.Timestamptz(6)
  public_id       String?       @unique @db.VarChar(30)
  external_shift_id String?     @db.VarChar(255)
  external_data     Json?
  synced_at         DateTime?   @db.Timestamptz(6)
  opener          User          @relation("ShiftOpener", fields: [opened_by], references: [user_id])
  cashier         Cashier       @relation(fields: [cashier_id], references: [cashier_id])
  approver        User?         @relation("ShiftApprover", fields: [approved_by], references: [user_id])
  pos_terminal    POSTerminal?  @relation(fields: [pos_terminal_id], references: [pos_terminal_id])
  store           Store         @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  transactions    Transaction[]

  @@index([store_id])
  @@index([opened_by])
  @@index([cashier_id])
  @@index([pos_terminal_id])
  @@index([status])
  @@index([opened_at])
  @@index([store_id, status])
  @@index([store_id, opened_at])
  @@index([public_id])
  @@map("shifts")
}

model POSTerminal {
  pos_terminal_id String            @id @default(uuid()) @db.Uuid
  store_id        String            @db.Uuid
  name            String            @db.VarChar(100)
  device_id       String?           @db.VarChar(255)
  connection_type POSConnectionType @default(MANUAL)
  connection_config Json?
  vendor_type     POSVendorType     @default(GENERIC)
  terminal_status POSTerminalStatus @default(ACTIVE)
  last_sync_at    DateTime?         @db.Timestamptz(6)
  sync_status     SyncStatus        @default(NEVER)
  deleted_at      DateTime?         @db.Timestamptz(6) // Soft delete timestamp (NULL = active)
  created_at      DateTime          @default(now()) @db.Timestamptz(6)
  updated_at      DateTime          @default(now()) @updatedAt @db.Timestamptz(6)
  store           Store             @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  shifts          Shift[]
  transactions    Transaction[]

  @@unique([device_id]) // Global uniqueness (device_id can be null, but if set, must be unique across all stores)
  @@index([store_id])
  @@index([deleted_at])
  @@map("pos_terminals")
}

model Transaction {
  transaction_id  String                @id @default(uuid()) @db.Uuid
  store_id        String                @db.Uuid
  shift_id        String                @db.Uuid
  cashier_id      String                @db.Uuid
  pos_terminal_id String?               @db.Uuid
  timestamp       DateTime              @default(now()) @db.Timestamptz(6)
  subtotal        Decimal               @db.Decimal(10, 2)
  tax             Decimal               @default(0) @db.Decimal(10, 2)
  discount        Decimal               @default(0) @db.Decimal(10, 2)
  total           Decimal               @db.Decimal(10, 2)
  created_at      DateTime              @default(now()) @db.Timestamptz(6)
  public_id       String                @unique @db.VarChar(30)
  line_items      TransactionLineItem[]
  payments        TransactionPayment[]
  cashier         User                  @relation("TransactionCashier", fields: [cashier_id], references: [user_id])
  pos_terminal    POSTerminal?          @relation(fields: [pos_terminal_id], references: [pos_terminal_id])
  shift           Shift                 @relation(fields: [shift_id], references: [shift_id])
  store           Store                 @relation(fields: [store_id], references: [store_id], onDelete: Cascade)

  @@index([store_id])
  @@index([shift_id])
  @@index([cashier_id])
  @@index([pos_terminal_id])
  @@index([timestamp])
  @@index([public_id])
  @@map("transactions")
}

model TransactionLineItem {
  line_item_id   String      @id @default(uuid()) @db.Uuid
  transaction_id String      @db.Uuid
  product_id     String?     @db.Uuid
  sku            String?     @db.VarChar(100)
  name           String      @db.VarChar(255)
  quantity       Int
  unit_price     Decimal     @db.Decimal(10, 2)
  discount       Decimal     @default(0) @db.Decimal(10, 2)
  line_total     Decimal     @db.Decimal(10, 2)
  created_at     DateTime    @default(now()) @db.Timestamptz(6)
  transaction    Transaction @relation(fields: [transaction_id], references: [transaction_id], onDelete: Cascade)

  @@index([transaction_id])
  @@index([product_id])
  @@map("transaction_line_items")
}

model TransactionPayment {
  payment_id     String      @id @default(uuid()) @db.Uuid
  transaction_id String      @db.Uuid
  method         String      @db.VarChar(50)
  amount         Decimal     @db.Decimal(10, 2)
  reference      String?     @db.VarChar(100)
  created_at     DateTime    @default(now()) @db.Timestamptz(6)
  transaction    Transaction @relation(fields: [transaction_id], references: [transaction_id], onDelete: Cascade)

  @@index([transaction_id])
  @@map("transaction_payments")
}

/// Bulk Import Job - Tracks bulk transaction import progress and errors
/// Story 3.6: Bulk Transaction Import
/// Tenant isolation enforced via user_id (users can only view their own jobs, admins can view all)
model BulkImportJob {
  job_id         String    @id @default(uuid()) @db.Uuid
  user_id        String    @db.Uuid
  file_name      String    @db.VarChar(255)
  file_type      String    @db.VarChar(10) // 'CSV' or 'JSON'
  total_rows     Int       @default(0)
  processed_rows Int       @default(0)
  error_rows     Int       @default(0)
  status         String    @default("PENDING") @db.VarChar(50) // 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED'
  started_at     DateTime  @default(now()) @db.Timestamptz(6)
  completed_at   DateTime? @db.Timestamptz(6)
  error_summary  Json? // Array of { row_number: number, field: string, error: string }
  user           User      @relation("BulkImportJobUser", fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([user_id])
  @@index([status])
  @@index([started_at])
  @@map("bulk_import_jobs")
}

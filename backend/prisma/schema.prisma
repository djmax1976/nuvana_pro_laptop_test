// Generate to backend/node_modules for backend code
generator client {
  provider      = "prisma-client-js"
  output        = "../node_modules/.prisma/client"
  // Include Alpine Linux (musl) binary for Docker production deployment
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

// Generate to root/node_modules for test files
generator clientRoot {
  provider      = "prisma-client-js"
  output        = "../../node_modules/.prisma/client"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  user_id                     String                  @id @default(uuid()) @db.Uuid
  email                       String                  @unique @db.VarChar(255)
  name                        String                  @db.VarChar(255)
  auth_provider_id            String?                 @unique @db.VarChar(255)
  status                      String                  @default("ACTIVE") @db.VarChar(50)
  created_at                  DateTime                @default(now()) @db.Timestamptz(6)
  updated_at                  DateTime                @default(now()) @updatedAt @db.Timestamptz(6)
  password_hash               String?                 @db.VarChar(255)
  public_id                   String                  @unique @db.VarChar(30)
  is_client_user              Boolean                 @default(false)
  audit_logs                  AuditLog[]
  owned_companies             Company[]               @relation("CompanyOwner")
  shifts_opened               Shift[]                 @relation("ShiftOpener")
  shifts_approved             Shift[]                 @relation("ShiftApprover")
  transactions                Transaction[]           @relation("TransactionCashier")
  assigned_roles              UserRole[]              @relation("UserRoleAssigner")
  user_roles                  UserRole[]
  client_role_permissions     ClientRolePermission[]  @relation("ClientRolePermissionOwner")
  roles_created               Role[]                  @relation("RoleCreator")
  roles_deleted               Role[]                  @relation("RoleDeleter")
  company_roles_assigned      CompanyAllowedRole[]    @relation("CompanyAllowedRoleAssigner")
  bulk_import_jobs            BulkImportJob[]         @relation("BulkImportJobUser")
  variance_approvals          LotteryVariance[]       @relation("VarianceApprover")
  cashiers_created            Cashier[]               @relation("CashierCreatedBy")
  cashiers_updated            Cashier[]               @relation("CashierUpdatedBy")
  cashier_sessions_auth       CashierSession[]        @relation("CashierSessionAuthenticator")
  store_logins                Store[]                 @relation("StoreLogin") // Stores where this user is the store login credential
  ticket_serials              LotteryTicketSerial[]   @relation("TicketCashier")
  pack_bin_history            LotteryPackBinHistory[] @relation("PackMover")
  packs_activated             LotteryPack[]           @relation("PackActivatedBy")
  packs_depleted              LotteryPack[]           @relation("PackDepletedBy")
  packs_serial_override_approved LotteryPack[]        @relation("PackSerialOverrideApprovedBy")
  packs_mark_sold_approved       LotteryPack[]        @relation("PackMarkSoldApprovedBy")
  manual_entry_authorizations LotteryShiftClosing[]   @relation("ManualEntryAuthorizer")
  lottery_days_opened         LotteryBusinessDay[]    @relation("LotteryDayOpenedBy")
  lottery_days_closed         LotteryBusinessDay[]    @relation("LotteryDayClosedBy")
  lottery_days_pending_close  LotteryBusinessDay[]    @relation("LotteryDayPendingCloseBy")
  lottery_games_created       LotteryGame[]           @relation("LotteryGameCreator")
  tender_types_created        TenderType[]            @relation("TenderTypeCreatedBy")
  departments_created         Department[]            @relation("DepartmentCreatedBy")
  tax_rates_created           TaxRate[]               @relation("TaxRateCreatedBy")
  pos_integrations_created    POSIntegration[]        @relation("POSIntegrationCreatedBy")
  pos_sync_logs_triggered     POSSyncLog[]            @relation("POSSyncLogTriggeredBy")
  // POS Audit relations (Phase 0)
  pos_audits_accessed         POSDataExchangeAudit[]  @relation("POSAuditAccessedBy")
  // NAXML Scheduled Export relations (Phase 2)
  scheduled_exports_created   NAXMLScheduledExport[]  @relation("ScheduledExportCreatedBy")
  // Shift Summary relations (Phase 2.1)
  shift_summaries_opened      ShiftSummary[]          @relation("ShiftSummaryOpenedBy")
  shift_summaries_closed      ShiftSummary[]          @relation("ShiftSummaryClosedBy")
  shift_summaries_cashier     ShiftSummary[]          @relation("ShiftSummaryCashier")
  shift_summaries_variance    ShiftSummary[]          @relation("ShiftSummaryVarianceApprover")
  // Day Summary relations (Phase 3.1)
  day_summaries_closed        DaySummary[]            @relation("DaySummaryClosedBy")
  // X/Z Report relations (Phase 4)
  x_reports_generated         XReport[]               @relation("XReportGeneratedBy")
  z_reports_generated         ZReport[]               @relation("ZReportGeneratedBy")
  // Scanned Documents (OCR Feature)
  documents_scanned           ScannedDocument[]       @relation("ScannedDocumentScannedBy")
  documents_verified          ScannedDocument[]       @relation("ScannedDocumentVerifiedBy")
  documents_rejected          ScannedDocument[]       @relation("ScannedDocumentRejectedBy")
  // Lottery Game Import relations
  lottery_game_imports        LotteryGameImport[]     @relation("LotteryGameImportCreatedBy")

  @@index([email])
  @@index([status])
  @@index([public_id])
  @@index([is_client_user])
  @@map("users")
}

model Company {
  company_id    String               @id @default(uuid()) @db.Uuid
  name          String               @db.VarChar(255)

  // === LEGACY ADDRESS FIELD (DEPRECATED) ===
  // @deprecated Use structured address fields below
  // Will be removed in future migration after data migration complete
  address       String?              @db.VarChar(500)

  // === STRUCTURED ADDRESS FIELDS ===
  // Enterprise-grade address storage following Square/Shopify patterns
  // Enables address validation, tax jurisdiction, and geographic filtering

  // Street address line 1 (e.g., "123 Main Street")
  address_line1 String? @db.VarChar(255)

  // Street address line 2 (e.g., "Suite 100", "Building A")
  address_line2 String? @db.VarChar(255)

  // City name (denormalized for display, validated against state)
  city String? @db.VarChar(100)

  // FK to us_states - determines available lottery games and tax jurisdiction
  state_id String? @db.Uuid

  // FK to us_counties - critical for future tax jurisdiction calculation
  county_id String? @db.Uuid

  // ZIP code (5-digit or ZIP+4 format: 12345 or 12345-6789)
  zip_code String? @db.VarChar(10)

  // === EXISTING FIELDS ===
  status        String               @default("ACTIVE") @db.VarChar(50)
  created_at    DateTime             @default(now()) @db.Timestamptz(6)
  updated_at    DateTime             @default(now()) @updatedAt @db.Timestamptz(6)
  owner_user_id String               @db.Uuid
  public_id     String               @unique @db.VarChar(30)

  // === RELATIONS ===
  owner         User                 @relation("CompanyOwner", fields: [owner_user_id], references: [user_id], onDelete: Cascade)
  state         USState?             @relation("CompanyState", fields: [state_id], references: [state_id], onDelete: Restrict)
  county        USCounty?            @relation("CompanyCounty", fields: [county_id], references: [county_id], onDelete: SetNull)
  stores        Store[]
  user_roles    UserRole[]
  allowed_roles CompanyAllowedRole[] @relation("CompanyAllowedRoleCompany")
  tender_types  TenderType[]         @relation("TenderTypeClient")
  departments   Department[]         @relation("DepartmentClient")
  tax_rates     TaxRate[]            @relation("TaxRateClient")
  // POS Audit relations (Phase 0)
  pos_audits    POSDataExchangeAudit[]
  // Scanned Documents (OCR Feature)
  scanned_documents ScannedDocument[]

  // === INDEXES ===
  @@index([owner_user_id])
  @@index([status])
  @@index([public_id])
  @@index([state_id])
  @@index([county_id])
  @@index([zip_code])
  @@map("companies")
}

model Store {
  store_id   String @id @default(uuid()) @db.Uuid
  company_id String @db.Uuid
  name       String @db.VarChar(255)

  // === LEGACY LOCATION FIELD (DEPRECATED) ===
  // @deprecated Use structured address fields below
  // Will be removed in future migration after data migration complete
  location_json Json?

  // === STRUCTURED ADDRESS FIELDS ===
  // Enterprise-grade address storage for store physical location
  // CRITICAL: state_id determines which lottery games are visible to this store

  // Street address line 1 (e.g., "456 Commerce Drive")
  address_line1 String? @db.VarChar(255)

  // Street address line 2 (e.g., "Unit 5", "Next to Walmart")
  address_line2 String? @db.VarChar(255)

  // City name (denormalized for display)
  city String? @db.VarChar(100)

  // FK to us_states - CRITICAL: determines lottery game visibility
  // After migration, this will become NOT NULL (required)
  // Stores can only see lottery games scoped to their state
  state_id String? @db.Uuid

  // FK to us_counties - for future tax jurisdiction calculation
  // County must belong to the store's state (enforced at application level)
  county_id String? @db.Uuid

  // ZIP code (5-digit or ZIP+4 format: 12345 or 12345-6789)
  zip_code String? @db.VarChar(10)

  // === LOTTERY CONFIGURATION ===
  // Number of lottery bins configured for this store
  // Owner sets this value, system auto-creates/syncs bin rows
  // Valid range: 0-200 (null means not configured yet)
  lottery_bin_count Int? @db.Integer

  // === EXISTING FIELDS ===
  timezone            String   @default("America/New_York") @db.VarChar(50)
  status              String   @default("ACTIVE") @db.VarChar(50)
  created_at          DateTime @default(now()) @db.Timestamptz(6)
  updated_at          DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  configuration       Json?
  public_id           String   @unique @db.VarChar(30)
  store_login_user_id String?  @db.Uuid // Optional FK to User - the CLIENT_USER login credential for this store's dashboard

  // === RELATIONS ===
  company               Company                  @relation(fields: [company_id], references: [company_id], onDelete: Cascade)
  state                 USState?                 @relation("StoreState", fields: [state_id], references: [state_id], onDelete: Restrict)
  county                USCounty?                @relation("StoreCounty", fields: [county_id], references: [county_id], onDelete: SetNull)
  store_login           User?                    @relation("StoreLogin", fields: [store_login_user_id], references: [user_id], onDelete: SetNull)
  pos_terminals         POSTerminal[]
  shifts                Shift[]
  cashiers              Cashier[]
  transactions          Transaction[]
  user_roles            UserRole[]
  cashier_sessions      CashierSession[]
  lottery_packs         LotteryPack[]
  lottery_bins          LotteryBin[]
  bin_configuration     LotteryBinConfiguration?
  lottery_business_days LotteryBusinessDay[]
  lottery_games         LotteryGame[]            @relation("LotteryGameStore")
  tax_rates             TaxRate[]                @relation("TaxRateStore")
  pos_integration       POSIntegration?          @relation("StorePOSIntegration")
  tender_types          TenderType[]             @relation("TenderTypeStore")
  departments           Department[]             @relation("DepartmentStore")
  // Shift Summary relation (Phase 2.1)
  shift_summaries       ShiftSummary[]
  // Day Summary relation (Phase 3.1)
  day_summaries         DaySummary[]
  // X/Z Report relations (Phase 4)
  x_reports             XReport[]
  z_reports             ZReport[]
  // POS Audit relations (Phase 0)
  pos_audits            POSDataExchangeAudit[]
  // NAXML Infrastructure relations (Phase 1)
  naxml_file_logs       NAXMLFileLog[]
  file_watcher_config   POSFileWatcherConfig?
  // NAXML Scheduled Export relations (Phase 2)
  scheduled_exports     NAXMLScheduledExport[]
  scheduled_export_logs NAXMLScheduledExportLog[]
  // Scanned Documents (OCR Feature)
  scanned_documents     ScannedDocument[]

  // === INDEXES ===
  @@index([company_id])
  @@index([status])
  @@index([public_id])
  @@index([store_login_user_id])
  @@index([state_id])
  @@index([county_id])
  @@index([zip_code])
  // Composite index for lottery game filtering by state
  @@index([state_id, status])
  @@map("stores")
}

/// Cashier model with soft-delete semantics
/// 
/// SOFT-DELETE SEMANTICS:
/// - disabled_at IS NULL = cashier is active (authoritative field for filtering)
/// - disabled_at IS NOT NULL = cashier is soft-deleted
/// - is_active is a denormalized boolean for quick checks and backward compatibility
/// 
/// RULES:
/// - When disabling: set is_active=false AND disabled_at=now() atomically
/// - When re-enabling: set is_active=true AND disabled_at=NULL atomically
/// - All queries MUST filter by disabled_at IS NULL (not is_active) to ensure consistency
/// - is_active should be kept in sync with disabled_at for backward compatibility
model Cashier {
  cashier_id             String    @id @default(uuid()) @db.Uuid
  store_id               String    @db.Uuid
  employee_id            String    @db.VarChar(4) // 4-digit zero-padded, unique per store
  name                   String    @db.VarChar(255)
  pin_hash               String    @db.VarChar(255) // bcrypt hashed
  sha256_pin_fingerprint String?   @db.VarChar(64) // SHA-256 hex digest for fast uniqueness checks
  is_active              Boolean   @default(true) // Denormalized: true when disabled_at IS NULL, false when disabled_at IS NOT NULL
  hired_on               DateTime  @db.Date
  termination_date       DateTime? @db.Date
  created_at             DateTime  @default(now()) @db.Timestamptz(6)
  updated_at             DateTime  @default(now()) @updatedAt @db.Timestamptz(6)
  disabled_at            DateTime? @db.Timestamptz(6) // Authoritative: NULL = active, NOT NULL = soft-deleted
  created_by             String    @db.Uuid
  updated_by             String?   @db.Uuid

  store                  Store                  @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  creator                User                   @relation("CashierCreatedBy", fields: [created_by], references: [user_id])
  updater                User?                  @relation("CashierUpdatedBy", fields: [updated_by], references: [user_id])
  shifts                 Shift[]
  sessions               CashierSession[]
  lotteryShiftClosings   LotteryShiftClosing[]  @relation("LotteryShiftClosingCashier")
  // Scanned Documents (OCR Feature)
  scanned_documents      ScannedDocument[]

  @@unique([store_id, employee_id])
  @@unique([store_id, pin_hash])
  @@unique([store_id, sha256_pin_fingerprint])
  @@index([store_id])
  // Note: No single-column index on employee_id - all queries filter by store_id too
  // The composite unique index (store_id, employee_id) handles these efficiently
  @@index([is_active])
  @@index([disabled_at])
  @@index([created_by])
  @@index([updated_by])
  @@map("cashiers")
}

model Role {
  role_id                 String                 @id @default(uuid()) @db.Uuid
  scope                   String                 @db.VarChar(50)
  code                    String                 @unique @db.VarChar(100)
  description             String?
  is_system_role          Boolean                @default(false) // Protects core roles from deletion
  created_by              String?                @db.Uuid // Super Admin who created this role
  deleted_at              DateTime?              @db.Timestamptz(6) // Soft delete timestamp (NULL = active)
  deleted_by              String?                @db.Uuid // Super Admin who deleted this role
  created_at              DateTime               @default(now()) @db.Timestamptz(6)
  updated_at              DateTime               @default(now()) @updatedAt @db.Timestamptz(6)
  role_permissions        RolePermission[]
  user_roles              UserRole[]
  client_role_permissions ClientRolePermission[] @relation("ClientRolePermissionRole")
  company_allowed_roles   CompanyAllowedRole[]   @relation("CompanyAllowedRoleRole")
  creator                 User?                  @relation("RoleCreator", fields: [created_by], references: [user_id])
  deleter                 User?                  @relation("RoleDeleter", fields: [deleted_by], references: [user_id])

  @@index([scope])
  @@index([code])
  @@index([deleted_at])
  @@index([is_system_role])
  @@map("roles")
}

model Permission {
  permission_id           String                 @id @default(uuid()) @db.Uuid
  code                    String                 @unique @db.VarChar(100)
  description             String?
  created_at              DateTime               @default(now()) @db.Timestamptz(6)
  role_permissions        RolePermission[]
  client_role_permissions ClientRolePermission[] @relation("ClientRolePermissionPermission")

  @@index([code])
  @@map("permissions")
}

model UserRole {
  user_role_id String   @id @default(uuid()) @db.Uuid
  user_id      String   @db.Uuid
  role_id      String   @db.Uuid
  company_id   String?  @db.Uuid
  store_id     String?  @db.Uuid
  assigned_by  String?  @db.Uuid
  assigned_at  DateTime @default(now()) @db.Timestamptz(6)
  status       String   @default("ACTIVE") @db.VarChar(50)
  assigner     User?    @relation("UserRoleAssigner", fields: [assigned_by], references: [user_id])
  company      Company? @relation(fields: [company_id], references: [company_id], onDelete: Cascade)
  role         Role     @relation(fields: [role_id], references: [role_id], onDelete: Cascade)
  store        Store?   @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  user         User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@unique([user_id, role_id, company_id, store_id])
  @@index([user_id])
  @@index([company_id])
  @@index([store_id])
  @@index([status])
  @@map("user_roles")
}

model RolePermission {
  role_id       String     @db.Uuid
  permission_id String     @db.Uuid
  permission    Permission @relation(fields: [permission_id], references: [permission_id], onDelete: Cascade)
  role          Role       @relation(fields: [role_id], references: [role_id], onDelete: Cascade)

  @@id([role_id, permission_id])
  @@index([role_id])
  @@index([permission_id])
  @@map("role_permissions")
}

/// Client Role Permission - Allows Client Owners to customize STORE scope role permissions
/// Overrides the system default RolePermission settings for the client's users
/// Tenant isolation is enforced via owner_user_id (client owner's user_id)
model ClientRolePermission {
  client_role_permission_id String   @id @default(uuid()) @db.Uuid
  owner_user_id             String   @db.Uuid // Client owner's user_id for tenant isolation
  role_id                   String   @db.Uuid // STORE scope role being customized
  permission_id             String   @db.Uuid // Permission being toggled
  is_enabled                Boolean  @default(true) // Override state: true = granted, false = revoked
  created_at                DateTime @default(now()) @db.Timestamptz(6)
  updated_at                DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  owner      User       @relation("ClientRolePermissionOwner", fields: [owner_user_id], references: [user_id], onDelete: Cascade)
  role       Role       @relation("ClientRolePermissionRole", fields: [role_id], references: [role_id], onDelete: Cascade)
  permission Permission @relation("ClientRolePermissionPermission", fields: [permission_id], references: [permission_id], onDelete: Cascade)

  @@unique([owner_user_id, role_id, permission_id])
  @@index([owner_user_id])
  @@index([role_id])
  @@map("client_role_permissions")
}

/// Company Allowed Role - Controls which roles are available to each company
/// Super Admin assigns roles to companies - Client Owner can only see/customize allowed roles
/// This enables role access control at the company level
model CompanyAllowedRole {
  company_allowed_role_id String   @id @default(uuid()) @db.Uuid
  company_id              String   @db.Uuid
  role_id                 String   @db.Uuid
  assigned_by             String   @db.Uuid // Super Admin who granted access
  assigned_at             DateTime @default(now()) @db.Timestamptz(6)

  company  Company @relation("CompanyAllowedRoleCompany", fields: [company_id], references: [company_id], onDelete: Cascade)
  role     Role    @relation("CompanyAllowedRoleRole", fields: [role_id], references: [role_id], onDelete: Cascade)
  assigner User    @relation("CompanyAllowedRoleAssigner", fields: [assigned_by], references: [user_id])

  @@unique([company_id, role_id])
  @@index([company_id])
  @@index([role_id])
  @@map("company_allowed_roles")
}

/// AuditLog - Partitioned by month on timestamp for efficient querying and retention
/// Primary key is composite (log_id, timestamp) for partitioning support
model AuditLog {
  log_id     String   @default(uuid()) @db.Uuid
  user_id    String?  @db.Uuid
  action     String   @db.VarChar(50)
  table_name String   @db.VarChar(100)
  record_id  String   @db.Uuid
  old_values Json?
  new_values Json?
  reason     String?
  ip_address String?  @db.VarChar(45)
  user_agent String?
  timestamp  DateTime @default(now()) @db.Timestamptz(6)
  user       User?    @relation(fields: [user_id], references: [user_id])

  @@id([log_id, timestamp])
  @@index([user_id])
  @@index([table_name])
  @@index([timestamp])
  @@index([record_id])
  @@index([table_name, timestamp])
  @@index([user_id, timestamp])
  @@map("audit_logs")
}

enum ShiftStatus {
  NOT_STARTED
  OPEN
  ACTIVE
  CLOSING
  RECONCILING
  CLOSED
  VARIANCE_REVIEW
}

// ============================================================================
// LEGACY POS ENUMS (POSTerminal connection types - keep for backward compat)
// ============================================================================
enum POSConnectionType {
  NETWORK
  API
  WEBHOOK
  FILE
  MANUAL
}

enum POSVendorType {
  GENERIC
  SQUARE
  CLOVER
  TOAST
  LIGHTSPEED
  CUSTOM
}

// ============================================================================
// POS INTEGRATION ENUMS (Phase 1.6)
// ============================================================================
// New POS system integration enums for auto-onboarding
// ============================================================================

/// POS System Types - Different POS vendors and their protocols
enum POSSystemType {
  GILBARCO_PASSPORT // Gilbarco Passport POS (XML protocol)
  GILBARCO_NAXML // Gilbarco Passport NAXML file-based exchange (XMLGateway)
  GILBARCO_COMMANDER // Gilbarco Commander (older XML)
  VERIFONE_RUBY2 // Verifone Ruby2
  VERIFONE_COMMANDER // Verifone Commander
  VERIFONE_SAPPHIRE // Verifone Sapphire
  CLOVER_REST // Clover POS (REST API)
  ORACLE_SIMPHONY // Oracle MICROS Simphony
  NCR_ALOHA // NCR Aloha
  LIGHTSPEED_REST // Lightspeed POS (REST API)
  SQUARE_REST // Square POS (REST API)
  TOAST_REST // Toast POS (REST API)
  GENERIC_XML // Generic XML interface
  GENERIC_REST // Generic REST API
  MANUAL_ENTRY // No POS integration (manual entry)
}

/// POS Authentication Types
enum POSAuthType {
  NONE // No authentication required
  API_KEY // Simple API key in header
  BASIC_AUTH // HTTP Basic Authentication
  OAUTH2 // OAuth 2.0 flow
  CERTIFICATE // Client certificate auth
  CUSTOM // Custom authentication scheme
}

/// POS Sync Status
enum POSSyncStatus {
  PENDING // Waiting to start
  IN_PROGRESS // Currently syncing
  SUCCESS // Completed successfully
  PARTIAL_SUCCESS // Some entities failed
  FAILED // Complete failure
  TIMEOUT // Connection timeout
  AUTH_ERROR // Authentication failed
  CONNECTION_ERROR // Connection failed
}

/// POS Sync Trigger Type
enum POSSyncTrigger {
  SCHEDULED // Automatic scheduled sync
  MANUAL // User-triggered sync
  INITIAL_SETUP // First-time onboarding
  RECONNECT // After connection restored
  WEBHOOK // POS-initiated webhook
  ENTITY_CHANGE // Triggered by entity change in POS
}

// ============================================================================
// POS DATA EXCHANGE AUDIT ENUMS (Phase 0: Mandatory Audit Infrastructure)
// ============================================================================

enum POSExchangeType {
  FILE_IMPORT // File imported from POS
  FILE_EXPORT // File exported to POS
  API_REQUEST // API request to POS
  API_RESPONSE // API response from POS
  WEBHOOK // Webhook from POS
  SYNC_OPERATION // General sync operation
}

enum POSDataCategory {
  TRANSACTION // Transaction data
  PRICEBOOK // Price book/items
  DEPARTMENT // Department/category data
  TENDER_TYPE // Payment methods
  TAX_RATE // Tax rates
  EMPLOYEE // Employee data
  CASHIER // Cashier data
  INVENTORY // Inventory data
  FINANCIAL // Financial/settlement data
  PII // Personal identifiable information
  SYSTEM_CONFIG // System configuration
}

enum POSAuditStatus {
  PENDING // Audit record created, processing not started
  PROCESSING // Currently processing
  SUCCESS // Processing completed successfully
  PARTIAL // Partially successful
  FAILED // Processing failed
  REJECTED // Rejected by validation
}

enum POSRetentionPolicy {
  STANDARD // 7 years (default for financial records)
  EXTENDED // 10 years
  PERMANENT // Never expires
  PII_RESTRICTED // 2 years or upon request
}

enum POSTerminalStatus {
  ACTIVE
  INACTIVE
  PENDING
  ERROR
}

enum SyncStatus {
  NEVER
  SUCCESS
  FAILED
  IN_PROGRESS
}

enum LotteryGameStatus {
  ACTIVE
  INACTIVE
  DISCONTINUED
}

enum LotteryPackStatus {
  RECEIVED
  ACTIVE
  DEPLETED
  RETURNED
}

/// Lottery Pack Depletion Reason - Tracks how a pack became depleted
/// Used for audit trail and distinguishing manual vs automatic depletion
enum LotteryPackDepletionReason {
  SHIFT_CLOSE     // Depleted during shift/day closing (ending serial = serial_end)
  AUTO_REPLACED   // Auto-depleted when new pack activated in same bin
  MANUAL_SOLD_OUT // Manually marked as sold out by user
  POS_LAST_TICKET // Future: POS reported last ticket sold
}

enum LotteryConfigType {
  PACK_VALUE
  TICKET_PRICE
}

// ============================================================================
// GEOGRAPHIC REFERENCE TABLES - US States, Counties, Cities, ZIP Codes
// ============================================================================
// Enterprise-grade geographic data management for:
// - State-scoped lottery games (primary use case)
// - Address validation for Company/Store
// - Future: Automated tax jurisdiction calculation
// - Future: Regional compliance and reporting
//
// Design Principles:
// - FIPS codes for government compliance (Federal Information Processing Standards)
// - Hierarchical relationships: State > County > City > ZIP
// - Soft delete via is_active flag for data integrity
// - Extensible for future tax rate and compliance data
// ============================================================================

/// US State - Reference table for US states and territories
/// Contains FIPS codes for government compliance and tax jurisdiction integration
/// Used for lottery game scoping, store assignment, and address validation
///
/// ENTERPRISE FEATURES:
/// - FIPS code (2-digit) for federal reporting standards
/// - ISO 3166-2:US compliant state codes
/// - Lottery enablement flag for multi-state support
/// - Extensible for future tax rate storage
///
/// USAGE:
/// - Store.state_id FK determines lottery game visibility
/// - LotteryGame.state_id scopes games to specific states
/// - SuperAdmin creates state-scoped games visible to all stores in that state
model USState {
  state_id String @id @default(uuid()) @db.Uuid

  // === STANDARD IDENTIFIERS ===
  // ISO 3166-2:US subdivision code (e.g., GA, NC, SC)
  code String @unique @db.Char(2)

  // Full state name for display (e.g., Georgia, North Carolina)
  name String @db.VarChar(100)

  // Federal Information Processing Standard code
  // 2-digit code used by US Census and tax authorities
  // GA=13, NC=37, SC=45
  // Reference: https://www.census.gov/library/reference/code-lists/ansi.html
  fips_code String @unique @db.Char(2)

  // === STATUS ===
  // Soft delete flag - allows disabling without data loss
  is_active Boolean @default(true)

  // === LOTTERY CONFIGURATION ===
  // Whether state lottery operations are enabled
  // Used to filter states in lottery game creation UI
  lottery_enabled Boolean @default(true)

  // === FUTURE EXPANSION (Nullable) ===
  // Default timezone for stores in this state (IANA format)
  timezone_default String? @db.VarChar(50)

  // Base state sales tax rate (future: Avalara/TaxJar integration)
  tax_rate_state Decimal? @db.Decimal(5, 4)

  // State lottery commission contact info (future)
  lottery_commission_name  String? @db.VarChar(255)
  lottery_commission_phone String? @db.VarChar(20)
  lottery_commission_url   String? @db.VarChar(500)

  // === TIMESTAMPS ===
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // === RELATIONS ===
  counties             USCounty[]
  zip_codes            USZipCode[]
  cities               USCity[]
  stores               Store[]              @relation("StoreState")
  companies            Company[]            @relation("CompanyState")
  lottery_games        LotteryGame[]        @relation("LotteryGameState")
  lottery_game_imports LotteryGameImport[]  @relation("LotteryGameImportState")

  // === INDEXES ===
  @@index([code])
  @@index([fips_code])
  @@index([is_active])
  @@index([lottery_enabled])
  @@index([is_active, lottery_enabled])
  @@map("us_states")
}

/// US County - Reference table for US counties
/// Contains 5-digit FIPS codes for tax jurisdiction determination
///
/// ENTERPRISE FEATURES:
/// - Full FIPS code (5-digit: state + county) for tax jurisdiction mapping
/// - County-level tax rate support for future Avalara/TaxJar integration
/// - Population data for analytics and reporting
///
/// TAX JURISDICTION:
/// County is CRITICAL for accurate sales tax calculation in the US.
/// Same city name can exist in multiple counties with different tax rates.
/// Example: Springfield exists in 30+ US states with varying county taxes.
model USCounty {
  county_id String @id @default(uuid()) @db.Uuid
  state_id  String @db.Uuid

  // === IDENTIFICATION ===
  // County name (e.g., Fulton, DeKalb, Cobb)
  name String @db.VarChar(100)

  // Full 5-digit FIPS code (state 2-digit + county 3-digit)
  // Example: 13121 = Georgia (13) + Fulton County (121)
  // Reference: https://www.census.gov/library/reference/code-lists/ansi.html
  fips_code String @unique @db.Char(5)

  // === STATUS ===
  is_active Boolean @default(true)

  // === FUTURE EXPANSION ===
  // County-level sales tax rate (future: tax automation)
  tax_rate_county Decimal? @db.Decimal(5, 4)

  // Population for analytics (US Census data)
  population Int?

  // County seat city name
  county_seat String? @db.VarChar(100)

  // === TIMESTAMPS ===
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // === RELATIONS ===
  // RESTRICT: Cannot delete state with counties
  state     USState     @relation(fields: [state_id], references: [state_id], onDelete: Restrict)
  cities    USCity[]
  zip_codes USZipCode[]
  stores    Store[]     @relation("StoreCounty")
  companies Company[]   @relation("CompanyCounty")

  // === CONSTRAINTS ===
  // County name must be unique within a state
  @@unique([state_id, name], name: "us_counties_state_name_unique")

  // === INDEXES ===
  @@index([state_id])
  @@index([name])
  @@index([fips_code])
  @@index([is_active])
  @@index([state_id, is_active])
  @@map("us_counties")
}

/// US City - Reference table for US cities
/// Used for address validation and future city-level tax rates
///
/// NOTE ON CITY-COUNTY RELATIONSHIP:
/// Some cities span multiple counties (e.g., Atlanta spans Fulton and DeKalb).
/// This table maps to the PRIMARY county. For precise tax jurisdiction,
/// use ZIP code + address geocoding with a service like Avalara.
///
/// ENTERPRISE FEATURES:
/// - Supports city-level tax rates (separate from county/state)
/// - Links to primary county for basic jurisdiction
/// - Population data for analytics
model USCity {
  city_id   String @id @default(uuid()) @db.Uuid
  county_id String @db.Uuid
  state_id  String @db.Uuid

  // === IDENTIFICATION ===
  // City name (e.g., Atlanta, Charlotte, Columbia)
  name String @db.VarChar(100)

  // === STATUS ===
  is_active Boolean @default(true)

  // === FUTURE EXPANSION ===
  // City-level sales tax rate (some cities have additional taxes)
  tax_rate_city Decimal? @db.Decimal(5, 4)

  // Population for analytics
  population Int?

  // Incorporated city flag
  is_incorporated Boolean @default(true)

  // === TIMESTAMPS ===
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // === RELATIONS ===
  // RESTRICT: Cannot delete county with cities
  county    USCounty    @relation(fields: [county_id], references: [county_id], onDelete: Restrict)
  state     USState     @relation(fields: [state_id], references: [state_id], onDelete: Restrict)
  zip_codes USZipCode[]

  // === CONSTRAINTS ===
  // City name should be unique within a county (not state - same city name can exist in different counties)
  @@unique([county_id, name], name: "us_cities_county_name_unique")

  // === INDEXES ===
  @@index([county_id])
  @@index([state_id])
  @@index([name])
  @@index([is_active])
  @@index([state_id, name])
  @@map("us_cities")
}

/// US ZIP Code - Reference table for US postal codes
/// Maps ZIP codes to geographic entities for address validation and tax jurisdiction
///
/// DESIGN DECISIONS:
/// - ZIP code is the PRIMARY KEY (natural key, 5-digit, unique by definition)
/// - Links to PRIMARY county/city (ZIP codes can span multiple - use geocoding for precision)
/// - Stores denormalized city_name for performance (most common lookup pattern)
/// - Includes lat/lng for future distance calculations and store locator
///
/// TAX JURISDICTION NOTES:
/// - Same ZIP code can span multiple counties (edge cases)
/// - For precise tax calculation, use address geocoding with Avalara/TaxJar
/// - county_id represents the PRIMARY county (covers majority of addresses in ZIP)
///
/// DATA SOURCE:
/// US Census ZCTA (ZIP Code Tabulation Area) data
/// https://www.census.gov/geographies/reference-files.html
model USZipCode {
  // 5-digit ZIP code as primary key (natural key)
  zip_code String @id @db.Char(5)

  // === GEOGRAPHIC REFERENCES ===
  state_id  String  @db.Uuid
  county_id String? @db.Uuid // Primary county (nullable for edge cases)
  city_id   String? @db.Uuid // Primary city (nullable)

  // Denormalized city name for performance (avoids join for common lookups)
  city_name String @db.VarChar(100)

  // === STATUS ===
  is_active Boolean @default(true)

  // === ZIP+4 SUPPORT (Future) ===
  // JSON array of valid ZIP+4 ranges for this base ZIP
  // Format: [{"from": "0001", "to": "0099"}, ...]
  zip_plus4_ranges Json? @db.JsonB

  // === GEOLOCATION (Future: Store Locator) ===
  // Centroid coordinates for the ZIP code area
  latitude  Decimal? @db.Decimal(9, 6)
  longitude Decimal? @db.Decimal(9, 6)

  // === METADATA ===
  // ZIP code type: STANDARD, PO_BOX, UNIQUE (large volume mailers)
  zip_type String? @db.VarChar(20)

  // Primary vs secondary classification
  is_primary Boolean @default(true)

  // === TIMESTAMPS ===
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // === RELATIONS ===
  // RESTRICT on state: Cannot delete state with ZIP codes
  // SET NULL on county/city: Allow orphaning for flexibility
  state  USState   @relation(fields: [state_id], references: [state_id], onDelete: Restrict)
  county USCounty? @relation(fields: [county_id], references: [county_id], onDelete: SetNull)
  city   USCity?   @relation(fields: [city_id], references: [city_id], onDelete: SetNull)

  // === INDEXES ===
  @@index([state_id])
  @@index([county_id])
  @@index([city_id])
  @@index([city_name])
  @@index([is_active])
  @@index([state_id, city_name])
  // Geospatial index for future store locator
  @@index([latitude, longitude])
  @@map("us_zip_codes")
}

// ============================================================================
// TENDER TYPE (Payment Method) - Lookup/Dimension Table
// ============================================================================
// Replaces hardcoded PaymentMethodEnum with flexible, client-configurable
// payment methods. Supports client-specific customization and soft deletes.
// Phase 1.1: Shift & Day Summary Implementation Plan
// ============================================================================

model TenderType {
  tender_type_id String @id @default(uuid()) @db.Uuid

  // === IDENTIFICATION ===
  code         String  @db.VarChar(50) // e.g., "CASH", "CREDIT", "APPLE_PAY"
  display_name String  @db.VarChar(100) // e.g., "Cash", "Credit Card", "Apple Pay"
  description  String? @db.VarChar(500)

  // === BEHAVIOR FLAGS ===
  is_cash_equivalent  Boolean @default(false) // Affects cash drawer reconciliation
  requires_reference  Boolean @default(false) // Requires reference number (e.g., check #)
  is_electronic       Boolean @default(false) // Card, mobile payment, etc.
  affects_cash_drawer Boolean @default(true) // Does this affect cash drawer count?

  // === CONFIGURATION ===
  sort_order Int     @default(0) // Display order in UI
  icon_name  String? @db.VarChar(50) // Icon identifier for UI
  color_code String? @db.VarChar(7) // Hex color for UI

  // === SCOPE ===
  // NULL = system-wide default, otherwise client-specific
  client_id String? @db.Uuid
  store_id  String? @db.Uuid // Store-specific tender (for POS sync)

  // === POS INTEGRATION (Phase 1.6) ===
  pos_code       String?        @db.VarChar(50) // Code from POS system (e.g., "01", "MOP_CASH")
  pos_source     POSSystemType? // Which POS type this came from
  last_synced_at DateTime?      @db.Timestamptz(6) // When last synced from POS

  // === LIFECYCLE ===
  is_active  Boolean  @default(true) // Soft delete
  is_system  Boolean  @default(false) // System-defined, cannot be deleted
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  created_by String?  @db.Uuid

  // === RELATIONS ===
  client          Company? @relation("TenderTypeClient", fields: [client_id], references: [company_id], onDelete: Cascade)
  created_by_user User?    @relation("TenderTypeCreatedBy", fields: [created_by], references: [user_id], onDelete: SetNull)
  store           Store?   @relation("TenderTypeStore", fields: [store_id], references: [store_id], onDelete: Cascade)

  // Transaction payment relations (Phase 1.5)
  transaction_payments TransactionPayment[]

  // Shift Summary relations (Phase 2.1)
  shift_tender_summaries ShiftTenderSummary[]
  // Day Summary relations (Phase 3.1)
  day_tender_summaries   DayTenderSummary[]

  // === INDEXES ===
  @@unique([code, client_id], name: "unique_tender_code_per_client")
  @@unique([pos_code, store_id], name: "unique_pos_tender_per_store")
  @@index([client_id, is_active])
  @@index([is_active, sort_order])
  @@index([code])
  @@map("tender_types")
}

// ============================================================================
// DEPARTMENT - Lookup/Dimension Table
// ============================================================================
// Configurable product departments for categorizing sales. Supports:
// - Client-specific departments
// - Tax configuration per department
// - Age restriction rules
// - Hierarchical structure (optional parent_id)
// Phase 1.2: Shift & Day Summary Implementation Plan
// ============================================================================

model Department {
  department_id String @id @default(uuid()) @db.Uuid

  // === IDENTIFICATION ===
  code         String  @db.VarChar(50) // e.g., "GROCERY", "TOBACCO", "LOTTERY"
  display_name String  @db.VarChar(100) // e.g., "Grocery", "Tobacco Products"
  description  String? @db.VarChar(500)

  // === HIERARCHY (Optional) ===
  parent_id String? @db.Uuid // For sub-departments
  level     Int     @default(1) // 1 = top level, 2 = sub-department, etc.

  // === TAX CONFIGURATION ===
  is_taxable          Boolean @default(true)
  default_tax_rate_id String? @db.Uuid // FK to TaxRate (Phase 1.3)

  // === REGULATORY ===
  minimum_age      Int?    @db.SmallInt // Age restriction (e.g., 21 for alcohol)
  requires_id_scan Boolean @default(false)

  // === LOTTERY SPECIFIC ===
  is_lottery Boolean @default(false) // Special handling for lottery

  // === CONFIGURATION ===
  sort_order Int     @default(0)
  icon_name  String? @db.VarChar(50)
  color_code String? @db.VarChar(7)

  // === SCOPE ===
  // NULL = system-wide default, otherwise client-specific
  client_id String? @db.Uuid
  store_id  String? @db.Uuid // Store-specific department (for POS sync)

  // === POS INTEGRATION (Phase 1.6) ===
  pos_code       String?        @db.VarChar(50) // Code from POS system (e.g., "01", "PLU_GROCERY")
  pos_source     POSSystemType? // Which POS type this came from
  last_synced_at DateTime?      @db.Timestamptz(6) // When last synced from POS

  // === LIFECYCLE ===
  is_active  Boolean  @default(true) // Soft delete
  is_system  Boolean  @default(false) // System-defined, cannot be deleted
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  created_by String?  @db.Uuid

  // === RELATIONS ===
  client          Company?     @relation("DepartmentClient", fields: [client_id], references: [company_id], onDelete: Cascade)
  created_by_user User?        @relation("DepartmentCreatedBy", fields: [created_by], references: [user_id], onDelete: SetNull)
  parent          Department?  @relation("DepartmentHierarchy", fields: [parent_id], references: [department_id], onDelete: SetNull)
  children        Department[] @relation("DepartmentHierarchy")
  store           Store?       @relation("DepartmentStore", fields: [store_id], references: [store_id], onDelete: Cascade)

  // Transaction line item relations (Phase 1.5)
  transaction_line_items TransactionLineItem[]

  // Tax rate relation (Phase 1.3)
  default_tax_rate TaxRate? @relation("DepartmentDefaultTaxRate", fields: [default_tax_rate_id], references: [tax_rate_id], onDelete: SetNull)

  // Shift Summary relations (Phase 2.1)
  shift_department_summaries ShiftDepartmentSummary[]
  // Day Summary relations (Phase 3.1)
  day_department_summaries   DayDepartmentSummary[]

  // === INDEXES ===
  @@unique([code, client_id], name: "unique_dept_code_per_client")
  @@unique([pos_code, store_id], name: "unique_pos_dept_per_store")
  @@index([client_id, is_active])
  @@index([parent_id])
  @@index([is_active, sort_order])
  @@index([code])
  @@index([is_lottery])
  @@map("departments")
}

// ============================================================================
// TAX RATE - Lookup/Dimension Table
// ============================================================================
// Configurable tax rates for different jurisdictions and categories.
// Supports effective date ranges for historical accuracy.
// Phase 1.3: Shift & Day Summary Implementation Plan
// ============================================================================

model TaxRate {
  tax_rate_id String @id @default(uuid()) @db.Uuid

  // === IDENTIFICATION ===
  code         String  @db.VarChar(50) // e.g., "STATE_TX", "LOCAL_AUSTIN"
  display_name String  @db.VarChar(100) // e.g., "Texas State Tax"
  description  String? @db.VarChar(500)

  // === TAX DETAILS ===
  rate      Decimal     @db.Decimal(6, 5) // e.g., 0.08250 for 8.25%
  rate_type TaxRateType @default(PERCENTAGE) // PERCENTAGE or FIXED

  // === JURISDICTION ===
  jurisdiction_level TaxJurisdictionLevel @default(STATE)
  jurisdiction_code  String?              @db.VarChar(20) // e.g., "TX", "48453" (FIPS)

  // === EFFECTIVE DATES ===
  effective_from DateTime  @db.Date
  effective_to   DateTime? @db.Date // NULL = currently active

  // === CONFIGURATION ===
  sort_order  Int     @default(0)
  is_compound Boolean @default(false) // Applied on top of other taxes

  // === SCOPE ===
  client_id String? @db.Uuid // NULL = system default
  store_id  String? @db.Uuid // Store-specific override

  // === POS INTEGRATION (Phase 1.6) ===
  pos_code       String?        @db.VarChar(50) // Code from POS system (e.g., "TAX1", "TAX_STATE")
  pos_source     POSSystemType? // Which POS type this came from
  last_synced_at DateTime?      @db.Timestamptz(6) // When last synced from POS

  // === LIFECYCLE ===
  is_active  Boolean  @default(true)
  is_system  Boolean  @default(false)
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  created_by String?  @db.Uuid

  // === RELATIONS ===
  client          Company? @relation("TaxRateClient", fields: [client_id], references: [company_id], onDelete: Cascade)
  store           Store?   @relation("TaxRateStore", fields: [store_id], references: [store_id], onDelete: Cascade)
  created_by_user User?    @relation("TaxRateCreatedBy", fields: [created_by], references: [user_id], onDelete: SetNull)

  // Department relations
  departments Department[] @relation("DepartmentDefaultTaxRate")

  // Transaction line item relations (Phase 2.4)
  transaction_line_items TransactionLineItem[]

  // Shift Summary relations (Phase 2.1)
  shift_tax_summaries ShiftTaxSummary[]
  // Day Summary relations (Phase 3.1)
  day_tax_summaries   DayTaxSummary[]

  // === INDEXES ===
  @@unique([code, client_id, store_id, effective_from], name: "unique_tax_rate_per_scope_date")
  @@unique([pos_code, store_id], name: "unique_pos_tax_per_store")
  @@index([client_id, store_id, is_active])
  @@index([effective_from, effective_to])
  @@index([code])
  @@index([jurisdiction_level])
  @@index([store_id])
  @@map("tax_rates")
}

enum TaxRateType {
  PERCENTAGE // Rate is a percentage (e.g., 0.0825 = 8.25%)
  FIXED // Rate is a fixed amount per unit
}

enum TaxJurisdictionLevel {
  FEDERAL
  STATE
  COUNTY
  CITY
  DISTRICT // Special tax district
  COMBINED // Pre-combined rate
}

model Shift {
  shift_id          String                @id @default(uuid()) @db.Uuid
  store_id          String                @db.Uuid
  opened_by         String                @db.Uuid
  cashier_id        String                @db.Uuid
  pos_terminal_id   String?               @db.Uuid
  opened_at         DateTime              @default(now()) @db.Timestamptz(6)
  closed_at         DateTime?             @db.Timestamptz(6)
  opening_cash      Decimal               @default(0) @db.Decimal(10, 2)
  expected_cash     Decimal?              @db.Decimal(10, 2)
  closing_cash      Decimal?              @db.Decimal(10, 2)
  variance          Decimal?              @db.Decimal(10, 2)
  variance_reason   String?               @db.VarChar(500)
  status            ShiftStatus           @default(NOT_STARTED)
  shift_number      Int?
  approved_by       String?               @db.Uuid
  approved_at       DateTime?             @db.Timestamptz(6)
  created_at        DateTime              @default(now()) @db.Timestamptz(6)
  updated_at        DateTime              @default(now()) @updatedAt @db.Timestamptz(6)
  public_id         String?               @unique @db.VarChar(30)
  external_shift_id String?               @db.VarChar(255)
  external_data     Json?
  synced_at         DateTime?             @db.Timestamptz(6)
  opener            User                  @relation("ShiftOpener", fields: [opened_by], references: [user_id])
  cashier           Cashier               @relation(fields: [cashier_id], references: [cashier_id])
  approver          User?                 @relation("ShiftApprover", fields: [approved_by], references: [user_id])
  pos_terminal      POSTerminal?          @relation(fields: [pos_terminal_id], references: [pos_terminal_id])
  store             Store                 @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  transactions      Transaction[]
  cashier_sessions  CashierSession[]
  lottery_openings  LotteryShiftOpening[]
  lottery_closings  LotteryShiftClosing[]
  lottery_variances LotteryVariance[]
  ticket_serials    LotteryTicketSerial[]
  packs_activated   LotteryPack[]         @relation("PackActivatedInShift")
  packs_depleted    LotteryPack[]         @relation("PackDepletedInShift")
  // Shift Summary relation (Phase 2.1) - one-to-one since summary is created on close
  shift_summary     ShiftSummary?
  // X/Z Report relations (Phase 4)
  x_reports         XReport[]
  z_report          ZReport? // One Z per shift
  // Scanned Documents (OCR Feature)
  scanned_documents ScannedDocument[]

  @@index([store_id])
  @@index([opened_by])
  @@index([cashier_id])
  @@index([pos_terminal_id])
  @@index([status])
  @@index([opened_at])
  @@index([store_id, status])
  @@index([store_id, opened_at])
  @@index([public_id])
  // NOTE: Additional partial index for active shift lookups exists in migration
  // 20251217_add_performance_indexes: idx_shifts_terminal_status_open
  // WHERE pos_terminal_id = X AND status = Y AND closed_at IS NULL
  @@map("shifts")
}

model POSTerminal {
  pos_terminal_id   String            @id @default(uuid()) @db.Uuid
  store_id          String            @db.Uuid
  name              String            @db.VarChar(100)
  device_id         String?           @db.VarChar(255)
  connection_type   POSConnectionType @default(MANUAL)
  connection_config Json?
  vendor_type       POSVendorType     @default(GENERIC)
  terminal_status   POSTerminalStatus @default(ACTIVE)
  last_sync_at      DateTime?         @db.Timestamptz(6)
  sync_status       SyncStatus        @default(NEVER)
  deleted_at        DateTime?         @db.Timestamptz(6) // Soft delete timestamp (NULL = active)
  created_at        DateTime          @default(now()) @db.Timestamptz(6)
  updated_at        DateTime          @default(now()) @updatedAt @db.Timestamptz(6)
  store             Store             @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  shifts            Shift[]
  transactions      Transaction[]
  cashier_sessions  CashierSession[]
  // Scanned Documents (OCR Feature)
  scanned_documents ScannedDocument[]

  @@unique([device_id]) // Global uniqueness (device_id can be null, but if set, must be unique across all stores)
  @@index([store_id])
  @@index([deleted_at])
  @@map("pos_terminals")
}

/// Transaction - Partitioned by month on timestamp for efficient querying
/// Primary key is composite (transaction_id, timestamp) for partitioning support
/// Note: transaction_id is marked @unique for Prisma relations (UUID guarantees uniqueness)
model Transaction {
  transaction_id  String                @unique @default(uuid()) @db.Uuid
  store_id        String                @db.Uuid
  shift_id        String                @db.Uuid
  cashier_id      String                @db.Uuid
  pos_terminal_id String?               @db.Uuid
  timestamp       DateTime              @default(now()) @db.Timestamptz(6)
  subtotal        Decimal               @db.Decimal(10, 2)
  tax             Decimal               @default(0) @db.Decimal(10, 2)
  discount        Decimal               @default(0) @db.Decimal(10, 2)
  total           Decimal               @db.Decimal(10, 2)
  created_at      DateTime              @default(now()) @db.Timestamptz(6)
  public_id       String                @db.VarChar(30)
  line_items      TransactionLineItem[]
  payments        TransactionPayment[]
  cashier         User                  @relation("TransactionCashier", fields: [cashier_id], references: [user_id])
  pos_terminal    POSTerminal?          @relation(fields: [pos_terminal_id], references: [pos_terminal_id])
  shift           Shift                 @relation(fields: [shift_id], references: [shift_id])
  store           Store                 @relation(fields: [store_id], references: [store_id], onDelete: Cascade)

  @@id([transaction_id, timestamp])
  @@unique([public_id, timestamp])
  @@index([store_id])
  @@index([shift_id])
  @@index([cashier_id])
  @@index([pos_terminal_id])
  @@index([timestamp])
  @@index([public_id])
  @@index([store_id, timestamp])
  @@map("transactions")
}

model TransactionLineItem {
  line_item_id   String   @id @default(uuid()) @db.Uuid
  transaction_id String   @db.Uuid
  product_id     String?  @db.Uuid
  sku            String?  @db.VarChar(100)
  name           String   @db.VarChar(255)
  quantity       Int
  unit_price     Decimal  @db.Decimal(10, 2)
  discount       Decimal  @default(0) @db.Decimal(10, 2)
  tax_amount     Decimal  @default(0) @db.Decimal(10, 2) // Per-item tax amount (Phase 1.5)
  line_total     Decimal  @db.Decimal(10, 2)
  created_at     DateTime @default(now()) @db.Timestamptz(6)

  // === NEW: Foreign key to lookup table (Phase 1.5) ===
  department_id   String? @db.Uuid // Optional for backward compatibility
  department_code String? @db.VarChar(50) // Denormalized: Copy of department.code at txn time

  // === NEW: Tax rate tracking (Phase 2.4) ===
  tax_rate_id    String?  @db.Uuid // Optional - FK to TaxRate used for this line item
  tax_rate_code  String?  @db.VarChar(50) // Denormalized: Copy of tax_rate.code at txn time
  tax_rate_value Decimal? @db.Decimal(6, 5) // Denormalized: Tax rate percentage at txn time (e.g., 0.0825)

  // === RELATIONS ===
  transaction Transaction @relation(fields: [transaction_id], references: [transaction_id], onDelete: Cascade)
  department  Department? @relation(fields: [department_id], references: [department_id], onDelete: SetNull)
  tax_rate    TaxRate?    @relation(fields: [tax_rate_id], references: [tax_rate_id], onDelete: SetNull)

  @@index([transaction_id])
  @@index([product_id])
  @@index([department_id])
  @@index([department_code])
  @@index([tax_rate_id])
  @@index([tax_rate_code])
  @@map("transaction_line_items")
}

model TransactionPayment {
  payment_id     String @id @default(uuid()) @db.Uuid
  transaction_id String @db.Uuid
  method         String @db.VarChar(50) // Legacy field - kept for backward compatibility

  // === NEW: Foreign key to lookup table (Phase 1.5) ===
  tender_type_id String? @db.Uuid // Optional for backward compatibility
  tender_code    String? @db.VarChar(50) // Denormalized: Copy of tender_type.code at txn time

  amount     Decimal  @db.Decimal(10, 2)
  reference  String?  @db.VarChar(100)
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // === RELATIONS ===
  transaction Transaction @relation(fields: [transaction_id], references: [transaction_id], onDelete: Cascade)
  tender_type TenderType? @relation(fields: [tender_type_id], references: [tender_type_id], onDelete: SetNull)

  @@index([transaction_id])
  @@index([tender_type_id])
  @@index([tender_code])
  @@map("transaction_payments")
}

/// Bulk Import Job - Tracks bulk transaction import progress and errors
/// Story 3.6: Bulk Transaction Import
/// Tenant isolation enforced via user_id (users can only view their own jobs, admins can view all)
model BulkImportJob {
  job_id         String    @id @default(uuid()) @db.Uuid
  user_id        String    @db.Uuid
  file_name      String    @db.VarChar(255)
  file_type      String    @db.VarChar(10) // 'CSV' or 'JSON'
  total_rows     Int       @default(0)
  processed_rows Int       @default(0)
  error_rows     Int       @default(0)
  status         String    @default("PENDING") @db.VarChar(50) // 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED'
  started_at     DateTime  @default(now()) @db.Timestamptz(6)
  completed_at   DateTime? @db.Timestamptz(6)
  error_summary  Json? // Array of { row_number: number, field: string, error: string }
  user           User      @relation("BulkImportJobUser", fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([user_id])
  @@index([status])
  @@index([started_at])
  @@map("bulk_import_jobs")
}

/// Cashier Terminal Session - Tracks active cashier sessions on terminals
///
/// This model implements the Cashier Session Token pattern for terminal operations:
/// - Created when a cashier authenticates via PIN on a terminal
/// - Required for all terminal operations (shift start, transactions, etc.)
/// - Invalidated on shift end, logout, or expiration
///
/// Security Model:
/// - CLIENT_USER authenticates to access dashboard (web JWT)
/// - CASHIER authenticates via PIN (creates CashierSession)
/// - Terminal operations require BOTH valid JWT AND valid CashierSession
/// - Authorization checks use CASHIER's permissions (SHIFT_OPEN, etc.)
///
/// Story: Terminal Shift Operations
model CashierSession {
  session_id         String    @id @default(uuid()) @db.Uuid
  cashier_id         String    @db.Uuid
  terminal_id        String    @db.Uuid
  store_id           String    @db.Uuid
  session_token_hash String    @unique @db.VarChar(64) // SHA-256 hash of token
  authenticated_by   String    @db.Uuid // CLIENT_USER who was logged in when cashier authenticated
  shift_id           String?   @db.Uuid // Linked once shift starts (nullable until then)
  created_at         DateTime  @default(now()) @db.Timestamptz(6)
  expires_at         DateTime  @db.Timestamptz(6) // Session timeout (configurable, default 12 hours)
  ended_at           DateTime? @db.Timestamptz(6) // When session was explicitly ended
  is_active          Boolean   @default(true)

  // Relations
  cashier       Cashier     @relation(fields: [cashier_id], references: [cashier_id], onDelete: Cascade)
  terminal      POSTerminal @relation(fields: [terminal_id], references: [pos_terminal_id], onDelete: Cascade)
  store         Store       @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  authenticated User        @relation("CashierSessionAuthenticator", fields: [authenticated_by], references: [user_id])
  shift         Shift?      @relation(fields: [shift_id], references: [shift_id])
  // Scanned Documents (OCR Feature)
  scanned_documents ScannedDocument[]

  // Indexes for performance
  @@index([session_token_hash])
  @@index([terminal_id, is_active])
  @@index([cashier_id, is_active])
  @@index([expires_at])
  @@map("cashier_sessions")
}

/// Lottery Game - Represents a lottery scratch-off game
/// Story 6.1: Lottery Game and Pack Data Models
///
/// SCOPING RULES (UPDATED FOR MULTI-STATE SUPPORT):
/// Games can be scoped at two levels with clear priority:
///
/// 1. STATE-SCOPED (PRIMARY - Most Common):
///    - state_id IS NOT NULL, store_id IS NULL
///    - Created by SuperAdmin for a specific state (e.g., Georgia Lottery games)
///    - Visible to ALL stores in that state
///    - Example: Georgia Lottery "Mega Bucks" visible to all GA stores
///
/// 2. STORE-SCOPED (FALLBACK - Rare Edge Cases):
///    - state_id IS NULL, store_id IS NOT NULL
///    - Created by store owner for custom/promotional games
///    - Visible only to that specific store
///    - Example: Store-specific promotional scratch ticket
///
/// LOOKUP PRIORITY:
/// When a store scans a pack, game lookup follows this order:
///   1. Look for STATE-scoped game (game.state_id = store.state_id)
///   2. Fall back to STORE-scoped game (game.store_id = storeId)
///   3. If not found, prompt user to create store-scoped game
///
/// CONSTRAINT:
/// A game must have EITHER state_id OR store_id set (mutually exclusive)
/// This is enforced at the application level during creation/update
model LotteryGame {
  game_id            String            @id @default(uuid()) @db.Uuid
  game_code          String            @db.VarChar(4)
  name               String            @db.VarChar(255)
  description        String?           @db.VarChar(500)
  price              Decimal           @db.Decimal(10, 2)
  tickets_per_pack   Int?              @db.Integer // Computed: pack_value / price (nullable for backward compat)
  pack_value         Decimal           @default(300) @db.Decimal(10, 2) // Total dollar value of pack
  status             LotteryGameStatus @default(ACTIVE)
  created_at         DateTime          @default(now()) @db.Timestamptz(6)
  updated_at         DateTime          @default(now()) @updatedAt @db.Timestamptz(6)
  created_by_user_id String?           @db.Uuid // User who created this game (NULL for legacy/seeded games)

  // === SCOPING FIELDS ===
  // NEW: State-scoped game - visible to all stores in this state
  // SuperAdmin creates these for state lottery games (primary use case)
  state_id String? @db.Uuid

  // EXISTING: Store-scoped game - visible only to this store (fallback/edge case)
  // Store owners can create these for custom promotional games
  store_id String? @db.Uuid

  // === RELATIONS ===
  packs      LotteryPack[]
  created_by User?         @relation("LotteryGameCreator", fields: [created_by_user_id], references: [user_id], onDelete: SetNull)
  state      USState?      @relation("LotteryGameState", fields: [state_id], references: [state_id], onDelete: Restrict)
  store      Store?        @relation("LotteryGameStore", fields: [store_id], references: [store_id], onDelete: Cascade)

  // === UNIQUE CONSTRAINTS ===
  // Game code must be unique within a state (for state-scoped games)
  @@unique([game_code, state_id], name: "lottery_games_game_code_state_unique")
  // Game code must be unique within a store (for store-scoped games)
  @@unique([game_code, store_id], name: "lottery_games_game_code_store_unique")

  // === INDEXES ===
  @@index([name])
  @@index([game_code])
  @@index([status])
  @@index([price])
  @@index([pack_value])
  @@index([state_id])
  @@index([store_id])
  @@index([created_by_user_id])
  // Composite index for state-scoped game lookup (most common query)
  @@index([game_code, state_id, status])
  // Composite index for store-scoped game lookup (fallback query)
  @@index([game_code, store_id, status])
  @@map("lottery_games")
}

/// Lottery Config Value - Stores configurable lottery values (pack values, ticket prices)
/// Used for dropdown selections when creating/editing games
model LotteryConfigValue {
  config_value_id String            @id @default(uuid()) @db.Uuid
  config_type     LotteryConfigType
  amount          Decimal           @db.Decimal(10, 2)
  display_order   Int               @default(0)
  is_active       Boolean           @default(true)
  created_at      DateTime          @default(now()) @db.Timestamptz(6)
  updated_at      DateTime          @default(now()) @updatedAt @db.Timestamptz(6)

  @@unique([config_type, amount])
  @@index([config_type])
  @@index([is_active])
  @@index([config_type, is_active, display_order])
  @@map("lottery_config_values")
}

/// Lottery Pack - Represents a physical pack of lottery tickets
/// Story 6.1: Lottery Game and Pack Data Models
/// Tenant isolation enforced via store_id foreign key (RLS policies will be implemented in future stories)
model LotteryPack {
  pack_id            String            @id @default(uuid()) @db.Uuid
  game_id            String            @db.Uuid
  store_id           String            @db.Uuid
  pack_number        String            @db.VarChar(50)
  serial_start       String            @db.VarChar(100)
  serial_end         String            @db.VarChar(100)
  status             LotteryPackStatus @default(RECEIVED)
  current_bin_id     String?           @db.Uuid
  tickets_sold_count Int               @default(0)
  last_sold_at       DateTime?         @db.Timestamptz(6)
  received_at        DateTime?         @db.Timestamptz(6)
  activated_at       DateTime?         @db.Timestamptz(6)
  depleted_at        DateTime?         @db.Timestamptz(6)
  returned_at        DateTime?         @db.Timestamptz(6)
  created_at         DateTime          @default(now()) @db.Timestamptz(6)
  updated_at         DateTime          @default(now()) @updatedAt @db.Timestamptz(6)

  // Pack activation context (Story 10.2)
  activated_by       String? @db.Uuid
  activated_shift_id String? @db.Uuid

  // Pack depletion context (Story 10.2)
  depleted_by        String?                      @db.Uuid
  depleted_shift_id  String?                      @db.Uuid
  depletion_reason   LotteryPackDepletionReason?

  // Serial override approval (dual-auth when cashier needs manager to approve serial change)
  serial_override_approved_by String?   @db.Uuid
  serial_override_approved_at DateTime? @db.Timestamptz(6)
  serial_override_reason      String?   @db.VarChar(500)

  // Mark sold approval (dual-auth when cashier needs manager to approve marking pack as pre-sold during activation)
  mark_sold_approved_by String?   @db.Uuid
  mark_sold_approved_at DateTime? @db.Timestamptz(6)
  mark_sold_reason      String?   @db.VarChar(500)

  game            LotteryGame             @relation(fields: [game_id], references: [game_id], onDelete: Cascade)
  store           Store                   @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  bin             LotteryBin?             @relation(fields: [current_bin_id], references: [bin_id], onDelete: SetNull)
  shift_openings  LotteryShiftOpening[]
  shift_closings  LotteryShiftClosing[]
  variances       LotteryVariance[]
  ticket_serials  LotteryTicketSerial[]
  bin_history     LotteryPackBinHistory[]
  day_packs       LotteryDayPack[]
  activatedByUser              User?  @relation("PackActivatedBy", fields: [activated_by], references: [user_id])
  activatedShift               Shift? @relation("PackActivatedInShift", fields: [activated_shift_id], references: [shift_id])
  depletedByUser               User?  @relation("PackDepletedBy", fields: [depleted_by], references: [user_id])
  depletedShift                Shift? @relation("PackDepletedInShift", fields: [depleted_shift_id], references: [shift_id])
  serialOverrideApprovedByUser User?  @relation("PackSerialOverrideApprovedBy", fields: [serial_override_approved_by], references: [user_id])
  markSoldApprovedByUser       User?  @relation("PackMarkSoldApprovedBy", fields: [mark_sold_approved_by], references: [user_id])

  @@unique([store_id, pack_number])
  @@index([game_id])
  @@index([store_id])
  @@index([status])
  @@index([pack_number])
  @@index([serial_start, serial_end])
  @@index([current_bin_id, status])
  @@index([activated_by])
  @@index([activated_shift_id])
  @@index([depleted_by])
  @@index([depleted_shift_id])
  @@index([serial_override_approved_by])
  @@index([mark_sold_approved_by])
  @@map("lottery_packs")
}

/// Lottery Bin - Represents a storage bin for lottery packs
/// Story 6.1: Lottery Game and Pack Data Models
/// Tenant isolation enforced via store_id foreign key (RLS policies will be implemented in future stories)
model LotteryBin {
  bin_id        String   @id @default(uuid()) @db.Uuid
  store_id      String   @db.Uuid
  name          String   @db.VarChar(255)
  location      String?  @db.VarChar(255)
  display_order Int      @default(0)
  is_active     Boolean  @default(true)
  created_at    DateTime @default(now()) @db.Timestamptz(6)
  updated_at    DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  store        Store                   @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  packs        LotteryPack[]
  pack_history LotteryPackBinHistory[]
  day_packs    LotteryDayPack[]

  @@index([store_id])
  @@index([store_id, is_active])
  @@index([store_id, display_order])
  @@index([store_id, name])
  @@map("lottery_bins")
}

/// Lottery Shift Opening - Tracks lottery pack openings for shifts
/// Story 6.6: Shift Lottery Opening
/// Tenant isolation enforced via store_id through Shift and LotteryPack relationships
model LotteryShiftOpening {
  opening_id     String   @id @default(uuid()) @db.Uuid
  shift_id       String   @db.Uuid
  pack_id        String   @db.Uuid
  opening_serial String   @db.VarChar(100)
  created_at     DateTime @default(now()) @db.Timestamptz(6)

  shift Shift       @relation(fields: [shift_id], references: [shift_id], onDelete: Cascade)
  pack  LotteryPack @relation(fields: [pack_id], references: [pack_id], onDelete: Cascade)

  @@unique([shift_id, pack_id])
  @@index([shift_id])
  @@index([pack_id])
  @@map("lottery_shift_openings")
}

model LotteryShiftClosing {
  closing_id                 String    @id @default(uuid()) @db.Uuid
  shift_id                   String    @db.Uuid
  pack_id                    String    @db.Uuid
  cashier_id                 String?   @db.Uuid // Direct cashier reference for efficient querying (nullable for migration)
  closing_serial             String    @db.VarChar(100)
  entry_method               String?   @db.VarChar(10) // 'SCAN' or 'MANUAL'
  manual_entry_authorized_by String?   @db.Uuid
  manual_entry_authorized_at DateTime? @db.Timestamptz(6)
  created_at                 DateTime  @default(now()) @db.Timestamptz(6)

  shift                 Shift       @relation(fields: [shift_id], references: [shift_id], onDelete: Cascade)
  pack                  LotteryPack @relation(fields: [pack_id], references: [pack_id], onDelete: Cascade)
  cashier               Cashier?    @relation("LotteryShiftClosingCashier", fields: [cashier_id], references: [cashier_id], onDelete: SetNull)
  manualEntryAuthorizer User?       @relation("ManualEntryAuthorizer", fields: [manual_entry_authorized_by], references: [user_id], onDelete: SetNull)

  @@unique([shift_id, pack_id])
  @@index([shift_id])
  @@index([pack_id])
  @@index([cashier_id])
  @@index([manual_entry_authorized_by])
  @@map("lottery_shift_closings")
}

model LotteryVariance {
  variance_id String    @id @default(uuid()) @db.Uuid
  shift_id    String    @db.Uuid
  pack_id     String    @db.Uuid
  expected    Int
  actual      Int
  difference  Int
  reason      String?   @db.Text
  approved_by String?   @db.Uuid
  approved_at DateTime? @db.Timestamptz(6)
  created_at  DateTime  @default(now()) @db.Timestamptz(6)

  shift    Shift       @relation(fields: [shift_id], references: [shift_id], onDelete: Cascade)
  pack     LotteryPack @relation(fields: [pack_id], references: [pack_id], onDelete: Cascade)
  approver User?       @relation("VarianceApprover", fields: [approved_by], references: [user_id], onDelete: SetNull)

  @@index([shift_id])
  @@index([pack_id])
  @@map("lottery_variances")
}

/// Lottery Ticket Serial - Tracks individual ticket serial numbers within packs
/// Story 6.13: Lottery Database Enhancements & Bin Management
/// Tenant isolation enforced via store_id through LotteryPack relationship
model LotteryTicketSerial {
  serial_id      String    @id @default(uuid()) @db.Uuid
  pack_id        String    @db.Uuid
  serial_number  String    @unique @db.VarChar(100)
  sold_at        DateTime? @db.Timestamptz(6)
  shift_id       String?   @db.Uuid
  cashier_id     String?   @db.Uuid
  transaction_id String?   @db.Uuid
  created_at     DateTime  @default(now()) @db.Timestamptz(6)
  updated_at     DateTime  @default(now()) @updatedAt @db.Timestamptz(6)

  pack    LotteryPack @relation(fields: [pack_id], references: [pack_id], onDelete: Cascade)
  shift   Shift?      @relation(fields: [shift_id], references: [shift_id], onDelete: SetNull)
  cashier User?       @relation("TicketCashier", fields: [cashier_id], references: [user_id], onDelete: SetNull)

  @@index([pack_id])
  @@index([pack_id, sold_at])
  @@index([shift_id])
  @@index([sold_at])
  @@index([cashier_id, sold_at])
  @@map("lottery_ticket_serials")
}

/// Lottery Pack Bin History - Tracks pack movements between bins
/// Story 6.13: Lottery Database Enhancements & Bin Management
/// Tenant isolation enforced via store_id through LotteryPack relationship
model LotteryPackBinHistory {
  history_id String   @id @default(uuid()) @db.Uuid
  pack_id    String   @db.Uuid
  bin_id     String   @db.Uuid
  moved_at   DateTime @default(now()) @db.Timestamptz(6)
  moved_by   String   @db.Uuid
  reason     String?  @db.VarChar(500)
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  pack  LotteryPack @relation(fields: [pack_id], references: [pack_id], onDelete: Cascade)
  bin   LotteryBin  @relation(fields: [bin_id], references: [bin_id], onDelete: Cascade)
  mover User        @relation("PackMover", fields: [moved_by], references: [user_id], onDelete: Cascade)

  @@index([pack_id])
  @@index([bin_id])
  @@index([moved_at])
  @@index([pack_id, moved_at])
  @@map("lottery_pack_bin_history")
}

/// Lottery Bin Configuration - Stores bin configuration templates per store
/// Story 6.13: Lottery Database Enhancements & Bin Management
/// Tenant isolation enforced via store_id foreign key
model LotteryBinConfiguration {
  config_id    String   @id @default(uuid()) @db.Uuid
  store_id     String   @unique @db.Uuid
  bin_template Json     @db.JsonB
  created_at   DateTime @default(now()) @db.Timestamptz(6)
  updated_at   DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  store Store @relation(fields: [store_id], references: [store_id], onDelete: Cascade)

  @@map("lottery_bin_configurations")
}

/// Lottery Business Day - Tracks lottery operations for a calendar day per store
/// Independent of shifts - day boundaries defined by first/last shift of the day
/// Story: MyStore Lottery Day-Based Tracking
/// Tenant isolation enforced via store_id foreign key
/// Lottery Business Day - Tracks lottery activity for a business day
/// Uses two-phase commit pattern for atomic day close with lottery
///
/// Status Flow:
///   OPEN -> PENDING_CLOSE -> CLOSED
///                        \-> OPEN (if day close cancelled/times out)
///
/// Enterprise Features:
/// - PENDING_CLOSE status holds lottery closings until day close completes
/// - pending_close_data stores closings JSON for atomic commit
/// - pending_close_expires_at enables automatic cleanup of stale pending states
/// - Proper locking via SELECT FOR UPDATE during status transitions
///
/// Story: MyStore Day Close Atomic Transaction
model LotteryBusinessDay {
  day_id        String    @id @default(uuid()) @db.Uuid
  store_id      String    @db.Uuid
  business_date DateTime  @db.Date
  /// Status: OPEN (active), PENDING_CLOSE (lottery scanned, awaiting day close), CLOSED (finalized)
  status        String    @default("OPEN") @db.VarChar(20)
  opened_at     DateTime  @default(now()) @db.Timestamptz(6)
  opened_by     String?   @db.Uuid
  closed_at     DateTime? @db.Timestamptz(6)
  closed_by     String?   @db.Uuid
  notes         String?   @db.Text

  /// Two-phase commit: Pending close data (JSONB)
  /// Stores lottery closings data while in PENDING_CLOSE status
  /// Structure: { closings: [{pack_id, closing_serial}], entry_method, authorized_by_user_id? }
  pending_close_data       Json?     @db.JsonB
  /// Two-phase commit: User who initiated pending close
  pending_close_by         String?   @db.Uuid
  /// Two-phase commit: When pending close was initiated
  pending_close_at         DateTime? @db.Timestamptz(6)
  /// Two-phase commit: Expiration time for pending state (auto-cleanup)
  /// Default: 1 hour from pending_close_at
  pending_close_expires_at DateTime? @db.Timestamptz(6)

  created_at    DateTime  @default(now()) @db.Timestamptz(6)
  updated_at    DateTime  @default(now()) @updatedAt @db.Timestamptz(6)

  store              Store            @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  openedByUser       User?            @relation("LotteryDayOpenedBy", fields: [opened_by], references: [user_id], onDelete: SetNull)
  closedByUser       User?            @relation("LotteryDayClosedBy", fields: [closed_by], references: [user_id], onDelete: SetNull)
  pendingCloseByUser User?            @relation("LotteryDayPendingCloseBy", fields: [pending_close_by], references: [user_id], onDelete: SetNull)
  day_packs          LotteryDayPack[]
  // Scanned Documents (OCR Feature)
  scanned_documents  ScannedDocument[]

  @@unique([store_id, business_date])
  @@index([store_id])
  @@index([store_id, status])
  @@index([business_date])
  @@index([opened_by])
  @@index([closed_by])
  @@index([pending_close_by])
  /// Index for cleanup job: find expired pending states
  @@index([status, pending_close_expires_at])
  @@map("lottery_business_days")
}

/// Lottery Day Pack - Tracks each pack's activity for a specific business day
/// Records starting and ending serials for day-based reconciliation
/// Story: MyStore Lottery Day-Based Tracking
/// Tenant isolation enforced via store_id through LotteryBusinessDay relationship
model LotteryDayPack {
  day_pack_id     String   @id @default(uuid()) @db.Uuid
  day_id          String   @db.Uuid
  pack_id         String   @db.Uuid
  bin_id          String?  @db.Uuid
  starting_serial String   @db.VarChar(100) // From previous day close OR "000" if newly activated
  ending_serial   String?  @db.VarChar(100) // Entered at day close
  tickets_sold    Int? // Calculated: ending - starting
  sales_amount    Decimal? @db.Decimal(10, 2) // tickets_sold  ticket_price
  entry_method    String?  @db.VarChar(10) // 'SCAN' or 'MANUAL'
  created_at      DateTime @default(now()) @db.Timestamptz(6)
  updated_at      DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  day  LotteryBusinessDay @relation(fields: [day_id], references: [day_id], onDelete: Cascade)
  pack LotteryPack        @relation(fields: [pack_id], references: [pack_id], onDelete: Cascade)
  bin  LotteryBin?        @relation(fields: [bin_id], references: [bin_id], onDelete: SetNull)

  @@unique([day_id, pack_id])
  @@index([day_id])
  @@index([pack_id])
  @@index([bin_id])
  @@map("lottery_day_packs")
}

// ============================================================================
// POS INTEGRATION (Phase 1.6) - POS System Connection & Sync
// ============================================================================
// Enables automatic onboarding from POS systems (Gilbarco, Verifone, Clover, etc.)
// The POS is the source of truth - departments, tenders, cashiers sync automatically
// ============================================================================

/// POSIntegration - Store's POS System Configuration
/// Each store can have ONE active POS integration
/// Stores connection details, auth credentials, and sync settings
model POSIntegration {
  pos_integration_id String @id @default(uuid()) @db.Uuid

  // === STORE REFERENCE ===
  store_id String @unique @db.Uuid // One POS per store

  // === POS IDENTIFICATION ===
  pos_type    POSSystemType // Gilbarco, Verifone, Clover, etc.
  pos_version String?       @db.VarChar(50) // Software version
  pos_serial  String?       @db.VarChar(100) // Hardware serial number
  pos_name    String?       @db.VarChar(100) // Friendly name for this POS

  // === CONNECTION DETAILS ===
  host    String  @db.VarChar(255) // IP address or hostname
  port    Int     @default(8080) // Default port
  use_ssl Boolean @default(true) // Use HTTPS/TLS
  timeout Int     @default(30000) // Connection timeout in ms

  // === AUTHENTICATION ===
  auth_type        POSAuthType @default(API_KEY)
  // Credentials stored as encrypted JSON
  // Structure varies by auth_type:
  // API_KEY: { api_key: "xxx" }
  // BASIC_AUTH: { username: "xxx", password_encrypted: "xxx" }
  // OAUTH2: { client_id: "xxx", client_secret_encrypted: "xxx", token_url: "xxx" }
  // CERTIFICATE: { cert_path: "xxx", key_path: "xxx", passphrase_encrypted: "xxx" }
  auth_credentials Json?       @db.JsonB

  // === SYNC CONFIGURATION ===
  sync_enabled       Boolean        @default(true) // Enable/disable auto-sync
  sync_interval_mins Int            @default(60) // How often to sync (default: 1 hour)
  last_sync_at       DateTime?      @db.Timestamptz(6) // When last synced
  last_sync_status   POSSyncStatus? // Status of last sync
  last_sync_error    String?        @db.Text // Error message from last sync
  next_sync_at       DateTime?      @db.Timestamptz(6) // When next sync is scheduled

  // === ENTITY SYNC FLAGS ===
  sync_departments  Boolean @default(true) // Sync departments from POS
  sync_tender_types Boolean @default(true) // Sync tender types from POS
  sync_cashiers     Boolean @default(true) // Sync cashiers from POS
  sync_tax_rates    Boolean @default(true) // Sync tax rates from POS
  sync_products     Boolean @default(false) // Sync products (future)

  // === LIFECYCLE ===
  is_active  Boolean  @default(true) // Soft delete flag
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  created_by String?  @db.Uuid // User who created this integration

  // === NAXML-SPECIFIC FIELDS (Phase 1) ===
  naxml_version             String?  @db.VarChar(10) @default("3.4")
  xml_gateway_path          String?  @db.VarChar(500)
  generate_acknowledgments  Boolean  @default(true)
  connection_mode           String   @default("API") @db.VarChar(20) // 'API', 'FILE_EXCHANGE', 'HYBRID'

  // === RELATIONS ===
  store           Store        @relation("StorePOSIntegration", fields: [store_id], references: [store_id], onDelete: Cascade)
  created_by_user User?        @relation("POSIntegrationCreatedBy", fields: [created_by], references: [user_id], onDelete: SetNull)
  sync_logs       POSSyncLog[]
  // POS Audit relations (Phase 0)
  audit_records   POSDataExchangeAudit[]
  // NAXML Infrastructure relations (Phase 1)
  naxml_file_logs       NAXMLFileLog[]
  file_watcher_configs  POSFileWatcherConfig[]
  // NAXML Scheduled Export relations (Phase 2)
  scheduled_exports     NAXMLScheduledExport[]

  // === INDEXES ===
  @@index([store_id])
  @@index([pos_type])
  @@index([is_active, next_sync_at])
  @@index([last_sync_status])
  @@index([connection_mode])
  @@map("pos_integrations")
}

/// POSSyncLog - History of POS Synchronization Operations
/// Tracks every sync attempt with detailed results for debugging and auditing
model POSSyncLog {
  sync_log_id        String @id @default(uuid()) @db.Uuid
  pos_integration_id String @db.Uuid

  // === SYNC TIMING ===
  started_at   DateTime  @db.Timestamptz(6)
  completed_at DateTime? @db.Timestamptz(6)
  duration_ms  Int? // Total sync duration

  // === STATUS ===
  status        POSSyncStatus
  error_message String?       @db.Text // Error message if failed
  error_code    String?       @db.VarChar(50) // Error code for categorization

  // === SYNC RESULTS (entity counts) ===
  departments_synced  Int @default(0)
  tender_types_synced Int @default(0)
  cashiers_synced     Int @default(0)
  tax_rates_synced    Int @default(0)

  // === CHANGE COUNTS ===
  entities_created     Int @default(0) // New entities created
  entities_updated     Int @default(0) // Existing entities updated
  entities_deactivated Int @default(0) // Entities marked inactive

  // === ERROR DETAILS ===
  error_details Json? @db.JsonB // Additional error context

  // === TRIGGER INFO ===
  trigger_type POSSyncTrigger @default(SCHEDULED)
  triggered_by String?        @db.Uuid // User who triggered (if manual)

  // === RELATIONS ===
  pos_integration   POSIntegration @relation(fields: [pos_integration_id], references: [pos_integration_id], onDelete: Cascade)
  triggered_by_user User?          @relation("POSSyncLogTriggeredBy", fields: [triggered_by], references: [user_id], onDelete: SetNull)

  // === INDEXES ===
  @@index([pos_integration_id, started_at])
  @@index([status])
  @@index([started_at])
  @@index([trigger_type])
  @@map("pos_sync_logs")
}

// ============================================================================
// POS DATA EXCHANGE AUDIT - Regulatory Compliance (Phase 0: MANDATORY)
// ============================================================================
// CRITICAL: All POS data exchanges MUST create a record in this table.
// This table provides complete audit trail for regulatory compliance.
// DO NOT SKIP: Any adapter that processes data without updating this table
// is in violation of data privacy requirements.
// ============================================================================

model POSDataExchangeAudit {
  audit_id String @id @default(uuid()) @db.Uuid

  // === FOREIGN KEYS FOR CONTEXT ===
  store_id           String @db.Uuid
  pos_integration_id String @db.Uuid
  company_id         String @db.Uuid

  // === EXCHANGE IDENTIFICATION ===
  exchange_id   String          @db.VarChar(100) // Unique ID for this exchange (can group related records)
  exchange_type POSExchangeType

  // === DATA FLOW DIRECTION AND CLASSIFICATION ===
  direction          String          @db.VarChar(10) // 'INBOUND' or 'OUTBOUND'
  data_category      POSDataCategory
  contains_pii       Boolean         @default(false) // Personal Identifiable Information flag
  contains_financial Boolean         @default(false) // Financial data flag

  // === SOURCE AND DESTINATION TRACKING ===
  source_system          String  @db.VarChar(100)
  source_identifier      String? @db.VarChar(255) // File path, API endpoint, webhook URL
  destination_system     String  @db.VarChar(100)
  destination_identifier String? @db.VarChar(255)

  // === DATA METRICS ===
  record_count    Int? // Number of records in the exchange
  data_size_bytes BigInt? // Size of the data payload
  file_hash       String? @db.VarChar(128) // SHA-256 or SHA-512 hash for integrity

  // === PROCESSING STATUS ===
  status        POSAuditStatus @default(PENDING)
  error_code    String?        @db.VarChar(50)
  error_message String?        @db.Text

  // === DATA RETENTION AND COMPLIANCE ===
  retention_policy     POSRetentionPolicy @default(STANDARD)
  retention_expires_at DateTime?          @db.Timestamptz(6) // When this record can be purged
  jurisdiction         String?            @default("US") @db.VarChar(50) // Regulatory jurisdiction

  // === CONSENT AND ACCESS TRACKING ===
  data_subject_consent  Boolean? // For PII: was consent obtained?
  accessed_by_user_id   String?  @db.Uuid // Who initiated this exchange
  access_reason         String?  @db.VarChar(255) // Why was this data accessed/exchanged

  // === TIMESTAMPS ===
  initiated_at DateTime  @default(now()) @db.Timestamptz(6)
  completed_at DateTime? @db.Timestamptz(6)
  created_at   DateTime  @default(now()) @db.Timestamptz(6)

  // === METADATA FOR EXTENSIBILITY ===
  metadata Json? @default("{}") @db.JsonB

  // === RELATIONS ===
  store           Store          @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  pos_integration POSIntegration @relation(fields: [pos_integration_id], references: [pos_integration_id], onDelete: Cascade)
  company         Company        @relation(fields: [company_id], references: [company_id], onDelete: Cascade)
  accessed_by     User?          @relation("POSAuditAccessedBy", fields: [accessed_by_user_id], references: [user_id], onDelete: SetNull)

  // === INDEXES ===
  @@index([store_id, initiated_at])
  @@index([company_id, initiated_at])
  @@index([exchange_id])
  @@index([pos_integration_id, initiated_at])
  @@index([status])
  @@index([data_category, initiated_at])
  @@index([contains_pii])
  @@index([retention_expires_at])
  @@index([jurisdiction])
  @@map("pos_data_exchange_audit")
}

// ============================================================================
// NAXML INFRASTRUCTURE (Phase 1: NAXML Core Infrastructure)
// ============================================================================
// Tables for NAXML file processing and file watcher configuration
// ============================================================================

/// NAXML File Status enum
enum NAXMLFileStatus {
  PENDING
  PROCESSING
  SUCCESS
  PARTIAL
  FAILED
  SKIPPED
}

/// NAXML File Direction enum
enum NAXMLFileDirection {
  IMPORT
  EXPORT
}

/// NAXML Document Type enum
enum NAXMLDocumentType {
  PriceBookMaintenance
  TransactionDocument
  InventoryMovement
  EmployeeMaintenance
  TenderMaintenance
  DepartmentMaintenance
  TaxRateMaintenance
  Acknowledgment
}

/// NAXML File Log - Tracks all NAXML files processed by the system
/// Used for auditing, duplicate detection, and processing history.
model NAXMLFileLog {
  file_log_id String @id @default(uuid()) @db.Uuid

  // === FOREIGN KEYS ===
  store_id           String @db.Uuid
  pos_integration_id String @db.Uuid

  // === FILE INFORMATION ===
  file_name   String             @db.VarChar(255)
  file_type   NAXMLDocumentType
  direction   NAXMLFileDirection
  status      NAXMLFileStatus    @default(PENDING)

  // === PROCESSING METRICS ===
  record_count        Int?
  file_size_bytes     BigInt
  processing_time_ms  Int?

  // === ERROR TRACKING ===
  error_code    String? @db.VarChar(50)
  error_message String? @db.Text

  // === DUPLICATE DETECTION ===
  file_hash String @db.VarChar(64) // SHA-256 hash

  // === FILE PATHS ===
  source_path    String? @db.VarChar(500)
  processed_path String? @db.VarChar(500)

  // === TIMESTAMPS ===
  processed_at DateTime? @db.Timestamptz(6)
  created_at   DateTime  @default(now()) @db.Timestamptz(6)

  // === METADATA FOR EXTENSIBILITY ===
  metadata Json? @default("{}") @db.JsonB

  // === RELATIONS ===
  store           Store          @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  pos_integration POSIntegration @relation(fields: [pos_integration_id], references: [pos_integration_id], onDelete: Cascade)

  // === INDEXES ===
  @@unique([store_id, file_hash])
  @@index([store_id, created_at])
  @@index([pos_integration_id, created_at])
  @@index([status])
  @@index([file_hash])
  @@index([file_type, created_at])
  @@map("naxml_file_log")
}

/// POS File Watcher Config - Configuration for file watchers
/// Each store can have one active file watcher configuration.
model POSFileWatcherConfig {
  config_id String @id @default(uuid()) @db.Uuid

  // === FOREIGN KEYS ===
  store_id           String @unique @db.Uuid // One watcher per store
  pos_integration_id String @db.Uuid

  // === PATH CONFIGURATION ===
  watch_path     String  @db.VarChar(500)
  processed_path String? @db.VarChar(500)
  error_path     String? @db.VarChar(500)

  // === FILE PATTERNS ===
  file_patterns Json @default("[\"*.xml\", \"TLog*.xml\", \"Dept*.xml\"]") @db.JsonB

  // === POLLING CONFIGURATION ===
  poll_interval_seconds Int @default(60)

  // === STATUS ===
  is_active     Boolean   @default(true)
  last_poll_at  DateTime? @db.Timestamptz(6)
  last_error    String?   @db.Text
  last_error_at DateTime? @db.Timestamptz(6)

  // === STATISTICS ===
  files_processed          Int       @default(0)
  files_errored            Int       @default(0)
  last_file_processed_at   DateTime? @db.Timestamptz(6)

  // === TIMESTAMPS ===
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // === RELATIONS ===
  store           Store          @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  pos_integration POSIntegration @relation(fields: [pos_integration_id], references: [pos_integration_id], onDelete: Cascade)

  // === INDEXES ===
  @@index([is_active])
  @@index([pos_integration_id])
  @@map("pos_file_watcher_config")
}

// ============================================================================
// NAXML SCHEDULED EXPORT (Phase 2: Gilbarco NAXML Adapter)
// ============================================================================
// Configuration for automated NAXML exports on a schedule.
// Supports cron-style scheduling for departments, tender types, tax rates, etc.
// ============================================================================

/// Export Type enum for scheduled exports
enum NAXMLExportType {
  DEPARTMENTS
  TENDER_TYPES
  TAX_RATES
  PRICE_BOOK
  FULL_SYNC
}

/// Scheduled Export Status
enum ScheduledExportStatus {
  ACTIVE
  PAUSED
  DISABLED
}

/// NAXML Scheduled Export Configuration
/// Each store can have multiple scheduled exports for different export types.
model NAXMLScheduledExport {
  schedule_id String @id @default(uuid()) @db.Uuid

  // === FOREIGN KEYS ===
  store_id           String @db.Uuid
  pos_integration_id String @db.Uuid

  // === EXPORT CONFIGURATION ===
  export_type      NAXMLExportType // What to export
  export_name      String          @db.VarChar(255) // Human-friendly name
  maintenance_type String          @default("Full") @db.VarChar(20) // "Full" or "Incremental"

  // === SCHEDULE CONFIGURATION (Cron-style) ===
  // Standard cron format: minute hour day_of_month month day_of_week
  // Examples: "0 2 * * *" (daily at 2 AM), "0 */6 * * *" (every 6 hours)
  cron_expression String @db.VarChar(50)
  timezone        String @default("America/New_York") @db.VarChar(50)

  // === OUTPUT CONFIGURATION ===
  output_path     String? @db.VarChar(500) // Path to write file (if null, uses POS integration default)
  file_name_pattern String @default("{type}_{date}_{time}.xml") @db.VarChar(255) // Supports: {type}, {date}, {time}, {store_id}

  // === STATUS ===
  status            ScheduledExportStatus @default(ACTIVE)
  last_run_at       DateTime?             @db.Timestamptz(6)
  last_run_status   NAXMLFileStatus?
  last_run_error    String?               @db.Text
  next_run_at       DateTime?             @db.Timestamptz(6)

  // === STATISTICS ===
  total_runs          Int @default(0)
  successful_runs     Int @default(0)
  failed_runs         Int @default(0)
  last_record_count   Int?
  last_file_size      BigInt?

  // === NOTIFICATIONS ===
  notify_on_failure Boolean @default(true)
  notify_on_success Boolean @default(false)
  notify_emails     Json?   @default("[]") @db.JsonB // Array of email addresses

  // === METADATA ===
  created_by String?  @db.Uuid
  metadata   Json?    @default("{}") @db.JsonB

  // === TIMESTAMPS ===
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // === RELATIONS ===
  store             Store          @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  pos_integration   POSIntegration @relation(fields: [pos_integration_id], references: [pos_integration_id], onDelete: Cascade)
  created_by_user   User?          @relation("ScheduledExportCreatedBy", fields: [created_by], references: [user_id], onDelete: SetNull)
  export_logs       NAXMLScheduledExportLog[]

  // === INDEXES ===
  @@index([store_id])
  @@index([pos_integration_id])
  @@index([status, next_run_at])
  @@index([export_type])
  @@map("naxml_scheduled_export")
}

/// NAXML Scheduled Export Log - History of scheduled export runs
model NAXMLScheduledExportLog {
  log_id String @id @default(uuid()) @db.Uuid

  // === FOREIGN KEYS ===
  schedule_id String @db.Uuid
  store_id    String @db.Uuid

  // === TIMING ===
  started_at   DateTime  @db.Timestamptz(6)
  completed_at DateTime? @db.Timestamptz(6)
  duration_ms  Int?

  // === STATUS ===
  status        NAXMLFileStatus
  error_code    String?         @db.VarChar(50)
  error_message String?         @db.Text

  // === EXPORT DETAILS ===
  export_type      NAXMLExportType
  maintenance_type String          @db.VarChar(20)
  record_count     Int?
  file_size_bytes  BigInt?
  file_hash        String?         @db.VarChar(64)
  output_path      String?         @db.VarChar(500)

  // === TRIGGER INFO ===
  trigger_type String @default("SCHEDULED") @db.VarChar(20) // SCHEDULED, MANUAL, API

  // === METADATA ===
  metadata Json? @default("{}") @db.JsonB

  // === TIMESTAMPS ===
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // === RELATIONS ===
  schedule NAXMLScheduledExport @relation(fields: [schedule_id], references: [schedule_id], onDelete: Cascade)
  store    Store                @relation(fields: [store_id], references: [store_id], onDelete: Cascade)

  // === INDEXES ===
  @@index([schedule_id, started_at])
  @@index([store_id, started_at])
  @@index([status])
  @@map("naxml_scheduled_export_log")
}

// ============================================================================
// SHIFT SUMMARY - Pre-Aggregated Snapshot (Phase 2.1)
// ============================================================================
// Created when a shift is closed. Contains all calculated totals frozen
// at close time. This is the primary source for shift reports.
// ============================================================================

model ShiftSummary {
  shift_summary_id String @id @default(uuid()) @db.Uuid

  // === FOREIGN KEYS ===
  shift_id String @unique @db.Uuid
  store_id String @db.Uuid

  // === BUSINESS DATE ===
  // The logical business day this shift belongs to (may differ from calendar date)
  business_date DateTime @db.Date

  // === TIMING ===
  shift_opened_at     DateTime @db.Timestamptz(6)
  shift_closed_at     DateTime @db.Timestamptz(6)
  shift_duration_mins Int // Duration in minutes

  // === PERSONNEL ===
  opened_by_user_id String  @db.Uuid
  closed_by_user_id String  @db.Uuid
  cashier_user_id   String? @db.Uuid

  // === SALES TOTALS (Pre-calculated) ===
  gross_sales     Decimal @db.Decimal(14, 2) // Total before returns/discounts
  returns_total   Decimal @db.Decimal(12, 2) // Total returns/refunds
  discounts_total Decimal @db.Decimal(12, 2) // Total discounts applied
  net_sales       Decimal @db.Decimal(14, 2) // gross - returns - discounts

  // === TAX ===
  tax_collected    Decimal @db.Decimal(12, 2) // Total tax collected
  tax_exempt_sales Decimal @db.Decimal(12, 2) // Sales without tax
  taxable_sales    Decimal @db.Decimal(14, 2) // Sales subject to tax

  // === TRANSACTION COUNTS ===
  transaction_count Int @default(0) // Total transactions
  void_count        Int @default(0) // Voided transactions
  refund_count      Int @default(0) // Refund transactions
  no_sale_count     Int @default(0) // No-sale drawer opens

  // === ITEM COUNTS ===
  items_sold_count     Int @default(0) // Total line items sold
  items_returned_count Int @default(0) // Total line items returned

  // === AVERAGES ===
  avg_transaction   Decimal @db.Decimal(10, 2) // Average transaction value
  avg_items_per_txn Decimal @db.Decimal(6, 2) // Average items per transaction

  // === CASH DRAWER RECONCILIATION ===
  opening_cash         Decimal   @db.Decimal(10, 2)
  closing_cash         Decimal   @db.Decimal(10, 2) // Declared closing amount
  expected_cash        Decimal   @db.Decimal(10, 2) // Calculated expected
  cash_variance        Decimal   @db.Decimal(10, 2) // closing - expected
  variance_percentage  Decimal   @db.Decimal(5, 2) // Variance as percentage
  variance_approved    Boolean   @default(false)
  variance_approved_by String?   @db.Uuid
  variance_approved_at DateTime? @db.Timestamptz(6)
  variance_reason      String?   @db.VarChar(500)

  // === LOTTERY TOTALS (if applicable) ===
  lottery_sales        Decimal? @db.Decimal(12, 2)
  lottery_cashes       Decimal? @db.Decimal(12, 2) // Lottery payouts/cashes
  lottery_net          Decimal? @db.Decimal(12, 2) // sales - cashes
  lottery_packs_sold   Int? // Number of packs closed
  lottery_tickets_sold Int? // Total tickets sold

  // === FUEL (if applicable) ===
  fuel_gallons Decimal? @db.Decimal(12, 3)
  fuel_sales   Decimal? @db.Decimal(12, 2)

  // === FUTURE-PROOFING ===
  // For truly unknown/custom data that doesn't need SQL querying
  extra_data Json? @db.JsonB

  // === METADATA ===
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // === RELATIONS ===
  shift             Shift @relation(fields: [shift_id], references: [shift_id], onDelete: Cascade)
  store             Store @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  opened_by         User  @relation("ShiftSummaryOpenedBy", fields: [opened_by_user_id], references: [user_id])
  closed_by         User  @relation("ShiftSummaryClosedBy", fields: [closed_by_user_id], references: [user_id])
  cashier           User? @relation("ShiftSummaryCashier", fields: [cashier_user_id], references: [user_id])
  variance_approver User? @relation("ShiftSummaryVarianceApprover", fields: [variance_approved_by], references: [user_id])

  // Child summary tables
  tender_summaries     ShiftTenderSummary[]
  department_summaries ShiftDepartmentSummary[]
  tax_summaries        ShiftTaxSummary[]
  hourly_summaries     ShiftHourlySummary[]
  // Z Report relation (Phase 4) - one-to-one
  z_report             ZReport?

  // === INDEXES ===
  @@index([store_id, business_date])
  @@index([business_date])
  @@index([store_id, shift_closed_at])
  @@index([opened_by_user_id])
  @@index([closed_by_user_id])
  @@map("shift_summaries")
}

// ============================================================================
// SHIFT TENDER SUMMARY - Child Rows per Payment Method (Phase 2.2)
// ============================================================================
// One row per tender type used during a shift. Enables flexible reporting
// by payment method without schema changes when new tenders are added.
// ============================================================================

model ShiftTenderSummary {
  id               String @id @default(uuid()) @db.Uuid
  shift_summary_id String @db.Uuid

  // === TENDER IDENTIFICATION ===
  tender_type_id      String @db.Uuid
  tender_code         String @db.VarChar(50) // Denormalized snapshot
  tender_display_name String @db.VarChar(100) // Denormalized snapshot

  // === TOTALS ===
  total_amount      Decimal @db.Decimal(12, 2)
  transaction_count Int

  // === REFUND BREAKDOWN ===
  refund_amount Decimal @default(0) @db.Decimal(10, 2)
  refund_count  Int     @default(0)

  // === NET ===
  net_amount Decimal @db.Decimal(12, 2) // total - refunds

  // === METADATA ===
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // === RELATIONS ===
  shift_summary ShiftSummary @relation(fields: [shift_summary_id], references: [shift_summary_id], onDelete: Cascade)
  tender_type   TenderType   @relation(fields: [tender_type_id], references: [tender_type_id])

  // === INDEXES ===
  @@unique([shift_summary_id, tender_type_id])
  @@index([tender_code])
  @@index([shift_summary_id])
  @@map("shift_tender_summaries")
}

// ============================================================================
// SHIFT DEPARTMENT SUMMARY - Child Rows per Department (Phase 2.3)
// ============================================================================
// One row per department with sales during a shift.
// ============================================================================

model ShiftDepartmentSummary {
  id               String @id @default(uuid()) @db.Uuid
  shift_summary_id String @db.Uuid

  // === DEPARTMENT IDENTIFICATION ===
  department_id   String @db.Uuid
  department_code String @db.VarChar(50) // Denormalized snapshot
  department_name String @db.VarChar(100) // Denormalized snapshot

  // === SALES TOTALS ===
  gross_sales     Decimal @db.Decimal(12, 2)
  returns_total   Decimal @default(0) @db.Decimal(10, 2)
  discounts_total Decimal @default(0) @db.Decimal(10, 2)
  net_sales       Decimal @db.Decimal(12, 2)

  // === TAX ===
  tax_collected Decimal @db.Decimal(10, 2)

  // === COUNTS ===
  transaction_count    Int @default(0)
  items_sold_count     Int @default(0)
  items_returned_count Int @default(0)

  // === METADATA ===
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // === RELATIONS ===
  shift_summary ShiftSummary @relation(fields: [shift_summary_id], references: [shift_summary_id], onDelete: Cascade)
  department    Department   @relation(fields: [department_id], references: [department_id])

  // === INDEXES ===
  @@unique([shift_summary_id, department_id])
  @@index([department_code])
  @@index([shift_summary_id])
  @@map("shift_department_summaries")
}

// ============================================================================
// SHIFT TAX SUMMARY - Child Rows per Tax Rate (Phase 2.4)
// ============================================================================
// One row per tax rate applied during the shift.
// ============================================================================

model ShiftTaxSummary {
  id               String @id @default(uuid()) @db.Uuid
  shift_summary_id String @db.Uuid

  // === TAX IDENTIFICATION ===
  tax_rate_id       String  @db.Uuid
  tax_code          String  @db.VarChar(50)
  tax_display_name  String  @db.VarChar(100)
  tax_rate_snapshot Decimal @db.Decimal(6, 5) // Rate at time of shift (denormalized)

  // === TOTALS ===
  taxable_amount Decimal @db.Decimal(12, 2) // Base amount taxed
  tax_collected  Decimal @db.Decimal(10, 2) // Tax amount collected
  exempt_amount  Decimal @db.Decimal(12, 2) // Exempt sales for this rate

  // === COUNTS ===
  transaction_count Int @default(0)

  // === METADATA ===
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // === RELATIONS ===
  shift_summary ShiftSummary @relation(fields: [shift_summary_id], references: [shift_summary_id], onDelete: Cascade)
  tax_rate      TaxRate      @relation(fields: [tax_rate_id], references: [tax_rate_id])

  // === INDEXES ===
  @@unique([shift_summary_id, tax_rate_id])
  @@index([tax_code])
  @@index([shift_summary_id])
  @@map("shift_tax_summaries")
}

// ============================================================================
// SHIFT HOURLY SUMMARY - Hourly Breakdown within Shift (Phase 2.5)
// ============================================================================
// Hourly breakdown within a shift for time-based analysis.
// ============================================================================

model ShiftHourlySummary {
  id               String @id @default(uuid()) @db.Uuid
  shift_summary_id String @db.Uuid

  // === TIME PERIOD ===
  hour_start  DateTime @db.Timestamptz(6) // Start of the hour
  hour_number Int // 0-23

  // === TOTALS ===
  gross_sales       Decimal @db.Decimal(10, 2)
  net_sales         Decimal @db.Decimal(10, 2)
  transaction_count Int     @default(0)
  items_sold_count  Int     @default(0)

  // === AVERAGES ===
  avg_transaction Decimal @db.Decimal(8, 2)

  // === METADATA ===
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // === RELATIONS ===
  shift_summary ShiftSummary @relation(fields: [shift_summary_id], references: [shift_summary_id], onDelete: Cascade)

  // === INDEXES ===
  @@unique([shift_summary_id, hour_number])
  @@index([shift_summary_id])
  @@index([hour_start])
  @@map("shift_hourly_summaries")
}

// ============================================================================
// DAY SUMMARY STATUS ENUM (Phase 3.1)
// ============================================================================

enum DaySummaryStatus {
  OPEN // Business day in progress - shifts are still being worked
  PENDING_CLOSE // All shifts closed, awaiting manager day close
  CLOSED // Day finalized, no more changes allowed
}

// ============================================================================
// DAY SUMMARY - Daily Pre-Aggregated Snapshot (Phase 3.1)
// ============================================================================
// Aggregates all shift summaries for a single business day at a store.
// Updated incrementally when each shift closes and finalized at day close.
// This is the primary source for daily, weekly, and monthly reports.
// ============================================================================

model DaySummary {
  day_summary_id String @id @default(uuid()) @db.Uuid

  // === FOREIGN KEYS ===
  store_id      String   @db.Uuid
  business_date DateTime @db.Date

  // === SHIFT COUNTS ===
  shift_count Int @default(0) // Number of shifts closed for this day

  // === TIMING ===
  first_shift_opened DateTime? @db.Timestamptz(6) // When first shift of day opened
  last_shift_closed  DateTime? @db.Timestamptz(6) // When last shift of day closed

  // === SALES TOTALS (Aggregated from all shifts) ===
  gross_sales     Decimal @default(0) @db.Decimal(14, 2) // Total before returns/discounts
  returns_total   Decimal @default(0) @db.Decimal(12, 2) // Total returns/refunds
  discounts_total Decimal @default(0) @db.Decimal(12, 2) // Total discounts applied
  net_sales       Decimal @default(0) @db.Decimal(14, 2) // gross - returns - discounts

  // === TAX ===
  tax_collected    Decimal @default(0) @db.Decimal(12, 2) // Total tax collected
  tax_exempt_sales Decimal @default(0) @db.Decimal(12, 2) // Sales without tax
  taxable_sales    Decimal @default(0) @db.Decimal(14, 2) // Sales subject to tax

  // === TRANSACTION COUNTS ===
  transaction_count Int @default(0) // Total transactions across all shifts
  void_count        Int @default(0) // Voided transactions
  refund_count      Int @default(0) // Refund transactions
  customer_count    Int @default(0) // Unique customers (if tracked)

  // === ITEM COUNTS ===
  items_sold_count     Int @default(0) // Total line items sold
  items_returned_count Int @default(0) // Total line items returned

  // === AVERAGES ===
  avg_transaction   Decimal @default(0) @db.Decimal(10, 2) // Average transaction value
  avg_items_per_txn Decimal @default(0) @db.Decimal(6, 2) // Average items per transaction

  // === CASH RECONCILIATION (Aggregated) ===
  total_opening_cash  Decimal @default(0) @db.Decimal(12, 2) // Sum of all shifts' opening cash
  total_closing_cash  Decimal @default(0) @db.Decimal(12, 2) // Sum of all shifts' closing cash
  total_expected_cash Decimal @default(0) @db.Decimal(12, 2) // Sum of all shifts' expected cash
  total_cash_variance Decimal @default(0) @db.Decimal(10, 2) // Total variance across all shifts

  // === LOTTERY (if applicable) ===
  lottery_sales        Decimal? @db.Decimal(12, 2)
  lottery_cashes       Decimal? @db.Decimal(12, 2) // Lottery payouts/cashes
  lottery_net          Decimal? @db.Decimal(12, 2) // sales - cashes
  lottery_packs_sold   Int? // Number of packs closed
  lottery_tickets_sold Int? // Total tickets sold

  // === FUEL (if applicable) ===
  fuel_gallons Decimal? @db.Decimal(14, 3)
  fuel_sales   Decimal? @db.Decimal(14, 2)

  // === STATUS & CLOSING ===
  status    DaySummaryStatus @default(OPEN)
  closed_at DateTime?        @db.Timestamptz(6) // When day was finalized
  closed_by String?          @db.Uuid // User who finalized the day

  // === MANAGER NOTES ===
  notes String? @db.Text

  // === FUTURE-PROOFING ===
  extra_data Json? @db.JsonB

  // === METADATA ===
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // === RELATIONS ===
  store          Store @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  closed_by_user User? @relation("DaySummaryClosedBy", fields: [closed_by], references: [user_id])

  // Child summary tables
  tender_summaries     DayTenderSummary[]
  department_summaries DayDepartmentSummary[]
  tax_summaries        DayTaxSummary[]
  hourly_summaries     DayHourlySummary[]
  // Scanned Documents (OCR Feature)
  scanned_documents    ScannedDocument[]

  // === INDEXES ===
  @@unique([store_id, business_date])
  @@index([store_id, business_date])
  @@index([business_date])
  @@index([status])
  @@map("day_summaries")
}

// ============================================================================
// DAY TENDER SUMMARY - Child Rows per Payment Method (Phase 3.2)
// ============================================================================
// Aggregates tender totals across all shifts for a business day.
// One row per tender type used during the day.
// ============================================================================

model DayTenderSummary {
  id             String @id @default(uuid()) @db.Uuid
  day_summary_id String @db.Uuid

  // === TENDER IDENTIFICATION ===
  tender_type_id      String @db.Uuid
  tender_code         String @db.VarChar(50) // Denormalized snapshot
  tender_display_name String @db.VarChar(100) // Denormalized snapshot

  // === TOTALS ===
  total_amount      Decimal @db.Decimal(14, 2)
  transaction_count Int

  // === REFUND BREAKDOWN ===
  refund_amount Decimal @default(0) @db.Decimal(12, 2)
  refund_count  Int     @default(0)

  // === NET ===
  net_amount Decimal @db.Decimal(14, 2) // total - refunds

  // === METADATA ===
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // === RELATIONS ===
  day_summary DaySummary @relation(fields: [day_summary_id], references: [day_summary_id], onDelete: Cascade)
  tender_type TenderType @relation(fields: [tender_type_id], references: [tender_type_id])

  // === INDEXES ===
  @@unique([day_summary_id, tender_type_id])
  @@index([tender_code])
  @@index([day_summary_id])
  @@map("day_tender_summaries")
}

// ============================================================================
// DAY DEPARTMENT SUMMARY - Child Rows per Department (Phase 3.3)
// ============================================================================
// Aggregates department sales across all shifts for a business day.
// One row per department with sales during the day.
// ============================================================================

model DayDepartmentSummary {
  id             String @id @default(uuid()) @db.Uuid
  day_summary_id String @db.Uuid

  // === DEPARTMENT IDENTIFICATION ===
  department_id   String @db.Uuid
  department_code String @db.VarChar(50) // Denormalized snapshot
  department_name String @db.VarChar(100) // Denormalized snapshot

  // === SALES TOTALS ===
  gross_sales     Decimal @db.Decimal(14, 2)
  returns_total   Decimal @default(0) @db.Decimal(12, 2)
  discounts_total Decimal @default(0) @db.Decimal(12, 2)
  net_sales       Decimal @db.Decimal(14, 2)

  // === TAX ===
  tax_collected Decimal @db.Decimal(12, 2)

  // === COUNTS ===
  transaction_count    Int @default(0)
  items_sold_count     Int @default(0)
  items_returned_count Int @default(0)

  // === METADATA ===
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // === RELATIONS ===
  day_summary DaySummary @relation(fields: [day_summary_id], references: [day_summary_id], onDelete: Cascade)
  department  Department @relation(fields: [department_id], references: [department_id])

  // === INDEXES ===
  @@unique([day_summary_id, department_id])
  @@index([department_code])
  @@index([day_summary_id])
  @@map("day_department_summaries")
}

// ============================================================================
// DAY TAX SUMMARY - Child Rows per Tax Rate (Phase 3.4)
// ============================================================================
// Aggregates tax collection across all shifts for a business day.
// One row per tax rate applied during the day.
// ============================================================================

model DayTaxSummary {
  id             String @id @default(uuid()) @db.Uuid
  day_summary_id String @db.Uuid

  // === TAX IDENTIFICATION ===
  tax_rate_id       String  @db.Uuid
  tax_code          String  @db.VarChar(50)
  tax_display_name  String  @db.VarChar(100)
  tax_rate_snapshot Decimal @db.Decimal(6, 5) // Rate at time of aggregation

  // === TOTALS ===
  taxable_amount Decimal @db.Decimal(14, 2) // Base amount taxed
  tax_collected  Decimal @db.Decimal(12, 2) // Tax amount collected
  exempt_amount  Decimal @db.Decimal(14, 2) // Exempt sales for this rate

  // === COUNTS ===
  transaction_count Int @default(0)

  // === METADATA ===
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // === RELATIONS ===
  day_summary DaySummary @relation(fields: [day_summary_id], references: [day_summary_id], onDelete: Cascade)
  tax_rate    TaxRate    @relation(fields: [tax_rate_id], references: [tax_rate_id])

  // === INDEXES ===
  @@unique([day_summary_id, tax_rate_id])
  @@index([tax_code])
  @@index([day_summary_id])
  @@map("day_tax_summaries")
}

// ============================================================================
// DAY HOURLY SUMMARY - Hourly Breakdown for the Day (Phase 3.5)
// ============================================================================
// Aggregates hourly totals across all shifts for a business day.
// Useful for traffic analysis and staffing optimization.
// ============================================================================

model DayHourlySummary {
  id             String @id @default(uuid()) @db.Uuid
  day_summary_id String @db.Uuid

  // === TIME PERIOD ===
  hour_start  DateTime @db.Timestamptz(6) // Start of the hour
  hour_number Int // 0-23

  // === TOTALS ===
  gross_sales       Decimal @db.Decimal(12, 2)
  net_sales         Decimal @db.Decimal(12, 2)
  transaction_count Int     @default(0)
  items_sold_count  Int     @default(0)

  // === AVERAGES ===
  avg_transaction Decimal @db.Decimal(10, 2)

  // === METADATA ===
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // === RELATIONS ===
  day_summary DaySummary @relation(fields: [day_summary_id], references: [day_summary_id], onDelete: Cascade)

  // === INDEXES ===
  @@unique([day_summary_id, hour_number])
  @@index([day_summary_id])
  @@index([hour_start])
  @@map("day_hourly_summaries")
}

// ============================================================================
// X REPORT - Mid-Shift Snapshot (Phase 4.1)
// ============================================================================
// Point-in-time snapshot of shift data generated on demand.
// Multiple X Reports can be generated per shift for interim reporting.
// Data is frozen at generation time for historical accuracy.
// ============================================================================

model XReport {
  x_report_id String @id @default(uuid()) @db.Uuid

  // === REFERENCE ===
  shift_id      String @db.Uuid
  store_id      String @db.Uuid
  report_number Int // Sequential within shift (1, 2, 3, ...)

  // === TIMING ===
  generated_at DateTime @db.Timestamptz(6)
  generated_by String   @db.Uuid

  // === SNAPSHOT DATA ===
  // Core sales metrics captured at generation time
  gross_sales       Decimal @db.Decimal(14, 2)
  returns_total     Decimal @db.Decimal(12, 2)
  discounts_total   Decimal @db.Decimal(12, 2)
  net_sales         Decimal @db.Decimal(14, 2)
  tax_collected     Decimal @db.Decimal(12, 2)
  transaction_count Int

  // === ITEM COUNTS ===
  items_sold_count     Int @default(0)
  items_returned_count Int @default(0)

  // === CASH DRAWER STATE ===
  opening_cash  Decimal @db.Decimal(10, 2)
  expected_cash Decimal @db.Decimal(10, 2) // Calculated at generation time

  // === TENDER BREAKDOWN (JSONB for flexibility) ===
  // Structure: [{ tender_code, tender_name, amount, count }]
  tender_breakdown Json @db.JsonB

  // === DEPARTMENT BREAKDOWN (JSONB for flexibility) ===
  // Structure: [{ dept_code, dept_name, gross_sales, net_sales, items }]
  department_breakdown Json @db.JsonB

  // === LOTTERY (if applicable) ===
  lottery_sales        Decimal? @db.Decimal(12, 2)
  lottery_cashes       Decimal? @db.Decimal(12, 2)
  lottery_tickets_sold Int?

  // === PRINTED/EXPORTED TRACKING ===
  was_printed Boolean @default(false)
  print_count Int     @default(0)

  // === METADATA ===
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // === RELATIONS ===
  shift             Shift @relation(fields: [shift_id], references: [shift_id], onDelete: Cascade)
  store             Store @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  generated_by_user User  @relation("XReportGeneratedBy", fields: [generated_by], references: [user_id])

  // === INDEXES ===
  @@unique([shift_id, report_number])
  @@index([shift_id, report_number])
  @@index([store_id, generated_at])
  @@index([generated_at])
  @@map("x_reports")
}

// ============================================================================
// Z REPORT - End-of-Shift Final Snapshot (Phase 4.2)
// ============================================================================
// Permanent, immutable record of shift totals generated at shift close.
// One Z Report per shift - represents the official, final shift record.
// Z Number provides sequential numbering for audit trail.
// ============================================================================

model ZReport {
  z_report_id String @id @default(uuid()) @db.Uuid

  // === REFERENCE ===
  shift_id         String   @unique @db.Uuid // One Z per shift
  shift_summary_id String   @unique @db.Uuid // Links to frozen summary
  store_id         String   @db.Uuid
  business_date    DateTime @db.Date

  // === TIMING ===
  generated_at DateTime @db.Timestamptz(6)
  generated_by String   @db.Uuid

  // === Z REPORT SPECIFIC ===
  z_number Int // Sequential Z number for store (1, 2, 3, ...)

  // === COMPLETE SNAPSHOT DATA (JSONB for archival) ===
  // Full copy of all summary data frozen at generation time
  // This ensures Z-report data never changes even if source data is modified
  // Structure includes: sales totals, tender breakdown, department breakdown,
  // tax breakdown, hourly breakdown, cash reconciliation, lottery, fuel
  report_data Json @db.JsonB

  // === PRINTED/EXPORTED TRACKING ===
  was_printed   Boolean @default(false)
  print_count   Int     @default(0)
  was_exported  Boolean @default(false)
  export_format String? @db.VarChar(20) // PDF, CSV, etc.

  // === DIGITAL SIGNATURE (for tamper detection) ===
  // SHA-256 hash of report_data for integrity verification
  signature_hash String? @db.VarChar(64)

  // === METADATA ===
  created_at DateTime @default(now()) @db.Timestamptz(6)

  // === RELATIONS ===
  shift             Shift        @relation(fields: [shift_id], references: [shift_id], onDelete: Cascade)
  shift_summary     ShiftSummary @relation(fields: [shift_summary_id], references: [shift_summary_id], onDelete: Cascade)
  store             Store        @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  generated_by_user User         @relation("ZReportGeneratedBy", fields: [generated_by], references: [user_id])

  // === INDEXES ===
  @@unique([store_id, z_number])
  @@index([store_id, z_number])
  @@index([store_id, business_date])
  @@index([generated_at])
  @@map("z_reports")
}

// ============================================================================
// SCANNED DOCUMENTS - OCR Document Scanning Feature
// ============================================================================
// Enterprise-grade storage for OCR-scanned documents with complete traceability.
// Actual files stored in S3/cloud storage - this table tracks the link.
//
// TRACEABILITY: store, company, date, shift, cashier, terminal, session
// AUDIT: who scanned, who verified, when, from where (IP)
// ============================================================================

/// Document type for OCR scanning
enum DocumentType {
  LOTTERY_SALES_REPORT
  LOTTERY_INVOICE_REPORT
  GAMING_REPORT
}

/// OCR processing status lifecycle
enum OCRStatus {
  PENDING
  PREPROCESSING
  EXTRACTING
  AWAITING_VERIFICATION
  VERIFIED
  FAILED
  REJECTED
}

/// Cloud storage provider
enum StorageProviderType {
  S3
  R2
  LOCAL
  AZURE
}

/// How data was captured
enum ScanEntryMethod {
  SCAN
  MANUAL
}

/// Scanned Document - Complete traceability for OCR-processed documents
model ScannedDocument {
  document_id String @id @default(uuid()) @db.Uuid

  // === TENANT ISOLATION & HIERARCHY ===
  store_id   String @db.Uuid
  company_id String @db.Uuid

  // === DOCUMENT TYPE ===
  document_type DocumentType

  // === TEMPORAL CONTEXT ===
  business_date    DateTime  @db.Date
  week_ending_date DateTime? @db.Date // For invoice reports (Saturday)

  // === OPERATIONAL CONTEXT (Complete Traceability) ===
  day_summary_id     String? @db.Uuid
  lottery_day_id     String? @db.Uuid
  shift_id           String? @db.Uuid
  cashier_session_id String? @db.Uuid
  terminal_id        String? @db.Uuid
  cashier_id         String? @db.Uuid

  // === PROCESSING STATUS ===
  status                      OCRStatus       @default(PENDING)
  entry_method                ScanEntryMethod @default(SCAN)
  preprocessing_started_at    DateTime?       @db.Timestamptz(6)
  preprocessing_completed_at  DateTime?       @db.Timestamptz(6)
  extraction_started_at       DateTime?       @db.Timestamptz(6)
  extraction_completed_at     DateTime?       @db.Timestamptz(6)
  total_processing_time_ms    Int?

  // === STORAGE INFORMATION ===
  storage_provider                 StorageProviderType
  storage_bucket                   String              @db.VarChar(255)
  storage_path                     String              @db.VarChar(1000)
  storage_region                   String?             @db.VarChar(50)
  cached_presigned_url             String?             @db.Text
  cached_presigned_url_expires_at  DateTime?           @db.Timestamptz(6)

  // === FILE METADATA ===
  original_filename        String  @db.VarChar(255)
  file_size_bytes          Int
  mime_type                String  @db.VarChar(100)
  file_hash                String  @db.VarChar(64)
  image_width              Int?
  image_height             Int?
  was_preprocessed         Boolean @default(false)
  preprocessing_operations Json?   @db.JsonB

  // === EXTRACTED DATA ===
  ocr_wizard_fields       Json?    @db.JsonB
  confirmed_wizard_fields Json?    @db.JsonB
  extracted_data          Json?    @db.JsonB
  raw_ocr_text            String?  @db.Text
  confidence_score        Decimal? @db.Decimal(5, 2)
  field_confidence_scores Json?    @db.JsonB

  // === REPORT METADATA (from scanned document) ===
  report_date        DateTime? @db.Date
  report_date_string String?   @db.VarChar(50)
  retailer_id        String?   @db.VarChar(50)
  report_type_string String?   @db.VarChar(100)

  // === DATE VALIDATION ===
  date_validation_passed Boolean?
  date_validation_error  String?

  // === AUDIT TRAIL - WHO ===
  scanned_by_user_id  String  @db.Uuid
  verified_by_user_id String? @db.Uuid
  rejected_by_user_id String? @db.Uuid

  // === AUDIT TRAIL - WHEN ===
  scanned_at  DateTime  @default(now()) @db.Timestamptz(6)
  verified_at DateTime? @db.Timestamptz(6)
  rejected_at DateTime? @db.Timestamptz(6)

  // === AUDIT TRAIL - WHY ===
  rejection_reason String? @db.Text
  rejection_code   String? @db.VarChar(50)

  // === CLIENT CONTEXT ===
  client_ip_address String? @db.VarChar(45) // IPv6 max length
  client_user_agent String? @db.Text

  // === REPROCESSING SUPPORT ===
  reprocessed_from_document_id String? @db.Uuid
  reprocess_count              Int     @default(0)

  // === TIMESTAMPS ===
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  // === RELATIONS ===
  store                 Store            @relation(fields: [store_id], references: [store_id], onDelete: Cascade)
  company               Company          @relation(fields: [company_id], references: [company_id], onDelete: Cascade)
  day_summary           DaySummary?      @relation(fields: [day_summary_id], references: [day_summary_id], onDelete: SetNull)
  lottery_day           LotteryBusinessDay? @relation(fields: [lottery_day_id], references: [day_id], onDelete: SetNull)
  shift                 Shift?           @relation(fields: [shift_id], references: [shift_id], onDelete: SetNull)
  cashier_session       CashierSession?  @relation(fields: [cashier_session_id], references: [session_id], onDelete: SetNull)
  terminal              POSTerminal?     @relation(fields: [terminal_id], references: [pos_terminal_id], onDelete: SetNull)
  cashier               Cashier?         @relation(fields: [cashier_id], references: [cashier_id], onDelete: SetNull)
  scanned_by_user       User             @relation("ScannedDocumentScannedBy", fields: [scanned_by_user_id], references: [user_id], onDelete: Restrict)
  verified_by_user      User?            @relation("ScannedDocumentVerifiedBy", fields: [verified_by_user_id], references: [user_id], onDelete: SetNull)
  rejected_by_user      User?            @relation("ScannedDocumentRejectedBy", fields: [rejected_by_user_id], references: [user_id], onDelete: SetNull)
  reprocessed_from      ScannedDocument? @relation("ReprocessedDocuments", fields: [reprocessed_from_document_id], references: [document_id], onDelete: SetNull)
  reprocessed_documents ScannedDocument[] @relation("ReprocessedDocuments")

  // === INDEXES ===
  @@index([store_id])
  @@index([company_id])
  @@index([business_date])
  @@index([store_id, business_date])
  @@index([store_id, document_type, business_date])
  @@index([status])
  @@index([store_id, status])
  @@index([day_summary_id])
  @@index([lottery_day_id])
  @@index([shift_id])
  @@index([cashier_id])
  @@index([scanned_by_user_id])
  @@index([scanned_at])
  @@index([storage_path])
  @@index([file_hash])
  @@map("scanned_documents")
}

// ============================================================================
// LOTTERY GAME IMPORT - Bulk Game Import with Two-Phase Commit
// ============================================================================
// Enterprise-grade bulk import for lottery games with validation preview
// Two-phase commit pattern: Validate  Preview  Commit (or Cancel)
// ============================================================================

/// LotteryGameImport - Stores validated import jobs awaiting commit
/// Two-phase commit pattern enables preview/review before committing changes
/// Tokens expire after 15 minutes to prevent stale imports
model LotteryGameImport {
  import_id        String   @id @default(uuid()) @db.Uuid
  validation_token String   @unique @db.Uuid @default(uuid())

  // === SCOPING ===
  state_id String @db.Uuid // Target state for imported games

  // === USER CONTEXT ===
  created_by_user_id String @db.Uuid

  // === VALIDATED DATA ===
  // Parsed and validated rows stored as JSON array
  // Each row contains: { row_number, status, action, data, errors?, existing_game? }
  validated_data Json @db.JsonB

  // === IMPORT OPTIONS ===
  // Options selected during validation: { skipDuplicates?, updateExisting? }
  import_options Json @db.JsonB

  // === SUMMARY STATS ===
  total_rows     Int
  valid_rows     Int
  error_rows     Int
  duplicate_rows Int

  // === LIFECYCLE ===
  expires_at   DateTime  @db.Timestamptz(6) // Token expiry (15 min from creation)
  committed_at DateTime? @db.Timestamptz(6) // NULL until committed
  created_at   DateTime  @default(now()) @db.Timestamptz(6)

  // === COMMIT RESULTS (populated after commit) ===
  // Summary: { created, updated, skipped, failed }
  commit_result Json? @db.JsonB

  // === RELATIONS ===
  state      USState @relation("LotteryGameImportState", fields: [state_id], references: [state_id], onDelete: Restrict)
  created_by User    @relation("LotteryGameImportCreatedBy", fields: [created_by_user_id], references: [user_id], onDelete: Restrict)

  // === INDEXES ===
  @@index([validation_token])
  @@index([state_id])
  @@index([created_by_user_id])
  @@index([expires_at])
  @@index([committed_at])
  @@map("lottery_game_imports")
}

/**
 * @test-level Component
 * @justification Component tests for Terminal Connection Configuration UI - validates connection type display, form rendering, dynamic fields, and validation
 * @story 4-82-terminal-connection-configuration-ui
 * @priority P0-P1 (Critical to High)
 */

import { describe, it, expect, vi, beforeEach } from "vitest";
import { renderWithProviders, screen, waitFor } from "../../support/test-utils";
import userEvent from "@testing-library/user-event";
import { ConnectionConfigForm } from "@/components/stores/ConnectionConfigForm";
import type { ConnectionConfig } from "@/types/terminal";

// Mock toast hook
const mockToast = vi.fn();
vi.mock("@/hooks/use-toast", () => ({
  useToast: () => ({
    toast: mockToast,
  }),
}));

describe("4.82-COMPONENT: Terminal Connection Configuration", () => {
  const mockStoreId = "store-123";
  const mockTerminalId = "terminal-123";
  const mockOnConfigChange = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("ConnectionConfigForm - NETWORK Connection Type", () => {
    it("[P1] should render NETWORK connection fields when connection_type is NETWORK", async () => {
      // GIVEN: ConnectionConfigForm with NETWORK connection type
      renderWithProviders(
        <ConnectionConfigForm
          connectionType="NETWORK"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
        />,
      );

      // THEN: NETWORK-specific fields are displayed
      expect(screen.getByLabelText(/Host/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/Port/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/Protocol/i)).toBeInTheDocument();
    });

    it("[P1] should update connection config when NETWORK fields are filled", async () => {
      // GIVEN: ConnectionConfigForm with NETWORK connection type
      const user = userEvent.setup();
      renderWithProviders(
        <ConnectionConfigForm
          connectionType="NETWORK"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
        />,
      );

      // WHEN: User fills NETWORK fields
      await user.type(screen.getByLabelText(/Host/i), "192.168.1.1");
      await user.type(screen.getByLabelText(/Port/i), "8080");
      await user.click(screen.getByLabelText(/Protocol/i));
      await user.click(screen.getByRole("option", { name: /TCP/i }));

      // THEN: onConfigChange is called with NETWORK config structure
      await waitFor(() => {
        expect(mockOnConfigChange).toHaveBeenCalledWith(
          expect.objectContaining({
            host: "192.168.1.1",
            port: 8080,
            protocol: "TCP",
          }),
        );
      });
    });

    it("[P1] should validate NETWORK connection config fields", async () => {
      // GIVEN: ConnectionConfigForm with NETWORK connection type
      const user = userEvent.setup();
      renderWithProviders(
        <ConnectionConfigForm
          connectionType="NETWORK"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
        />,
      );

      // WHEN: User submits with invalid port (negative number)
      await user.type(screen.getByLabelText(/Host/i), "192.168.1.1");
      await user.type(screen.getByLabelText(/Port/i), "-1");

      // THEN: Validation error is displayed
      await waitFor(() => {
        expect(
          screen.getByText(/port must be a positive integer/i),
        ).toBeInTheDocument();
      });
    });
  });

  describe("ConnectionConfigForm - API Connection Type", () => {
    it("[P1] should render API connection fields when connection_type is API", async () => {
      // GIVEN: ConnectionConfigForm with API connection type
      renderWithProviders(
        <ConnectionConfigForm
          connectionType="API"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
        />,
      );

      // THEN: API-specific fields are displayed
      expect(screen.getByLabelText(/Base URL/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/API Key/i)).toBeInTheDocument();
    });

    it("[P1] should update connection config when API fields are filled", async () => {
      // GIVEN: ConnectionConfigForm with API connection type
      const user = userEvent.setup();
      renderWithProviders(
        <ConnectionConfigForm
          connectionType="API"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
        />,
      );

      // WHEN: User fills API fields
      await user.type(
        screen.getByLabelText(/Base URL/i),
        "https://api.example.com",
      );
      await user.type(screen.getByLabelText(/API Key/i), "secret-key-123");

      // THEN: onConfigChange is called with API config structure
      await waitFor(() => {
        expect(mockOnConfigChange).toHaveBeenCalledWith(
          expect.objectContaining({
            baseUrl: "https://api.example.com",
            apiKey: "secret-key-123",
          }),
        );
      });
    });

    it("[P1] should validate API connection config URL format", async () => {
      // GIVEN: ConnectionConfigForm with API connection type
      const user = userEvent.setup();
      renderWithProviders(
        <ConnectionConfigForm
          connectionType="API"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
        />,
      );

      // WHEN: User enters invalid URL
      await user.type(screen.getByLabelText(/Base URL/i), "not-a-valid-url");

      // THEN: Validation error is displayed
      await waitFor(() => {
        expect(
          screen.getByText(/baseUrl must be a valid URL/i),
        ).toBeInTheDocument();
      });
    });
  });

  describe("ConnectionConfigForm - WEBHOOK Connection Type", () => {
    it("[P1] should render WEBHOOK connection fields when connection_type is WEBHOOK", async () => {
      // GIVEN: ConnectionConfigForm with WEBHOOK connection type
      renderWithProviders(
        <ConnectionConfigForm
          connectionType="WEBHOOK"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
          terminalId={mockTerminalId}
        />,
      );

      // THEN: WEBHOOK-specific fields are displayed
      expect(screen.getByLabelText(/Webhook URL/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/Secret/i)).toBeInTheDocument();
      // Webhook URL should be read-only
      const webhookUrlInput = screen.getByLabelText(/Webhook URL/i);
      expect(webhookUrlInput).toHaveAttribute("readonly");
    });

    it("[P1] should auto-generate webhook URL when terminal ID is provided", async () => {
      // GIVEN: ConnectionConfigForm with WEBHOOK connection type and terminal ID
      renderWithProviders(
        <ConnectionConfigForm
          connectionType="WEBHOOK"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
          terminalId={mockTerminalId}
        />,
      );

      // THEN: Webhook URL is auto-generated and displayed
      const webhookUrlInput = screen.getByLabelText(/Webhook URL/i);
      expect(webhookUrlInput).toHaveValue(
        expect.stringContaining("/api/webhooks/terminals/"),
      );
    });

    it("[P1] should update connection config when Secret field is filled", async () => {
      // GIVEN: ConnectionConfigForm with WEBHOOK connection type
      const user = userEvent.setup();
      renderWithProviders(
        <ConnectionConfigForm
          connectionType="WEBHOOK"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
          terminalId={mockTerminalId}
        />,
      );

      // WHEN: User fills Secret field
      await user.type(screen.getByLabelText(/Secret/i), "webhook-secret-123");

      // THEN: onConfigChange is called with WEBHOOK config structure
      await waitFor(() => {
        expect(mockOnConfigChange).toHaveBeenCalledWith(
          expect.objectContaining({
            secret: "webhook-secret-123",
            webhookUrl: expect.stringContaining("/api/webhooks/terminals/"),
          }),
        );
      });
    });
  });

  describe("ConnectionConfigForm - FILE Connection Type", () => {
    it("[P1] should render FILE connection fields when connection_type is FILE", async () => {
      // GIVEN: ConnectionConfigForm with FILE connection type
      renderWithProviders(
        <ConnectionConfigForm
          connectionType="FILE"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
        />,
      );

      // THEN: FILE-specific fields are displayed
      expect(screen.getByLabelText(/Import Path/i)).toBeInTheDocument();
    });

    it("[P1] should update connection config when Import Path is filled", async () => {
      // GIVEN: ConnectionConfigForm with FILE connection type
      const user = userEvent.setup();
      renderWithProviders(
        <ConnectionConfigForm
          connectionType="FILE"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
        />,
      );

      // WHEN: User fills Import Path field
      await user.type(
        screen.getByLabelText(/Import Path/i),
        "/path/to/import/file.csv",
      );

      // THEN: onConfigChange is called with FILE config structure
      await waitFor(() => {
        expect(mockOnConfigChange).toHaveBeenCalledWith({
          importPath: "/path/to/import/file.csv",
        });
      });
    });
  });

  describe("ConnectionConfigForm - MANUAL Connection Type", () => {
    it("[P2] should render no additional fields when connection_type is MANUAL", async () => {
      // GIVEN: ConnectionConfigForm with MANUAL connection type
      renderWithProviders(
        <ConnectionConfigForm
          connectionType="MANUAL"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
        />,
      );

      // THEN: No connection config fields are displayed
      expect(screen.queryByLabelText(/Host/i)).not.toBeInTheDocument();
      expect(screen.queryByLabelText(/Base URL/i)).not.toBeInTheDocument();
      expect(screen.queryByLabelText(/Webhook URL/i)).not.toBeInTheDocument();
      expect(screen.queryByLabelText(/Import Path/i)).not.toBeInTheDocument();
    });

    it("[P2] should call onConfigChange with null when connection_type is MANUAL", async () => {
      // GIVEN: ConnectionConfigForm with MANUAL connection type
      renderWithProviders(
        <ConnectionConfigForm
          connectionType="MANUAL"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
        />,
      );

      // THEN: onConfigChange is called with null/undefined
      await waitFor(() => {
        expect(mockOnConfigChange).toHaveBeenCalledWith(null);
      });
    });
  });

  describe("ConnectionConfigForm - Dynamic Field Switching", () => {
    it("[P1] should switch fields when connection type changes", async () => {
      // GIVEN: ConnectionConfigForm initially with NETWORK type
      const user = userEvent.setup();
      const { rerender } = renderWithProviders(
        <ConnectionConfigForm
          connectionType="NETWORK"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
        />,
      );

      // THEN: NETWORK fields are displayed
      expect(screen.getByLabelText(/Host/i)).toBeInTheDocument();

      // WHEN: Connection type changes to API
      rerender(
        <ConnectionConfigForm
          connectionType="API"
          connectionConfig={null}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
        />,
      );

      // THEN: API fields are displayed, NETWORK fields are hidden
      expect(screen.queryByLabelText(/Host/i)).not.toBeInTheDocument();
      expect(screen.getByLabelText(/Base URL/i)).toBeInTheDocument();
    });
  });

  describe("ConnectionConfigForm - Pre-filled Config", () => {
    it("[P2] should pre-fill fields when connection_config is provided", async () => {
      // GIVEN: ConnectionConfigForm with pre-filled NETWORK config
      const existingConfig: ConnectionConfig = {
        host: "10.0.0.1",
        port: 9000,
        protocol: "HTTP",
      };

      renderWithProviders(
        <ConnectionConfigForm
          connectionType="NETWORK"
          connectionConfig={existingConfig}
          onConfigChange={mockOnConfigChange}
          storeId={mockStoreId}
        />,
      );

      // THEN: Fields are pre-filled with existing values
      expect(screen.getByLabelText(/Host/i)).toHaveValue("10.0.0.1");
      expect(screen.getByLabelText(/Port/i)).toHaveValue(9000);
      expect(screen.getByLabelText(/Protocol/i)).toHaveTextContent("HTTP");
    });
  });
});


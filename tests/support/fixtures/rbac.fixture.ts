import { config } from "dotenv";
// Load environment variables from .env.local as defaults
// IMPORTANT: Do NOT use override: true - the test script's DATABASE_URL
// (e.g., nuvana_test) must take precedence over .env.local's DATABASE_URL
config({ path: ".env.local" });

import { test as base, APIRequestContext } from "@playwright/test";
import { assertDatabaseSafeForTests } from "../config/database-protection";

// =============================================================================
// DATABASE PROTECTION - Uses centralized config
// =============================================================================
// Validation logic is centralized in ./config/database-protection.ts
// This ensures consistency across Vitest, Playwright, and all test infrastructure.
// =============================================================================

assertDatabaseSafeForTests();

import {
  createUser,
  createCompany,
  createStore,
  createClientUser,
} from "../factories";
import {
  createSuperadminRole,
  createCorporateAdminRole,
  createStoreManagerRole,
} from "../factories";
// Import Prisma client from root node_modules (generated by npm run prisma:generate)
import { PrismaClient } from "@prisma/client";
import { createJWTAccessToken } from "../factories";
import { withBypassClient } from "../prisma-bypass";
import { createClient, RedisClientType } from "redis";

// Redis client for cache clearing in tests
let testRedisClientForFixtures: RedisClientType | null = null;

async function getTestRedisClientForFixtures(): Promise<RedisClientType | null> {
  if (testRedisClientForFixtures && testRedisClientForFixtures.isOpen) {
    return testRedisClientForFixtures;
  }

  const redisUrl = process.env.REDIS_URL || "redis://localhost:6379";

  try {
    testRedisClientForFixtures = createClient({ url: redisUrl });
    testRedisClientForFixtures.on("error", () => {
      // Silently ignore Redis errors in tests
    });
    await testRedisClientForFixtures.connect();
    return testRedisClientForFixtures;
  } catch {
    // Redis unavailable - graceful degradation
    testRedisClientForFixtures = null;
    return null;
  }
}

/**
 * Clear RBAC cache for a specific user to ensure fresh data in tests
 * This clears both user_roles and permission_check caches to match
 * the behavior of rbacService.invalidateUserRolesCache()
 */
async function clearUserRbacCache(userId: string): Promise<void> {
  try {
    const redis = await getTestRedisClientForFixtures();
    if (redis) {
      // Clear user roles cache
      await redis.del(`user_roles:${userId}`);
      // Also clear all permission check caches for this user
      // This is important because checkPermission() has its own cache
      const permissionKeys = await redis.keys(`permission_check:${userId}:*`);
      if (permissionKeys.length > 0) {
        await redis.del(permissionKeys);
      }
    }
  } catch {
    // Ignore Redis errors - tests will still work, just slower
  }
}

/**
 * UserRole interface matching the rbac.service.ts format
 * Used for pre-populating Redis cache in tests
 */
interface CachedUserRole {
  user_role_id: string;
  user_id: string;
  role_id: string;
  role_code: string;
  scope: "SYSTEM" | "COMPANY" | "STORE" | "CLIENT";
  client_id: string | null;
  company_id: string | null;
  store_id: string | null;
  permissions: string[];
}

/**
 * Pre-populate the Redis cache with user roles to bypass RLS issues in tests
 * This is necessary because:
 * 1. The rbacService.getUserRoles() queries user_roles table which has RLS
 * 2. RLS requires app.current_user_id PostgreSQL session variable to be set
 * 3. The permission middleware doesn't set this variable, causing queries to return empty
 * 4. By pre-populating the cache, we avoid the DB query entirely
 *
 * @param userId - User ID to cache roles for
 * @param roles - Array of user roles to cache
 */
async function populateUserRolesCache(
  userId: string,
  roles: CachedUserRole[],
): Promise<void> {
  try {
    const redis = await getTestRedisClientForFixtures();
    if (redis) {
      const cacheKey = `user_roles:${userId}`;
      // Use 300 second TTL (5 minutes) matching rbac.service.ts cacheTTL
      await redis.setEx(cacheKey, 300, JSON.stringify(roles));
    }
  } catch {
    // Ignore Redis errors - tests may fail but this shouldn't block
  }
}

// Note: Environment variables are loaded at the top of this file

/**
 * RBAC Test Fixtures
 *
 * Provides fixtures for RBAC testing:
 * - Authenticated users with specific roles and permissions
 * - API requests with role-based access tokens
 * - Auto-cleanup of test data
 *
 * Follows fixture architecture pattern: pure functions wrapped in fixtures
 */

type ApiRequestHelper = {
  get: (
    path: string,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
  post: (
    path: string,
    data?: unknown,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
  put: (
    path: string,
    data?: unknown,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
  delete: (
    path: string,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
  patch: (
    path: string,
    data?: unknown,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
};

type RBACFixture = {
  backendUrl: string;
  apiRequest: ApiRequestHelper;
  authenticatedApiRequest: ApiRequestHelper;
  superadminApiRequest: {
    get: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    post: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    put: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    delete: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    patch: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
  };
  corporateAdminApiRequest: {
    get: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    post: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    put: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    delete: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    patch: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
  };
  storeManagerApiRequest: {
    get: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    post: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    put: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    delete: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    patch: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
  };
  superadminUser: {
    user_id: string;
    email: string;
    name: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  corporateAdminUser: {
    user_id: string;
    email: string;
    name: string;
    company_id: string;
    store_id: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  storeManagerUser: {
    user_id: string;
    email: string;
    name: string;
    company_id: string;
    store_id: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  authenticatedShiftManager: {
    user: any;
    company: any;
    store: any;
    prisma: PrismaClient;
    token: string;
    get: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    post: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    put: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    delete: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
  };
  authenticatedUser: {
    user: any;
    company: any;
    store: any;
    prisma: PrismaClient;
    token: string;
  };
  clientUser: {
    user_id: string;
    email: string;
    name: string;
    company_id: string;
    store_id: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  regularUser: {
    user_id: string;
    email: string;
    name: string;
    roles: string[];
    permissions: string[];
    token: string;
    _roleId?: string; // Optional property for cleanup purposes
  };
  clientUserApiRequest: ApiRequestHelper;
  regularUserApiRequest: ApiRequestHelper;
  prismaClient: PrismaClient;
  rlsPrismaClient: PrismaClient;
  superadminPage: import("@playwright/test").Page;
  storeManagerPage: import("@playwright/test").Page;
  cashierUser: {
    user_id: string;
    email: string;
    name: string;
    company_id: string;
    store_id: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  cashierPage: import("@playwright/test").Page;
  clientOwnerPage: import("@playwright/test").Page;
  cashierApiRequest: ApiRequestHelper;
  systemAdminApiRequest: ApiRequestHelper;
  anotherStoreManagerUser: {
    user_id: string;
    email: string;
    name: string;
    company_id: string;
    store_id: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
};

export const test = base.extend<RBACFixture>({
  backendUrl: async ({}, use) => {
    const url = process.env.BACKEND_URL || "http://localhost:3001";
    await use(url);
  },

  apiRequest: async ({ request, backendUrl }, use) => {
    // Setup: Create unauthenticated API request helper
    const apiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: options?.headers,
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = { ...options?.headers };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.post(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = { ...options?.headers };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.put(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: options?.headers,
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = { ...options?.headers };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers,
        });
      },
    };

    await use(apiRequest);
  },

  // Alias for superadminApiRequest for backward compatibility
  authenticatedApiRequest: async (
    { request, superadminUser, backendUrl },
    use,
  ) => {
    const authenticatedApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${superadminUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.post(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${superadminUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.put(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${superadminUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers,
        });
      },
    };

    await use(authenticatedApiRequest);
  },

  prismaClient: async ({}, use: (prisma: PrismaClient) => Promise<void>) => {
    const prisma = new PrismaClient();
    await prisma.$connect();
    await use(prisma);
    await prisma.$disconnect();
  },

  rlsPrismaClient: async ({}, use: (prisma: PrismaClient) => Promise<void>) => {
    // Create a Prisma client that connects as app_user (non-superuser)
    // This client respects RLS policies unlike the postgres superuser

    // Replace postgres user with app_user in DATABASE_URL
    // Handles both formats:
    // - postgres:postgres@... (local with password)
    // - postgres@... (CI without password)
    const dbUrl = process.env.DATABASE_URL;
    if (!dbUrl) {
      throw new Error(
        "DATABASE_URL environment variable is required for RLS tests. " +
          "Run tests via npm scripts (e.g., npm run test:api) which set DATABASE_URL.",
      );
    }
    let appUserUrl = dbUrl
      .replace("postgres:postgres@", "app_user:app_user_password@")
      .replace(
        /^postgresql:\/\/postgres@/,
        "postgresql://app_user:app_user_password@",
      );

    // IMPORTANT: Force single connection pool to ensure SET session variables
    // persist across all queries. Without this, Prisma's connection pooling
    // may assign different connections to SET and subsequent queries,
    // causing RLS context to be lost. This is critical for RLS tests.
    if (appUserUrl.includes("?")) {
      appUserUrl += "&connection_limit=1";
    } else {
      appUserUrl += "?connection_limit=1";
    }

    const rlsPrisma = new PrismaClient({
      datasources: {
        db: {
          url: appUserUrl,
        },
      },
    });
    await rlsPrisma.$connect();
    await use(rlsPrisma);
    await rlsPrisma.$disconnect();
  },

  superadminUser: async ({ prismaClient }, use) => {
    // Setup: Create superadmin user with SUPERADMIN role
    const userData = createUser();
    const user = await prismaClient.user.create({ data: userData });

    // Get SUPERADMIN role (must exist in database)
    const role = await prismaClient.role.findUnique({
      where: { code: "SUPERADMIN" },
    });
    if (!role) {
      throw new Error(
        "SUPERADMIN role not found in database. Run database seed first.",
      );
    }

    // Assign SUPERADMIN role to user
    // Use bypass client to avoid RLS restrictions during test setup
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
        },
      });
    });

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["SUPERADMIN"],
      permissions: ["*"], // Superadmin has all permissions
      // Phase 2: RLS scope information
      is_system_admin: true, // SUPERADMIN has system-wide access
      company_ids: [], // System admin doesn't need specific company access
      store_ids: [], // System admin doesn't need specific store access
    });

    const superadminUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      roles: ["SUPERADMIN"],
      permissions: ["*"],
      token,
    };

    await use(superadminUser);

    // Cleanup: Delete all related data in correct FK order using bypass client
    await withBypassClient(async (bypassClient) => {
      // 1. Find shifts created by this user (cashier_id or opened_by references user)
      const userShifts = await bypassClient.shift.findMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
        select: { shift_id: true },
      });
      const shiftIds = userShifts.map((s) => s.shift_id);

      if (shiftIds.length > 0) {
        // Delete transaction payments (child of transaction)
        await bypassClient.transactionPayment.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transaction line items (child of transaction)
        await bypassClient.transactionLineItem.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transactions (child of shift)
        await bypassClient.transaction.deleteMany({
          where: { shift_id: { in: shiftIds } },
        });
      }

      // 2. Delete shifts for this user
      await bypassClient.shift.deleteMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
      });

      // 3. Delete bulk import jobs for this user
      await bypassClient.bulkImportJob.deleteMany({
        where: { user_id: user.user_id },
      });

      // 4. Delete user roles
      await bypassClient.userRole.deleteMany({
        where: { user_id: user.user_id },
      });

      // 5. Delete cashiers created by this user (FK constraint: cashiers_created_by_fkey)
      await bypassClient.cashier.deleteMany({
        where: {
          OR: [{ created_by: user.user_id }, { updated_by: user.user_id }],
        },
      });

      // 6. Delete the user (check if exists first to avoid errors if already deleted by global cleanup)
      const userExists = await bypassClient.user.findUnique({
        where: { user_id: user.user_id },
        select: { user_id: true },
      });
      if (userExists) {
        await bypassClient.user.delete({ where: { user_id: user.user_id } });
      }
    });
  },

  corporateAdminUser: async ({ prismaClient }, use) => {
    // Setup: Create corporate admin user with COMPANY scope role
    const userData = createUser({});
    const ownerUser = await prismaClient.user.create({
      data: createUser({ name: "Company Owner" }),
    });
    const companyData = createCompany({ owner_user_id: ownerUser.user_id });

    // Create company
    const company = await prismaClient.company.create({ data: companyData });

    // Create store for the corporate admin (needed by EPIC 10 tests)
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Create user
    const user = await prismaClient.user.create({ data: userData });

    // Get CORPORATE_ADMIN role (must exist in database)
    const role = await prismaClient.role.findUnique({
      where: { code: "CORPORATE_ADMIN" },
    });
    if (!role) {
      throw new Error(
        "CORPORATE_ADMIN role not found in database. Run database seed first.",
      );
    }

    // Assign CORPORATE_ADMIN role to user with company_id (COMPANY scope)
    // Use bypass client to avoid RLS restrictions during test setup
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
        },
      });
    });

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["CORPORATE_ADMIN"],
      permissions: [
        "USER_READ",
        "STORE_CREATE",
        "STORE_READ",
        "STORE_UPDATE",
        "STORE_DELETE",
        "SHIFT_READ",
        "TRANSACTION_CREATE",
        "TRANSACTION_READ",
      ],
      // Phase 2: RLS scope information
      is_system_admin: false,
      company_ids: [company.company_id], // Corporate admin has access to their company
      store_ids: [store.store_id], // Also has access to stores in their company
    });

    const corporateAdminUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      company_id: company.company_id,
      store_id: store.store_id,
      roles: ["CORPORATE_ADMIN"],
      permissions: [
        "USER_READ",
        "STORE_CREATE",
        "STORE_READ",
        "STORE_UPDATE",
        "STORE_DELETE",
        "SHIFT_READ",
        "TRANSACTION_CREATE",
        "TRANSACTION_READ",
      ],
      token,
    };

    await use(corporateAdminUser);

    // Cleanup - Use bypass client to avoid RLS restrictions during test cleanup
    // Delete in correct order to respect foreign key constraints
    await withBypassClient(async (bypassClient) => {
      // 1. Delete transaction-related data FIRST (children of transactions)
      // Get all shifts for this user to find related transactions
      const userShifts = await bypassClient.shift.findMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
        select: { shift_id: true },
      });
      const shiftIds = userShifts.map((s) => s.shift_id);

      if (shiftIds.length > 0) {
        // Delete transaction payments (child of transaction)
        await bypassClient.transactionPayment.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });

        // Delete transaction line items (child of transaction)
        await bypassClient.transactionLineItem.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });

        // Delete transactions (child of shift)
        await bypassClient.transaction.deleteMany({
          where: { shift_id: { in: shiftIds } },
        });
      }

      // 2. NOW delete shifts (after transactions are gone)
      // Use retry loop to handle race conditions with async worker processing
      // The worker may create transactions after we query but before we delete
      const MAX_RETRIES = 3;
      for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        try {
          // Re-query shifts to get current state
          const currentShifts = await bypassClient.shift.findMany({
            where: {
              OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
            },
            select: { shift_id: true },
          });
          const currentShiftIds = currentShifts.map((s) => s.shift_id);

          if (currentShiftIds.length > 0) {
            // Delete any transactions (and children) for these shifts
            await bypassClient.transactionPayment.deleteMany({
              where: { transaction: { shift_id: { in: currentShiftIds } } },
            });
            await bypassClient.transactionLineItem.deleteMany({
              where: { transaction: { shift_id: { in: currentShiftIds } } },
            });
            await bypassClient.transaction.deleteMany({
              where: { shift_id: { in: currentShiftIds } },
            });
          }

          // Now delete the shifts
          await bypassClient.shift.deleteMany({
            where: {
              OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
            },
          });
          break; // Success, exit retry loop
        } catch (error) {
          if (
            attempt === MAX_RETRIES ||
            !(error instanceof Error) ||
            !error.message.includes("Foreign key constraint")
          ) {
            throw error; // Max retries reached or different error
          }
          // Brief delay before retry to let worker finish
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
      }

      // 2. Get all stores for this company to delete their user roles
      const stores = await bypassClient.store.findMany({
        where: { company_id: company.company_id },
        select: { store_id: true },
      });
      const storeIds = stores.map((s) => s.store_id);

      // 3. Delete ALL user roles related to this company (must be before user, store, and company due to onDelete: Restrict)
      // This includes roles for the user, company, and any stores under the company
      await bypassClient.userRole.deleteMany({
        where: {
          OR: [
            { user_id: user.user_id },
            { company_id: company.company_id },
            ...(storeIds.length > 0 ? [{ store_id: { in: storeIds } }] : []),
          ],
        },
      });

      // 3.5. Delete bulk import jobs for this user (FK to users)
      await bypassClient.bulkImportJob.deleteMany({
        where: { user_id: user.user_id },
      });

      // 3.6. Delete transactions for this user (FK cashier_id to users)
      // Must delete child rows (transactionPayment, transactionLineItem) first to avoid FK constraint violations
      await bypassClient.$transaction(async (tx) => {
        // Find all transaction IDs for this cashier
        const transactions = await tx.transaction.findMany({
          where: { cashier_id: user.user_id },
          select: { transaction_id: true },
        });
        const transactionIds = transactions.map((t) => t.transaction_id);

        if (transactionIds.length > 0) {
          // Delete child rows first
          await tx.transactionPayment.deleteMany({
            where: { transaction_id: { in: transactionIds } },
          });
          await tx.transactionLineItem.deleteMany({
            where: { transaction_id: { in: transactionIds } },
          });
        }

        // Now delete the transactions
        await tx.transaction.deleteMany({
          where: { cashier_id: user.user_id },
        });
      });

      // 3.7. Delete cashiers created/updated by this user (FK: cashiers_created_by_fkey)
      await bypassClient.cashier.deleteMany({
        where: {
          OR: [{ created_by: user.user_id }, { updated_by: user.user_id }],
        },
      });

      // 4. Delete user
      await bypassClient.user.delete({ where: { user_id: user.user_id } });

      // 5. Delete POS terminals for all stores (before deleting stores)
      if (storeIds.length > 0) {
        await bypassClient.pOSTerminal.deleteMany({
          where: { store_id: { in: storeIds } },
        });
      }

      // 6. Delete stores under company (required due to onDelete: Restrict)
      await bypassClient.store.deleteMany({
        where: { company_id: company.company_id },
      });

      // 7. Delete company last
      await bypassClient.company.delete({
        where: { company_id: company.company_id },
      });
    });
  },

  storeManagerUser: async ({ prismaClient }, use) => {
    // Setup: Create store manager user with STORE scope role
    const userData = createUser({});
    const ownerUser = await prismaClient.user.create({
      data: createUser({ name: "Store Company Owner" }),
    });
    const companyData = createCompany({ owner_user_id: ownerUser.user_id });

    // Create company
    const company = await prismaClient.company.create({ data: companyData });

    // Create store
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Create user
    const user = await prismaClient.user.create({ data: userData });

    // Get STORE_MANAGER role (must exist in database)
    const role = await prismaClient.role.findUnique({
      where: { code: "STORE_MANAGER" },
    });
    if (!role) {
      throw new Error(
        "STORE_MANAGER role not found in database. Run database seed first.",
      );
    }

    // Store manager permissions list (used in multiple places)
    // Must match the seeded STORE_MANAGER role permissions from rbac.seed.ts
    const storeManagerPermissions = [
      "STORE_READ",
      "SHIFT_OPEN",
      "SHIFT_CLOSE",
      "SHIFT_READ",
      "SHIFT_REPORT_VIEW",
      "INVENTORY_READ",
      "TRANSACTION_READ",
      "LOTTERY_PACK_ACTIVATE",
      "LOTTERY_PACK_RECEIVE",
      "LOTTERY_GAME_READ",
      "LOTTERY_PACK_READ",
      "LOTTERY_VARIANCE_READ",
      "LOTTERY_BIN_READ",
      "LOTTERY_BIN_MANAGE",
      "LOTTERY_BIN_CONFIG_READ",
      "LOTTERY_BIN_CONFIG_WRITE",
      "LOTTERY_SHIFT_OPEN",
      "LOTTERY_SHIFT_CLOSE",
      "LOTTERY_SHIFT_RECONCILE",
      "LOTTERY_REPORT",
      "LOTTERY_MANUAL_ENTRY",
      "REPORT_SHIFT",
      "REPORT_DAILY",
      "REPORT_ANALYTICS",
      "REPORT_EXPORT",
      "CASHIER_CREATE",
      "CASHIER_READ",
      "CASHIER_UPDATE",
      "CASHIER_DELETE",
    ];

    // Assign STORE_MANAGER role to user with store_id (STORE scope)
    // Use bypass client to avoid RLS restrictions during test setup
    let userRoleId: string = "";
    await withBypassClient(async (bypassClient) => {
      const userRole = await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
          store_id: store.store_id,
        },
      });
      userRoleId = userRole.user_role_id;
    });

    // Pre-populate the Redis cache with user roles
    // This is necessary because the permission middleware calls rbacService.getUserRoles()
    // which queries the user_roles table. Due to RLS policies, this query returns empty
    // unless we either use withRLSTransaction (complex) or pre-populate the cache (simple)
    await populateUserRolesCache(user.user_id, [
      {
        user_role_id: userRoleId,
        user_id: user.user_id,
        role_id: role.role_id,
        role_code: "STORE_MANAGER",
        scope: "STORE",
        client_id: null,
        company_id: company.company_id,
        store_id: store.store_id,
        permissions: storeManagerPermissions,
      },
    ]);

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["STORE_MANAGER"],
      permissions: storeManagerPermissions,
      // Phase 2: RLS scope information
      is_system_admin: false,
      company_ids: [company.company_id], // Store manager has company-level visibility
      store_ids: [store.store_id], // Store manager has access to their assigned store
    });

    const storeManagerUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      company_id: company.company_id,
      store_id: store.store_id,
      roles: ["STORE_MANAGER"],
      permissions: storeManagerPermissions,
      token,
    };

    await use(storeManagerUser);

    // Cleanup - delete in correct order respecting foreign key constraints
    // Use bypass client to delete all related data properly
    await withBypassClient(async (bypassClient) => {
      // 1. Find shifts for the user
      const userShifts = await bypassClient.shift.findMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
        select: { shift_id: true },
      });
      const shiftIds = userShifts.map((s) => s.shift_id);

      if (shiftIds.length > 0) {
        // Delete transaction payments (child of transaction)
        await bypassClient.transactionPayment.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transaction line items (child of transaction)
        await bypassClient.transactionLineItem.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transactions (child of shift)
        await bypassClient.transaction.deleteMany({
          where: { shift_id: { in: shiftIds } },
        });
      }

      // 2. Delete shifts for the user
      await bypassClient.shift.deleteMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
      });

      // 3. Delete user roles for the user
      await bypassClient.userRole.deleteMany({
        where: { user_id: user.user_id },
      });

      // 4. Delete bulk import jobs for the user
      await bypassClient.bulkImportJob.deleteMany({
        where: { user_id: user.user_id },
      });

      // 5. Delete POS terminals for the store (before deleting store)
      await bypassClient.pOSTerminal.deleteMany({
        where: { store_id: store.store_id },
      });

      // 5.1. Delete NAXML scheduled export logs and exports (FK: schedule_id)
      // Wrapped in try-catch to handle case where tables don't exist yet (migration not applied)
      try {
        const schedules = await bypassClient.nAXMLScheduledExport.findMany({
          where: { store_id: store.store_id },
          select: { schedule_id: true },
        });
        if (schedules.length > 0) {
          await bypassClient.nAXMLScheduledExportLog.deleteMany({
            where: { schedule_id: { in: schedules.map((s) => s.schedule_id) } },
          });
        }

        // 5.2. Delete NAXML scheduled exports (FK: store_id, pos_integration_id)
        await bypassClient.nAXMLScheduledExport.deleteMany({
          where: { store_id: store.store_id },
        });
      } catch (error: unknown) {
        // P2021 = table does not exist - ignore if NAXML tables not yet migrated
        if (
          error &&
          typeof error === "object" &&
          "code" in error &&
          error.code === "P2021"
        ) {
          // Tables don't exist yet, skip cleanup
        } else {
          throw error;
        }
      }

      // 5.3. Delete POS integrations (FK: store_id)
      await bypassClient.pOSIntegration.deleteMany({
        where: { store_id: store.store_id },
      });

      // 5.5. Delete cashiers created/updated by this user (FK: cashiers_created_by_fkey)
      await bypassClient.cashier.deleteMany({
        where: {
          OR: [{ created_by: user.user_id }, { updated_by: user.user_id }],
        },
      });

      // 6. Delete the store manager user
      await bypassClient.user.delete({ where: { user_id: user.user_id } });

      // 7. Delete store (use deleteMany to avoid errors if already deleted)
      await bypassClient.store.deleteMany({
        where: { store_id: store.store_id },
      });

      // 8. Delete company (use deleteMany to avoid errors if already deleted)
      await bypassClient.company.deleteMany({
        where: { company_id: company.company_id },
      });

      // 8.5. Delete cashiers created/updated by owner user (FK: cashiers_created_by_fkey)
      await bypassClient.cashier.deleteMany({
        where: {
          OR: [
            { created_by: ownerUser.user_id },
            { updated_by: ownerUser.user_id },
          ],
        },
      });

      // 9. Delete the owner user (created for company ownership)
      await bypassClient.user.delete({ where: { user_id: ownerUser.user_id } });
    });
  },

  authenticatedShiftManager: async (
    { prismaClient, request, backendUrl },
    use,
  ) => {
    // Setup: Create shift manager user with SHIFT_MANAGER role and SHIFT_RECONCILE permission
    const userData = createUser({});
    const ownerUser = await prismaClient.user.create({
      data: createUser({ name: "Shift Manager Company Owner" }),
    });
    const companyData = createCompany({ owner_user_id: ownerUser.user_id });

    // Create company
    const company = await prismaClient.company.create({ data: companyData });

    // Create store
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Create user
    const user = await prismaClient.user.create({ data: userData });

    // Get SHIFT_MANAGER role (must exist in database)
    const role = await prismaClient.role.findUnique({
      where: { code: "SHIFT_MANAGER" },
    });
    if (!role) {
      throw new Error(
        "SHIFT_MANAGER role not found in database. Run database seed first.",
      );
    }

    // Assign SHIFT_MANAGER role to user with store_id (STORE scope)
    // Use bypass client to avoid RLS restrictions during test setup
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
          store_id: store.store_id,
        },
      });
    });

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["SHIFT_MANAGER"],
      permissions: [
        "SHIFT_OPEN",
        "SHIFT_CLOSE",
        "SHIFT_READ",
        "SHIFT_RECONCILE",
      ],
    });

    const authenticatedShiftManager = {
      user,
      company,
      store,
      prisma: prismaClient,
      token,
      // Provide API request helper similar to authenticatedApiRequest
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.post(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.put(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${token}`,
            ...options?.headers,
          },
        });
      },
    };

    await use(authenticatedShiftManager);

    // Cleanup - delete in correct order respecting foreign key constraints
    await withBypassClient(async (bypassClient) => {
      // 1. Delete shifts for the user (shifts reference user via cashier_id and opened_by)
      const userShifts = await bypassClient.shift.findMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
        select: { shift_id: true },
      });
      const shiftIds = userShifts.map((s) => s.shift_id);

      if (shiftIds.length > 0) {
        // Delete transaction payments (child of transaction)
        await bypassClient.transactionPayment.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transaction line items (child of transaction)
        await bypassClient.transactionLineItem.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transactions (child of shift)
        await bypassClient.transaction.deleteMany({
          where: { shift_id: { in: shiftIds } },
        });
      }

      await bypassClient.shift.deleteMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
      });

      // 2. Delete user roles for the user
      await bypassClient.userRole.deleteMany({
        where: { user_id: user.user_id },
      });

      // 3. Delete bulk import jobs for the user (FK to users)
      await bypassClient.bulkImportJob.deleteMany({
        where: { user_id: user.user_id },
      });

      // 4. Delete POS terminals for the store (before deleting store)
      await bypassClient.pOSTerminal.deleteMany({
        where: { store_id: store.store_id },
      });

      // 4.5. Delete cashiers created/updated by this user (FK: cashiers_created_by_fkey)
      await bypassClient.cashier.deleteMany({
        where: {
          OR: [{ created_by: user.user_id }, { updated_by: user.user_id }],
        },
      });

      // 5. Delete the shift manager user
      await bypassClient.user.delete({ where: { user_id: user.user_id } });

      // 6. Delete store
      await bypassClient.store.delete({ where: { store_id: store.store_id } });

      // 7. Delete company
      await bypassClient.company.delete({
        where: { company_id: company.company_id },
      });

      // 7.5. Delete cashiers created/updated by owner user (FK: cashiers_created_by_fkey)
      await bypassClient.cashier.deleteMany({
        where: {
          OR: [
            { created_by: ownerUser.user_id },
            { updated_by: ownerUser.user_id },
          ],
        },
      });

      // 8. Delete the owner user (created for company ownership)
      await bypassClient.user.delete({ where: { user_id: ownerUser.user_id } });
    });
  },

  authenticatedUser: async ({ prismaClient }, use) => {
    // Setup: Create authenticated user without SHIFT_RECONCILE permission (for permission testing)
    const userData = createUser({});
    const ownerUser = await prismaClient.user.create({
      data: createUser({ name: "Authenticated User Company Owner" }),
    });
    const companyData = createCompany({ owner_user_id: ownerUser.user_id });

    // Create company
    const company = await prismaClient.company.create({ data: companyData });

    // Create store
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Create user
    const user = await prismaClient.user.create({ data: userData });

    // Get STORE_MANAGER role (without SHIFT_RECONCILE permission)
    const role = await prismaClient.role.findUnique({
      where: { code: "STORE_MANAGER" },
    });
    if (!role) {
      throw new Error(
        "STORE_MANAGER role not found in database. Run database seed first.",
      );
    }

    // Assign STORE_MANAGER role to user with store_id (STORE scope)
    // Use bypass client to avoid RLS restrictions during test setup
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
          store_id: store.store_id,
        },
      });
    });

    // Clear RBAC cache to ensure the new role is visible to the API immediately
    await clearUserRbacCache(user.user_id);

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["STORE_MANAGER"],
      permissions: [
        "STORE_READ",
        "SHIFT_OPEN",
        "SHIFT_CLOSE",
        "SHIFT_READ",
        // Note: SHIFT_RECONCILE is intentionally omitted for permission testing
      ],
    });

    const authenticatedUser = {
      user,
      company,
      store,
      prisma: prismaClient,
      token,
    };

    await use(authenticatedUser);

    // Cleanup - delete in correct order respecting foreign key constraints
    await withBypassClient(async (bypassClient) => {
      // 1. Delete shifts for the user (shifts reference user via cashier_id and opened_by)
      const userShifts = await bypassClient.shift.findMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
        select: { shift_id: true },
      });
      const shiftIds = userShifts.map((s) => s.shift_id);

      if (shiftIds.length > 0) {
        // Delete transaction payments (child of transaction)
        await bypassClient.transactionPayment.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transaction line items (child of transaction)
        await bypassClient.transactionLineItem.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transactions (child of shift)
        await bypassClient.transaction.deleteMany({
          where: { shift_id: { in: shiftIds } },
        });
      }

      await bypassClient.shift.deleteMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
      });

      // 2. Delete user roles for the user
      await bypassClient.userRole.deleteMany({
        where: { user_id: user.user_id },
      });

      // 3. Delete bulk import jobs for the user (FK to users)
      await bypassClient.bulkImportJob.deleteMany({
        where: { user_id: user.user_id },
      });

      // 4. Delete POS terminals for the store (before deleting store)
      await bypassClient.pOSTerminal.deleteMany({
        where: { store_id: store.store_id },
      });

      // 4.5. Delete cashiers created/updated by this user (FK: cashiers_created_by_fkey)
      await bypassClient.cashier.deleteMany({
        where: {
          OR: [{ created_by: user.user_id }, { updated_by: user.user_id }],
        },
      });

      // 5. Delete the authenticated user
      await bypassClient.user.delete({ where: { user_id: user.user_id } });

      // 6. Delete store
      await bypassClient.store.delete({ where: { store_id: store.store_id } });

      // 7. Delete company
      await bypassClient.company.delete({
        where: { company_id: company.company_id },
      });

      // 7.5. Delete cashiers created/updated by owner user (FK: cashiers_created_by_fkey)
      await bypassClient.cashier.deleteMany({
        where: {
          OR: [
            { created_by: ownerUser.user_id },
            { updated_by: ownerUser.user_id },
          ],
        },
      });

      // 8. Delete the owner user (created for company ownership)
      await bypassClient.user.delete({ where: { user_id: ownerUser.user_id } });
    });
  },

  superadminApiRequest: async (
    { request, superadminUser, backendUrl },
    use,
  ) => {
    const superadminApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Check if data is multipart object (for file uploads)
        // Playwright multipart expects: { fieldName: { name: string, mimeType: string, buffer: Buffer } }
        const isMultipart =
          data && typeof data === "object" && "multipart" in data;
        const headers: Record<string, string> = {
          Cookie: `access_token=${superadminUser.token}`,
        };
        // Only set Content-Type for non-multipart requests
        if (!isMultipart) {
          headers["Content-Type"] = "application/json";
        }
        // Merge with provided headers (but filter out Content-Type for multipart)
        if (options?.headers) {
          Object.entries(options.headers).forEach(([key, value]) => {
            // For multipart, skip Content-Type header to let Playwright set it with boundary
            if (isMultipart && key.toLowerCase() === "content-type") {
              return;
            }
            // eslint-disable-next-line security/detect-object-injection -- Safe: key comes from Object.entries on options.headers
            headers[key] = value;
          });
        }
        return request.post(`${backendUrl}${path}`, {
          data: isMultipart ? undefined : data,
          multipart: isMultipart ? (data as any).multipart : undefined,
          headers,
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${superadminUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.put(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${superadminUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers,
        });
      },
    };

    await use(superadminApiRequest);
  },

  corporateAdminApiRequest: async (
    { request, corporateAdminUser, backendUrl },
    use,
  ) => {
    const corporateAdminApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${corporateAdminUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Check if data is FormData - if so, use multipart and don't set Content-Type
        const isFormData = data instanceof FormData;
        const headers: Record<string, string> = {
          Cookie: `access_token=${corporateAdminUser.token}`,
        };
        // Only set Content-Type for non-FormData requests
        if (!isFormData) {
          headers["Content-Type"] = "application/json";
        }
        // Merge with provided headers (but filter out Content-Type for FormData)
        if (options?.headers) {
          Object.entries(options.headers).forEach(([key, value]) => {
            // For FormData, skip Content-Type header to let Playwright set it with boundary
            if (isFormData && key.toLowerCase() === "content-type") {
              return;
            }
            // eslint-disable-next-line security/detect-object-injection -- Safe: key comes from Object.entries on options.headers
            headers[key] = value;
          });
        }
        return request.post(`${backendUrl}${path}`, {
          data: isFormData ? undefined : data,
          multipart: isFormData ? data : undefined,
          headers,
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${corporateAdminUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.put(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${corporateAdminUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${corporateAdminUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers,
        });
      },
    };

    await use(corporateAdminApiRequest);
  },

  storeManagerApiRequest: async (
    { request, storeManagerUser, backendUrl },
    use,
  ) => {
    const storeManagerApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${storeManagerUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${storeManagerUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.post(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        // to avoid Fastify FST_ERR_CTP_EMPTY_JSON_BODY error
        const headers: Record<string, string> = {
          Cookie: `access_token=${storeManagerUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.put(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${storeManagerUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        // to avoid Fastify FST_ERR_CTP_EMPTY_JSON_BODY error
        const headers: Record<string, string> = {
          Cookie: `access_token=${storeManagerUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers,
        });
      },
    };

    await use(storeManagerApiRequest);
  },

  clientUser: async ({ prismaClient }, use) => {
    // Setup: Create client user with CLIENT_OWNER role and own company/store
    // CLIENT_OWNER has full permissions including CLIENT_ROLE_MANAGE
    const userData = createClientUser();

    // Create user first (will be company owner)
    const user = await prismaClient.user.create({ data: userData });

    // Create company owned by this client user
    const companyData = createCompany({ owner_user_id: user.user_id });
    const company = await prismaClient.company.create({ data: companyData });

    // Create store for the company
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Get CLIENT_OWNER role (must exist in database)
    // CLIENT_OWNER has CLIENT_ROLE_MANAGE permission, CLIENT_USER does not
    const role = await prismaClient.role.findUnique({
      where: { code: "CLIENT_OWNER" },
    });
    if (!role) {
      throw new Error(
        "CLIENT_OWNER role not found in database. Run database seed first.",
      );
    }

    // Assign CLIENT_OWNER role to user
    let userRoleId: string = "";
    await withBypassClient(async (bypassClient) => {
      const userRole = await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
        },
      });
      userRoleId = userRole.user_role_id;
    });

    // Clear RBAC cache to ensure the new role is visible to the API immediately
    await clearUserRbacCache(user.user_id);

    // Assign default STORE scope roles to the company via CompanyAllowedRole
    // This is required for client role permission management (Story 2.92)
    // IMPORTANT: Query MUST be inside withBypassClient to prevent race conditions
    // in parallel test workers where roles could be deleted between query and insert
    await withBypassClient(async (bypassClient) => {
      const storeRoles = await bypassClient.role.findMany({
        where: {
          scope: "STORE",
          deleted_at: null,
          is_system_role: true, // Only system roles (never deleted during tests)
        },
      });
      await bypassClient.companyAllowedRole.createMany({
        data: storeRoles.map((storeRole) => ({
          company_id: company.company_id,
          role_id: storeRole.role_id,
          assigned_by: user.user_id,
        })),
        skipDuplicates: true,
      });
    });

    // Client Owner permissions - CLIENT_OWNER has ALL company and store scope permissions
    // Does NOT include ADMIN_* which is Super Admin only
    // Must match the permissions defined in rbac.seed.ts for CLIENT_OWNER role
    const clientPermissions = [
      // Company Management
      "COMPANY_CREATE",
      "COMPANY_READ",
      "COMPANY_UPDATE",
      "COMPANY_DELETE",
      // Store Management
      "STORE_CREATE",
      "STORE_READ",
      "STORE_UPDATE",
      "STORE_DELETE",
      // User Management
      "USER_CREATE",
      "USER_READ",
      "USER_UPDATE",
      "USER_DELETE",
      // Shift Operations
      "SHIFT_OPEN",
      "SHIFT_CLOSE",
      "SHIFT_READ",
      "SHIFT_RECONCILE",
      "SHIFT_REPORT_VIEW",
      // Transaction Management
      "TRANSACTION_CREATE",
      "TRANSACTION_READ",
      "TRANSACTION_IMPORT",
      // Inventory Management
      "INVENTORY_READ",
      "INVENTORY_ADJUST",
      "INVENTORY_ORDER",
      // Lottery Management
      "LOTTERY_GAME_READ",
      "LOTTERY_PACK_READ",
      "LOTTERY_PACK_RECEIVE",
      "LOTTERY_PACK_ACTIVATE",
      "LOTTERY_VARIANCE_READ",
      "LOTTERY_BIN_READ",
      "LOTTERY_BIN_MANAGE",
      "LOTTERY_BIN_CONFIG_READ",
      "LOTTERY_BIN_CONFIG_WRITE",
      "LOTTERY_SHIFT_OPEN",
      "LOTTERY_SHIFT_CLOSE",
      "LOTTERY_SHIFT_RECONCILE",
      "LOTTERY_REPORT",
      // Reports
      "REPORT_SHIFT",
      "REPORT_DAILY",
      "REPORT_ANALYTICS",
      "REPORT_EXPORT",
      // Client Dashboard Access
      "CLIENT_DASHBOARD_ACCESS",
      // Client Employee Management
      "CLIENT_EMPLOYEE_CREATE",
      "CLIENT_EMPLOYEE_READ",
      "CLIENT_EMPLOYEE_DELETE",
      "CLIENT_EMPLOYEE_MANAGE",
      // Cashier Management
      "CASHIER_CREATE",
      "CASHIER_READ",
      "CASHIER_UPDATE",
      "CASHIER_DELETE",
      // Client Role Management
      "CLIENT_ROLE_MANAGE",
      // Configuration Management (Phase 1: Shift & Day Summary)
      "TENDER_TYPE_READ",
      "TENDER_TYPE_MANAGE",
      "DEPARTMENT_READ",
      "DEPARTMENT_MANAGE",
      "TAX_RATE_READ",
      "TAX_RATE_MANAGE",
      "CONFIG_READ",
      "CONFIG_MANAGE",
      // POS Integration (Phase 1.6)
      "POS_CONNECTION_READ",
      "POS_CONNECTION_MANAGE",
      "POS_SYNC_TRIGGER",
      "POS_SYNC_LOG_READ",
      // POS Audit (Phase 0)
      "POS_AUDIT_READ",
      // NAXML File Management (Phase 1)
      "NAXML_FILE_READ",
      "NAXML_FILE_IMPORT",
      "NAXML_FILE_EXPORT",
      "NAXML_WATCHER_READ",
      "NAXML_WATCHER_MANAGE",
    ];

    // Pre-populate the Redis cache with user roles
    // This is necessary because the permission middleware calls rbacService.getUserRoles()
    // which queries the user_roles table. Due to RLS policies, this query returns empty
    // unless we either use withRLSTransaction (complex) or pre-populate the cache (simple)
    await populateUserRolesCache(user.user_id, [
      {
        user_role_id: userRoleId,
        user_id: user.user_id,
        role_id: role.role_id,
        role_code: "CLIENT_OWNER",
        scope: "COMPANY",
        client_id: null,
        company_id: company.company_id,
        store_id: null,
        permissions: clientPermissions,
      },
    ]);

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["CLIENT_OWNER"],
      permissions: clientPermissions,
      // Phase 2: RLS scope information
      is_system_admin: false,
      company_ids: [company.company_id], // Client owner has access to their own company
      store_ids: [store.store_id], // And stores within their company
    });

    const clientUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      company_id: company.company_id,
      store_id: store.store_id,
      roles: ["CLIENT_OWNER"],
      permissions: clientPermissions,
      token,
    };

    await use(clientUser);

    // Cleanup: Delete all related data in correct FK order using bypass client
    await withBypassClient(async (bypassClient) => {
      // 1. Find shifts created by this user
      const userShifts = await bypassClient.shift.findMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
        select: { shift_id: true },
      });
      const shiftIds = userShifts.map((s) => s.shift_id);

      if (shiftIds.length > 0) {
        // Delete transaction payments (child of transaction)
        await bypassClient.transactionPayment.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transaction line items (child of transaction)
        await bypassClient.transactionLineItem.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transactions (child of shift)
        await bypassClient.transaction.deleteMany({
          where: { shift_id: { in: shiftIds } },
        });
      }

      // 2. Delete shifts for this user
      await bypassClient.shift.deleteMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
      });

      // 3. Delete user roles
      await bypassClient.userRole.deleteMany({
        where: { user_id: user.user_id },
      });

      // 4. Delete company allowed roles
      await bypassClient.companyAllowedRole.deleteMany({
        where: { company_id: company.company_id },
      });

      // 5. Delete client role permissions (if any were created during tests)
      await bypassClient.clientRolePermission.deleteMany({
        where: { owner_user_id: user.user_id },
      });

      // 6. Delete POS terminals for the store
      await bypassClient.pOSTerminal.deleteMany({
        where: { store_id: store.store_id },
      });

      // 6.1. Delete NAXML scheduled export logs and exports (FK: schedule_id)
      // Wrapped in try-catch to handle case where tables don't exist yet (migration not applied)
      try {
        const schedules = await bypassClient.nAXMLScheduledExport.findMany({
          where: { store_id: store.store_id },
          select: { schedule_id: true },
        });
        if (schedules.length > 0) {
          await bypassClient.nAXMLScheduledExportLog.deleteMany({
            where: { schedule_id: { in: schedules.map((s) => s.schedule_id) } },
          });
        }

        // 6.2. Delete NAXML scheduled exports (FK: store_id, pos_integration_id)
        await bypassClient.nAXMLScheduledExport.deleteMany({
          where: { store_id: store.store_id },
        });
      } catch (error: unknown) {
        // P2021 = table does not exist - ignore if NAXML tables not yet migrated
        if (
          error &&
          typeof error === "object" &&
          "code" in error &&
          error.code === "P2021"
        ) {
          // Tables don't exist yet, skip cleanup
        } else {
          throw error;
        }
      }

      // 6.3. Delete POS integrations (FK: store_id)
      await bypassClient.pOSIntegration.deleteMany({
        where: { store_id: store.store_id },
      });

      // 7. Delete store (use deleteMany to avoid errors if already deleted)
      await bypassClient.store.deleteMany({
        where: { store_id: store.store_id },
      });

      // 8. Delete company (use deleteMany to avoid errors if already deleted)
      await bypassClient.company.deleteMany({
        where: { company_id: company.company_id },
      });

      // 8.5. Delete cashiers created/updated by this user (FK: cashiers_created_by_fkey)
      await bypassClient.cashier.deleteMany({
        where: {
          OR: [{ created_by: user.user_id }, { updated_by: user.user_id }],
        },
      });

      // 9. Delete user (use deleteMany to avoid errors if already deleted)
      await bypassClient.user.deleteMany({ where: { user_id: user.user_id } });
    });
  },

  regularUser: async ({ prismaClient }, use) => {
    // Setup: Create regular user WITHOUT CLIENT_EMPLOYEE permissions
    // Important: We create a custom role because system roles like CASHIER have CLIENT_EMPLOYEE_READ
    const userData = createUser({});
    const user = await prismaClient.user.create({ data: userData });

    // Create a company and store for context (user needs some context)
    const ownerUser = await prismaClient.user.create({
      data: createUser({ name: "Regular User Company Owner" }),
    });
    const company = await prismaClient.company.create({
      data: createCompany({ owner_user_id: ownerUser.user_id }),
    });
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Create a custom role with ONLY basic permissions (no CLIENT_EMPLOYEE_*)
    // This ensures the permission check via DB also fails
    const restrictedRole = await prismaClient.role.create({
      data: {
        code: `RESTRICTED_USER_${Date.now()}`,
        scope: "STORE",
        description:
          "Test role with restricted permissions for authorization tests",
        is_system_role: false,
      },
    });

    // Get permission IDs for the limited permissions we want to assign
    const shiftReadPermission = await prismaClient.permission.findUnique({
      where: { code: "SHIFT_READ" },
    });
    const inventoryReadPermission = await prismaClient.permission.findUnique({
      where: { code: "INVENTORY_READ" },
    });

    // Assign only basic permissions to the role (NOT CLIENT_EMPLOYEE_*)
    if (shiftReadPermission) {
      await prismaClient.rolePermission.create({
        data: {
          role_id: restrictedRole.role_id,
          permission_id: shiftReadPermission.permission_id,
        },
      });
    }
    if (inventoryReadPermission) {
      await prismaClient.rolePermission.create({
        data: {
          role_id: restrictedRole.role_id,
          permission_id: inventoryReadPermission.permission_id,
        },
      });
    }

    // Assign restricted role to user
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: restrictedRole.role_id,
          company_id: company.company_id,
          store_id: store.store_id,
        },
      });
    });

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: [restrictedRole.code],
      permissions: ["SHIFT_READ", "INVENTORY_READ"], // Must match DB role permissions
    });

    const regularUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      roles: [restrictedRole.code],
      permissions: ["SHIFT_READ", "INVENTORY_READ"],
      token,
      _roleId: restrictedRole.role_id, // Store for cleanup
    };

    await use(regularUser);

    // Cleanup: Delete all related data in correct FK order using bypass client
    await withBypassClient(async (bypassClient) => {
      // 1. Find shifts created by this user
      const userShifts = await bypassClient.shift.findMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
        select: { shift_id: true },
      });
      const shiftIds = userShifts.map((s) => s.shift_id);

      if (shiftIds.length > 0) {
        // Delete transaction payments (child of transaction)
        await bypassClient.transactionPayment.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transaction line items (child of transaction)
        await bypassClient.transactionLineItem.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transactions (child of shift)
        await bypassClient.transaction.deleteMany({
          where: { shift_id: { in: shiftIds } },
        });
      }

      // 2. Delete shifts for this user
      await bypassClient.shift.deleteMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
      });

      // 3. Delete user roles
      await bypassClient.userRole.deleteMany({
        where: { user_id: user.user_id },
      });

      // 4. Delete role permissions for the restricted role
      await bypassClient.rolePermission.deleteMany({
        where: { role_id: restrictedRole.role_id },
      });

      // 5. Delete the restricted role
      await bypassClient.role.delete({
        where: { role_id: restrictedRole.role_id },
      });

      // 5.5. Delete cashiers created/updated by this user (FK: cashiers_created_by_fkey)
      await bypassClient.cashier.deleteMany({
        where: {
          OR: [{ created_by: user.user_id }, { updated_by: user.user_id }],
        },
      });

      // 6. Delete the regular user
      await bypassClient.user.delete({ where: { user_id: user.user_id } });

      // 7. Delete POS terminals for the store
      await bypassClient.pOSTerminal.deleteMany({
        where: { store_id: store.store_id },
      });

      // 8. Delete store
      await bypassClient.store.delete({ where: { store_id: store.store_id } });

      // 9. Delete company
      await bypassClient.company.delete({
        where: { company_id: company.company_id },
      });

      // 9.5. Delete cashiers created/updated by owner user (FK: cashiers_created_by_fkey)
      await bypassClient.cashier.deleteMany({
        where: {
          OR: [
            { created_by: ownerUser.user_id },
            { updated_by: ownerUser.user_id },
          ],
        },
      });

      // 10. Delete owner user
      await bypassClient.user.delete({ where: { user_id: ownerUser.user_id } });
    });
  },

  clientUserApiRequest: async ({ request, clientUser, backendUrl }, use) => {
    const clientUserApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${clientUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${clientUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.post(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${clientUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.put(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${clientUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${clientUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers,
        });
      },
    };

    await use(clientUserApiRequest);
  },

  regularUserApiRequest: async ({ request, regularUser, backendUrl }, use) => {
    const regularUserApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${regularUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${regularUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.post(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${regularUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.put(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${regularUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${regularUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers,
        });
      },
    };

    await use(regularUserApiRequest);
  },

  superadminPage: async ({ page, superadminUser }, use) => {
    // Setup: Use real authentication with JWT cookie
    // This is proper E2E testing - no mocking of auth endpoints
    // The cookie contains a valid JWT that the backend will verify

    // Add authentication cookie (real JWT token)
    await page.context().addCookies([
      {
        name: "access_token",
        value: superadminUser.token,
        domain: "localhost",
        path: "/",
      },
    ]);

    // Set localStorage auth_session directly to bypass API call during tests
    // This ensures the AuthContext recognizes the user as authenticated
    // The cookie is still set for API calls that need it
    await page.addInitScript((userData) => {
      localStorage.setItem(
        "auth_session",
        JSON.stringify({
          user: {
            id: userData.user_id,
            email: userData.email,
            name: userData.name,
          },
          authenticated: true,
          isClientUser: false,
        }),
      );
    }, superadminUser);

    // Navigate to dashboard - AuthContext will use the localStorage session
    // Use domcontentloaded instead of networkidle for better CI reliability
    // networkidle can timeout in resource-constrained CI environments
    await page.goto(
      `${process.env.FRONTEND_URL || "http://localhost:3000"}/dashboard`,
      { waitUntil: "domcontentloaded" },
    );

    // Wait for the page to finish loading; this uses the load state rather than waiting for a specific dashboard element
    // This is more reliable than networkidle in CI environments
    await page.waitForLoadState("load");

    await use(page);

    // Cleanup: Clear session state
    await page.context().clearCookies();
    await page.evaluate(() => {
      localStorage.clear();
      sessionStorage.clear();
    });
  },

  cashierUser: async ({ prismaClient }, use) => {
    // Setup: Create cashier user with SHIFT_OPEN permission
    const userData = createClientUser();
    const user = await prismaClient.user.create({ data: userData });

    // Create company and store
    const companyData = createCompany({ owner_user_id: user.user_id });
    const company = await prismaClient.company.create({ data: companyData });
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Get CLIENT_USER role (cashier role)
    const role = await prismaClient.role.findUnique({
      where: { code: "CLIENT_USER" },
    });
    if (!role) {
      throw new Error(
        "CLIENT_USER role not found in database. Run database seed first.",
      );
    }

    // Assign CLIENT_USER role to user
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
          store_id: store.store_id,
        },
      });
    });

    // Cashier permissions - includes SHIFT_OPEN for self-service shift start
    const cashierPermissions = [
      "CLIENT_DASHBOARD_ACCESS",
      "SHIFT_OPEN",
      "SHIFT_READ",
      "STORE_READ",
    ];

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["CLIENT_USER"],
      permissions: cashierPermissions,
      // Phase 2: RLS scope information
      is_system_admin: false,
      company_ids: [company.company_id],
      store_ids: [store.store_id],
    });

    const cashierUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      company_id: company.company_id,
      store_id: store.store_id,
      roles: ["CLIENT_USER"],
      permissions: cashierPermissions,
      token,
    };

    await use(cashierUser);

    // Cleanup: Delete all related data in correct FK order using bypass client
    await withBypassClient(async (bypassClient) => {
      // 1. Find shifts created by this user (cashier_id or opened_by references user)
      const userShifts = await bypassClient.shift.findMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
        select: { shift_id: true },
      });
      const shiftIds = userShifts.map((s) => s.shift_id);

      if (shiftIds.length > 0) {
        // Delete transaction payments (child of transaction)
        await bypassClient.transactionPayment.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transaction line items (child of transaction)
        await bypassClient.transactionLineItem.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        // Delete transactions (child of shift)
        await bypassClient.transaction.deleteMany({
          where: { shift_id: { in: shiftIds } },
        });
      }

      // 2. Delete shifts for this user
      await bypassClient.shift.deleteMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
      });

      // 3. Delete POS terminals for the store (before deleting store)
      await bypassClient.pOSTerminal.deleteMany({
        where: { store_id: store.store_id },
      });

      // 4. Delete user roles
      await bypassClient.userRole.deleteMany({
        where: { user_id: user.user_id },
      });

      // 5. Delete store (must delete after terminals)
      await bypassClient.store.delete({ where: { store_id: store.store_id } });

      // 6. Delete company
      await bypassClient.company.delete({
        where: { company_id: company.company_id },
      });

      // 6.5. Delete cashiers created/updated by this user (FK: cashiers_created_by_fkey)
      await bypassClient.cashier.deleteMany({
        where: {
          OR: [{ created_by: user.user_id }, { updated_by: user.user_id }],
        },
      });

      // 7. Delete the user
      await bypassClient.user.delete({ where: { user_id: user.user_id } });
    });
  },

  cashierPage: async ({ page, cashierUser }, use) => {
    // Setup: Use real authentication with JWT cookie
    // This is proper E2E testing - no mocking of auth endpoints

    // Add authentication cookie (real JWT token)
    await page.context().addCookies([
      {
        name: "access_token",
        value: cashierUser.token,
        domain: "localhost",
        path: "/",
      },
    ]);

    // Set localStorage auth_session directly to bypass API call during tests
    await page.addInitScript((userData) => {
      localStorage.setItem(
        "auth_session",
        JSON.stringify({
          user: {
            id: userData.user_id,
            email: userData.email,
            name: userData.name,
          },
          authenticated: true,
          isClientUser: true, // Cashier is a client user
        }),
      );
    }, cashierUser);

    // Navigate to dashboard - AuthContext will use the localStorage session
    // Use domcontentloaded instead of networkidle for better CI reliability
    await page.goto(
      `${process.env.FRONTEND_URL || "http://localhost:3000"}/dashboard`,
      { waitUntil: "domcontentloaded" },
    );

    // Wait for the page to be ready
    await page.waitForLoadState("load");

    await use(page);

    // Cleanup: Clear session state
    await page.context().clearCookies();
    await page.evaluate(() => {
      localStorage.clear();
      sessionStorage.clear();
    });
  },

  storeManagerPage: async ({ page, storeManagerUser }, use) => {
    // Setup: Use real authentication with JWT cookie
    // This is proper E2E testing - no mocking of auth endpoints

    // Add authentication cookie (real JWT token)
    await page.context().addCookies([
      {
        name: "access_token",
        value: storeManagerUser.token,
        domain: "localhost",
        path: "/",
      },
    ]);

    // Set localStorage auth_session directly to bypass API call during tests
    await page.addInitScript((userData) => {
      localStorage.setItem(
        "auth_session",
        JSON.stringify({
          user: {
            id: userData.user_id,
            email: userData.email,
            name: userData.name,
          },
          authenticated: true,
          isClientUser: true, // Store manager is a client user
        }),
      );
    }, storeManagerUser);

    // Navigate to dashboard - AuthContext will use the localStorage session
    // Use domcontentloaded instead of networkidle for better CI reliability
    await page.goto(
      `${process.env.FRONTEND_URL || "http://localhost:3000"}/dashboard`,
      { waitUntil: "domcontentloaded" },
    );

    // Wait for the page to be ready
    await page.waitForLoadState("load");

    await use(page);

    // Cleanup: Clear session state
    await page.context().clearCookies();
    await page.evaluate(() => {
      localStorage.clear();
      sessionStorage.clear();
    });
  },

  clientOwnerPage: async ({ page, clientUser }, use) => {
    // Setup: Use real authentication with JWT cookie for CLIENT_OWNER user
    // CLIENT_OWNER role is required to access /client-dashboard routes

    // Add authentication cookie (real JWT token)
    await page.context().addCookies([
      {
        name: "access_token",
        value: clientUser.token,
        domain: "localhost",
        path: "/",
      },
    ]);

    // Set localStorage auth_session directly to bypass API call during tests
    // CLIENT_OWNER users need the role to be correctly identified by ClientAuthContext
    await page.addInitScript((userData) => {
      localStorage.setItem(
        "auth_session",
        JSON.stringify({
          user: {
            id: userData.user_id,
            email: userData.email,
            name: userData.name,
            roles: userData.roles,
          },
          authenticated: true,
          isClientUser: true, // CLIENT_OWNER is a client user
        }),
      );
    }, clientUser);

    // Navigate to client dashboard - ClientAuthContext will verify CLIENT_OWNER role
    // Use domcontentloaded instead of networkidle for better CI reliability
    await page.goto(
      `${process.env.FRONTEND_URL || "http://localhost:3000"}/client-dashboard`,
      { waitUntil: "domcontentloaded" },
    );

    // Wait for the page to be ready
    await page.waitForLoadState("load");

    await use(page);

    // Cleanup: Clear session state
    await page.context().clearCookies();
    await page.evaluate(() => {
      localStorage.clear();
      sessionStorage.clear();
    });
  },

  cashierApiRequest: async ({ request, cashierUser, backendUrl }, use) => {
    const cashierApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${cashierUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${cashierUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.post(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        const headers: Record<string, string> = {
          Cookie: `access_token=${cashierUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.put(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${cashierUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        const headers: Record<string, string> = {
          Cookie: `access_token=${cashierUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers,
        });
      },
    };

    await use(cashierApiRequest);
  },

  systemAdminApiRequest: async (
    { request, superadminUser, backendUrl },
    use,
  ) => {
    // systemAdminApiRequest is an alias for superadminApiRequest
    const systemAdminApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        // Only set Content-Type: application/json when there's actual data
        const headers: Record<string, string> = {
          Cookie: `access_token=${superadminUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.post(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        const headers: Record<string, string> = {
          Cookie: `access_token=${superadminUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.put(`${backendUrl}${path}`, {
          data,
          headers,
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        const headers: Record<string, string> = {
          Cookie: `access_token=${superadminUser.token}`,
          ...options?.headers,
        };
        if (data !== undefined) {
          headers["Content-Type"] = "application/json";
        }
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers,
        });
      },
    };

    await use(systemAdminApiRequest);
  },

  anotherStoreManagerUser: async ({ prismaClient }, use) => {
    // Setup: Create another store manager user with a DIFFERENT company and store
    // Useful for cross-store/cross-company isolation tests
    const userData = createUser({});
    const ownerUser = await prismaClient.user.create({
      data: createUser({ name: "Another Store Company Owner" }),
    });
    const companyData = createCompany({ owner_user_id: ownerUser.user_id });

    // Create company
    const company = await prismaClient.company.create({ data: companyData });

    // Create store
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Create user
    const user = await prismaClient.user.create({ data: userData });

    // Get STORE_MANAGER role (must exist in database)
    const role = await prismaClient.role.findUnique({
      where: { code: "STORE_MANAGER" },
    });
    if (!role) {
      throw new Error(
        "STORE_MANAGER role not found in database. Run database seed first.",
      );
    }

    // Assign STORE_MANAGER role to user with store_id (STORE scope)
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
          store_id: store.store_id,
        },
      });
    });

    // Clear RBAC cache
    await clearUserRbacCache(user.user_id);

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["STORE_MANAGER"],
      permissions: [
        "STORE_READ",
        "SHIFT_OPEN",
        "SHIFT_CLOSE",
        "SHIFT_READ",
        "SHIFT_REPORT_VIEW",
        "INVENTORY_READ",
        "TRANSACTION_READ",
        "LOTTERY_PACK_ACTIVATE",
        "LOTTERY_PACK_RECEIVE",
        "LOTTERY_GAME_READ",
        "LOTTERY_PACK_READ",
        "LOTTERY_VARIANCE_READ",
        "LOTTERY_BIN_READ",
        "LOTTERY_BIN_MANAGE",
        "LOTTERY_BIN_CONFIG_READ",
        "LOTTERY_BIN_CONFIG_WRITE",
      ],
      // Phase 2: RLS scope information
      is_system_admin: false,
      company_ids: [company.company_id],
      store_ids: [store.store_id],
    });

    const anotherStoreManagerUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      company_id: company.company_id,
      store_id: store.store_id,
      roles: ["STORE_MANAGER"],
      permissions: [
        "STORE_READ",
        "SHIFT_OPEN",
        "SHIFT_CLOSE",
        "SHIFT_READ",
        "SHIFT_REPORT_VIEW",
        "INVENTORY_READ",
        "TRANSACTION_READ",
        "LOTTERY_PACK_ACTIVATE",
        "LOTTERY_PACK_RECEIVE",
        "LOTTERY_GAME_READ",
        "LOTTERY_PACK_READ",
        "LOTTERY_VARIANCE_READ",
        "LOTTERY_BIN_READ",
        "LOTTERY_BIN_MANAGE",
        "LOTTERY_BIN_CONFIG_READ",
        "LOTTERY_BIN_CONFIG_WRITE",
      ],
      token,
    };

    await use(anotherStoreManagerUser);

    // Cleanup - delete in correct order respecting foreign key constraints
    await withBypassClient(async (bypassClient) => {
      // 1. Find shifts for the user
      const userShifts = await bypassClient.shift.findMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
        select: { shift_id: true },
      });
      const shiftIds = userShifts.map((s) => s.shift_id);

      if (shiftIds.length > 0) {
        await bypassClient.transactionPayment.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        await bypassClient.transactionLineItem.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });
        await bypassClient.transaction.deleteMany({
          where: { shift_id: { in: shiftIds } },
        });
      }

      await bypassClient.shift.deleteMany({
        where: {
          OR: [{ cashier_id: user.user_id }, { opened_by: user.user_id }],
        },
      });

      await bypassClient.userRole.deleteMany({
        where: { user_id: user.user_id },
      });

      await bypassClient.bulkImportJob.deleteMany({
        where: { user_id: user.user_id },
      });

      await bypassClient.pOSTerminal.deleteMany({
        where: { store_id: store.store_id },
      });

      await bypassClient.cashier.deleteMany({
        where: {
          OR: [{ created_by: user.user_id }, { updated_by: user.user_id }],
        },
      });

      await bypassClient.user.delete({ where: { user_id: user.user_id } });

      await bypassClient.store.delete({ where: { store_id: store.store_id } });

      await bypassClient.company.delete({
        where: { company_id: company.company_id },
      });

      await bypassClient.cashier.deleteMany({
        where: {
          OR: [
            { created_by: ownerUser.user_id },
            { updated_by: ownerUser.user_id },
          ],
        },
      });

      await bypassClient.user.delete({ where: { user_id: ownerUser.user_id } });
    });
  },
});

export { expect } from "@playwright/test";

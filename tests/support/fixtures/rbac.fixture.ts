import { config } from "dotenv";
import { test as base, APIRequestContext } from "@playwright/test";
import {
  createUser,
  createCompany,
  createStore,
  createClientUser,
} from "../factories";
import {
  createSuperadminRole,
  createCorporateAdminRole,
  createStoreManagerRole,
} from "../factories";
// Import Prisma client from root node_modules (generated by npm run prisma:generate)
import { PrismaClient } from "@prisma/client";
import { createJWTAccessToken } from "../factories";
import { withBypassClient } from "../prisma-bypass";

// Load environment variables from .env.local for Playwright tests
config({ path: ".env.local" });

/**
 * RBAC Test Fixtures
 *
 * Provides fixtures for RBAC testing:
 * - Authenticated users with specific roles and permissions
 * - API requests with role-based access tokens
 * - Auto-cleanup of test data
 *
 * Follows fixture architecture pattern: pure functions wrapped in fixtures
 */

type ApiRequestHelper = {
  get: (
    path: string,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
  post: (
    path: string,
    data?: unknown,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
  put: (
    path: string,
    data?: unknown,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
  delete: (
    path: string,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
  patch: (
    path: string,
    data?: unknown,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
};

type RBACFixture = {
  backendUrl: string;
  apiRequest: ApiRequestHelper;
  authenticatedApiRequest: ApiRequestHelper;
  superadminApiRequest: {
    get: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    post: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    put: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    delete: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    patch: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
  };
  corporateAdminApiRequest: {
    get: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    post: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    put: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    delete: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    patch: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
  };
  storeManagerApiRequest: {
    get: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    post: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    put: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    delete: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    patch: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
  };
  superadminUser: {
    user_id: string;
    email: string;
    name: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  corporateAdminUser: {
    user_id: string;
    email: string;
    name: string;
    company_id: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  storeManagerUser: {
    user_id: string;
    email: string;
    name: string;
    company_id: string;
    store_id: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  clientUser: {
    user_id: string;
    email: string;
    name: string;
    company_id: string;
    store_id: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  regularUser: {
    user_id: string;
    email: string;
    name: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  clientUserApiRequest: ApiRequestHelper;
  regularUserApiRequest: ApiRequestHelper;
  prismaClient: PrismaClient;
  rlsPrismaClient: PrismaClient;
  superadminPage: import("@playwright/test").Page;
};

export const test = base.extend<RBACFixture>({
  backendUrl: async ({}, use) => {
    const url = process.env.BACKEND_URL || "http://localhost:3001";
    await use(url);
  },

  apiRequest: async ({ request, backendUrl }, use) => {
    // Setup: Create unauthenticated API request helper
    const apiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: options?.headers,
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: options?.headers,
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            ...options?.headers,
          },
        });
      },
    };

    await use(apiRequest);
  },

  // Alias for superadminApiRequest for backward compatibility
  authenticatedApiRequest: async (
    { request, superadminUser, backendUrl },
    use,
  ) => {
    const authenticatedApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
    };

    await use(authenticatedApiRequest);
  },

  prismaClient: async ({}, use: (prisma: PrismaClient) => Promise<void>) => {
    const prisma = new PrismaClient();
    await prisma.$connect();
    await use(prisma);
    await prisma.$disconnect();
  },

  rlsPrismaClient: async ({}, use: (prisma: PrismaClient) => Promise<void>) => {
    // Create a Prisma client that connects as app_user (non-superuser)
    // This client respects RLS policies unlike the postgres superuser

    // Replace postgres user with app_user in DATABASE_URL
    // Handles both formats:
    // - postgres:postgres@... (local with password)
    // - postgres@... (CI without password)
    const dbUrl =
      process.env.DATABASE_URL ||
      "postgresql://postgres@localhost:5432/nuvana_dev";
    const appUserUrl = dbUrl
      .replace("postgres:postgres@", "app_user:app_user_password@")
      .replace(
        /^postgresql:\/\/postgres@/,
        "postgresql://app_user:app_user_password@",
      );

    const rlsPrisma = new PrismaClient({
      datasources: {
        db: {
          url: appUserUrl,
        },
      },
    });
    await rlsPrisma.$connect();
    await use(rlsPrisma);
    await rlsPrisma.$disconnect();
  },

  superadminUser: async ({ prismaClient }, use) => {
    // Setup: Create superadmin user with SUPERADMIN role
    const userData = createUser();
    const user = await prismaClient.user.create({ data: userData });

    // Get SUPERADMIN role (must exist in database)
    const role = await prismaClient.role.findUnique({
      where: { code: "SUPERADMIN" },
    });
    if (!role) {
      throw new Error(
        "SUPERADMIN role not found in database. Run database seed first.",
      );
    }

    // Assign SUPERADMIN role to user
    // Use bypass client to avoid RLS restrictions during test setup
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
        },
      });
    });

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["SUPERADMIN"],
      permissions: ["*"], // Superadmin has all permissions
    });

    const superadminUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      roles: ["SUPERADMIN"],
      permissions: ["*"],
      token,
    };

    await use(superadminUser);

    // Cleanup: Delete user and roles
    await prismaClient.userRole.deleteMany({
      where: { user_id: user.user_id },
    });
    await prismaClient.user.delete({ where: { user_id: user.user_id } });
  },

  corporateAdminUser: async ({ prismaClient }, use) => {
    // Setup: Create corporate admin user with COMPANY scope role
    const userData = createUser({});
    const ownerUser = await prismaClient.user.create({
      data: createUser({ name: "Company Owner" }),
    });
    const companyData = createCompany({ owner_user_id: ownerUser.user_id });

    // Create company
    const company = await prismaClient.company.create({ data: companyData });

    // Create user
    const user = await prismaClient.user.create({ data: userData });

    // Get CORPORATE_ADMIN role (must exist in database)
    const role = await prismaClient.role.findUnique({
      where: { code: "CORPORATE_ADMIN" },
    });
    if (!role) {
      throw new Error(
        "CORPORATE_ADMIN role not found in database. Run database seed first.",
      );
    }

    // Assign CORPORATE_ADMIN role to user with company_id (COMPANY scope)
    // Use bypass client to avoid RLS restrictions during test setup
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
        },
      });
    });

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["CORPORATE_ADMIN"],
      permissions: [
        "USER_READ",
        "STORE_CREATE",
        "STORE_READ",
        "STORE_UPDATE",
        "STORE_DELETE",
      ],
    });

    const corporateAdminUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      company_id: company.company_id,
      roles: ["CORPORATE_ADMIN"],
      permissions: [
        "USER_READ",
        "STORE_CREATE",
        "STORE_READ",
        "STORE_UPDATE",
        "STORE_DELETE",
      ],
      token,
    };

    await use(corporateAdminUser);

    // Cleanup - Use bypass client to avoid RLS restrictions during test cleanup
    // Delete in correct order to respect foreign key constraints
    await withBypassClient(async (bypassClient) => {
      // 1. Delete transaction-related data FIRST (children of transactions)
      // Get all shifts for this user to find related transactions
      const userShifts = await bypassClient.shift.findMany({
        where: { cashier_id: user.user_id },
        select: { shift_id: true },
      });
      const shiftIds = userShifts.map((s) => s.shift_id);

      if (shiftIds.length > 0) {
        // Delete transaction payments (child of transaction)
        await bypassClient.transactionPayment.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });

        // Delete transaction line items (child of transaction)
        await bypassClient.transactionLineItem.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });

        // Delete transactions (child of shift)
        await bypassClient.transaction.deleteMany({
          where: { shift_id: { in: shiftIds } },
        });
      }

      // 2. NOW delete shifts (after transactions are gone)
      await bypassClient.shift.deleteMany({
        where: { cashier_id: user.user_id },
      });

      // 2. Get all stores for this company to delete their user roles
      const stores = await bypassClient.store.findMany({
        where: { company_id: company.company_id },
        select: { store_id: true },
      });
      const storeIds = stores.map((s) => s.store_id);

      // 3. Delete ALL user roles related to this company (must be before user, store, and company due to onDelete: Restrict)
      // This includes roles for the user, company, and any stores under the company
      await bypassClient.userRole.deleteMany({
        where: {
          OR: [
            { user_id: user.user_id },
            { company_id: company.company_id },
            ...(storeIds.length > 0 ? [{ store_id: { in: storeIds } }] : []),
          ],
        },
      });

      // 4. Delete user
      await bypassClient.user.delete({ where: { user_id: user.user_id } });

      // 5. Delete stores under company (required due to onDelete: Restrict)
      await bypassClient.store.deleteMany({
        where: { company_id: company.company_id },
      });
      // 5. Delete company last
      await bypassClient.company.delete({
        where: { company_id: company.company_id },
      });
    });
  },

  storeManagerUser: async ({ prismaClient }, use) => {
    // Setup: Create store manager user with STORE scope role
    const userData = createUser({});
    const ownerUser = await prismaClient.user.create({
      data: createUser({ name: "Store Company Owner" }),
    });
    const companyData = createCompany({ owner_user_id: ownerUser.user_id });

    // Create company
    const company = await prismaClient.company.create({ data: companyData });

    // Create store
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Create user
    const user = await prismaClient.user.create({ data: userData });

    // Get STORE_MANAGER role (must exist in database)
    const role = await prismaClient.role.findUnique({
      where: { code: "STORE_MANAGER" },
    });
    if (!role) {
      throw new Error(
        "STORE_MANAGER role not found in database. Run database seed first.",
      );
    }

    // Assign STORE_MANAGER role to user with store_id (STORE scope)
    // Use bypass client to avoid RLS restrictions during test setup
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
          store_id: store.store_id,
        },
      });
    });

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["STORE_MANAGER"],
      permissions: [
        "STORE_READ",
        "SHIFT_OPEN",
        "SHIFT_CLOSE",
        "INVENTORY_READ",
      ],
    });

    const storeManagerUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      company_id: company.company_id,
      store_id: store.store_id,
      roles: ["STORE_MANAGER"],
      permissions: [
        "STORE_READ",
        "SHIFT_OPEN",
        "SHIFT_CLOSE",
        "INVENTORY_READ",
      ],
      token,
    };

    await use(storeManagerUser);

    // Cleanup
    await prismaClient.userRole.deleteMany({
      where: { user_id: user.user_id },
    });
    await prismaClient.user.delete({ where: { user_id: user.user_id } });
    await prismaClient.store.delete({ where: { store_id: store.store_id } });
    await prismaClient.company.delete({
      where: { company_id: company.company_id },
    });
  },

  superadminApiRequest: async (
    { request, superadminUser, backendUrl },
    use,
  ) => {
    const superadminApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
    };

    await use(superadminApiRequest);
  },

  corporateAdminApiRequest: async (
    { request, corporateAdminUser, backendUrl },
    use,
  ) => {
    const corporateAdminApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${corporateAdminUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${corporateAdminUser.token}`,
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${corporateAdminUser.token}`,
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${corporateAdminUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${corporateAdminUser.token}`,
            ...options?.headers,
          },
        });
      },
    };

    await use(corporateAdminApiRequest);
  },

  storeManagerApiRequest: async (
    { request, storeManagerUser, backendUrl },
    use,
  ) => {
    const storeManagerApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${storeManagerUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${storeManagerUser.token}`,
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${storeManagerUser.token}`,
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${storeManagerUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${storeManagerUser.token}`,
            ...options?.headers,
          },
        });
      },
    };

    await use(storeManagerApiRequest);
  },

  clientUser: async ({ prismaClient }, use) => {
    // Setup: Create client user with CLIENT_USER role and own company/store
    const userData = createClientUser();

    // Create user first (will be company owner)
    const user = await prismaClient.user.create({ data: userData });

    // Create company owned by this client user
    const companyData = createCompany({ owner_user_id: user.user_id });
    const company = await prismaClient.company.create({ data: companyData });

    // Create store for the company
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Get CLIENT_USER role (must exist in database)
    const role = await prismaClient.role.findUnique({
      where: { code: "CLIENT_USER" },
    });
    if (!role) {
      throw new Error(
        "CLIENT_USER role not found in database. Run database seed first.",
      );
    }

    // Assign CLIENT_USER role to user
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
        },
      });
    });

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["CLIENT_USER"],
      permissions: ["*"], // Wildcard bypasses DB permission check, relies on service-layer auth
    });

    const clientUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      company_id: company.company_id,
      store_id: store.store_id,
      roles: ["CLIENT_USER"],
      permissions: ["*"], // Wildcard for test fixture - service layer handles real authorization
      token,
    };

    await use(clientUser);

    // Cleanup
    await withBypassClient(async (bypassClient) => {
      // Delete user roles
      await bypassClient.userRole.deleteMany({
        where: { user_id: user.user_id },
      });
      // Delete store
      await bypassClient.store.delete({ where: { store_id: store.store_id } });
      // Delete company
      await bypassClient.company.delete({
        where: { company_id: company.company_id },
      });
      // Delete user
      await bypassClient.user.delete({ where: { user_id: user.user_id } });
    });
  },

  regularUser: async ({ prismaClient }, use) => {
    // Setup: Create regular user without CLIENT_EMPLOYEE permissions
    const userData = createUser({});
    const user = await prismaClient.user.create({ data: userData });

    // Get a basic role without CLIENT_EMPLOYEE permissions (CASHIER - STORE scope)
    const role = await prismaClient.role.findUnique({
      where: { code: "CASHIER" },
    });
    if (!role) {
      throw new Error(
        "CASHIER role not found in database. Run database seed first.",
      );
    }

    // Create a company and store for context (user needs some context)
    const ownerUser = await prismaClient.user.create({
      data: createUser({ name: "Regular User Company Owner" }),
    });
    const company = await prismaClient.company.create({
      data: createCompany({ owner_user_id: ownerUser.user_id }),
    });
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Assign STORE_EMPLOYEE role
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
          store_id: store.store_id,
        },
      });
    });

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["CASHIER"],
      permissions: ["SHIFT_READ", "INVENTORY_READ"], // Basic permissions, no CLIENT_EMPLOYEE_*
    });

    const regularUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      roles: ["CASHIER"],
      permissions: ["SHIFT_READ", "INVENTORY_READ"],
      token,
    };

    await use(regularUser);

    // Cleanup
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.deleteMany({
        where: { user_id: user.user_id },
      });
      await bypassClient.user.delete({ where: { user_id: user.user_id } });
      await bypassClient.store.delete({ where: { store_id: store.store_id } });
      await bypassClient.company.delete({
        where: { company_id: company.company_id },
      });
      await bypassClient.user.delete({ where: { user_id: ownerUser.user_id } });
    });
  },

  clientUserApiRequest: async ({ request, clientUser, backendUrl }, use) => {
    const clientUserApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${clientUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${clientUser.token}`,
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${clientUser.token}`,
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${clientUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${clientUser.token}`,
            ...options?.headers,
          },
        });
      },
    };

    await use(clientUserApiRequest);
  },

  regularUserApiRequest: async ({ request, regularUser, backendUrl }, use) => {
    const regularUserApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${regularUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${regularUser.token}`,
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${regularUser.token}`,
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${regularUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${regularUser.token}`,
            ...options?.headers,
          },
        });
      },
    };

    await use(regularUserApiRequest);
  },

  superadminPage: async ({ page, superadminUser }, use) => {
    // Login as superadmin
    await page.goto(
      `${process.env.FRONTEND_URL || "http://localhost:3000"}/login`,
    );
    await page.context().addCookies([
      {
        name: "access_token",
        value: superadminUser.token,
        domain: "localhost",
        path: "/",
        url: process.env.FRONTEND_URL || "http://localhost:3000",
      },
    ]);
    await page.goto(
      `${process.env.FRONTEND_URL || "http://localhost:3000"}/dashboard`,
    );
    await use(page);
  },
});

export { expect } from "@playwright/test";

import { config } from "dotenv";
import { test as base, APIRequestContext } from "@playwright/test";
import {
  createUser,
  createCompany,
  createStore,
  createClientUser,
} from "../factories";
import {
  createSuperadminRole,
  createCorporateAdminRole,
  createStoreManagerRole,
} from "../factories";
// Import Prisma client from root node_modules (generated by npm run prisma:generate)
import { PrismaClient } from "@prisma/client";
import { createJWTAccessToken } from "../factories";
import { withBypassClient } from "../prisma-bypass";

// Load environment variables from .env.local for Playwright tests
config({ path: ".env.local" });

/**
 * RBAC Test Fixtures
 *
 * Provides fixtures for RBAC testing:
 * - Authenticated users with specific roles and permissions
 * - API requests with role-based access tokens
 * - Auto-cleanup of test data
 *
 * Follows fixture architecture pattern: pure functions wrapped in fixtures
 */

type ApiRequestHelper = {
  get: (
    path: string,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
  post: (
    path: string,
    data?: unknown,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
  put: (
    path: string,
    data?: unknown,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
  delete: (
    path: string,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
  patch: (
    path: string,
    data?: unknown,
    options?: { headers?: Record<string, string> },
  ) => Promise<import("@playwright/test").APIResponse>;
};

type RBACFixture = {
  backendUrl: string;
  apiRequest: ApiRequestHelper;
  authenticatedApiRequest: ApiRequestHelper;
  superadminApiRequest: {
    get: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    post: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    put: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    delete: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    patch: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
  };
  corporateAdminApiRequest: {
    get: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    post: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    put: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    delete: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    patch: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
  };
  storeManagerApiRequest: {
    get: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    post: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    put: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    delete: (
      path: string,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
    patch: (
      path: string,
      data?: unknown,
      options?: { headers?: Record<string, string> },
    ) => Promise<import("@playwright/test").APIResponse>;
  };
  superadminUser: {
    user_id: string;
    email: string;
    name: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  corporateAdminUser: {
    user_id: string;
    email: string;
    name: string;
    company_id: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  storeManagerUser: {
    user_id: string;
    email: string;
    name: string;
    company_id: string;
    store_id: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  clientUser: {
    user_id: string;
    email: string;
    name: string;
    company_id: string;
    store_id: string;
    roles: string[];
    permissions: string[];
    token: string;
  };
  regularUser: {
    user_id: string;
    email: string;
    name: string;
    roles: string[];
    permissions: string[];
    token: string;
    _roleId?: string; // Optional property for cleanup purposes
  };
  clientUserApiRequest: ApiRequestHelper;
  regularUserApiRequest: ApiRequestHelper;
  prismaClient: PrismaClient;
  rlsPrismaClient: PrismaClient;
  superadminPage: import("@playwright/test").Page;
  storeManagerPage: import("@playwright/test").Page;
};

export const test = base.extend<RBACFixture>({
  backendUrl: async ({}, use) => {
    const url = process.env.BACKEND_URL || "http://localhost:3001";
    await use(url);
  },

  apiRequest: async ({ request, backendUrl }, use) => {
    // Setup: Create unauthenticated API request helper
    const apiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: options?.headers,
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: options?.headers,
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            ...options?.headers,
          },
        });
      },
    };

    await use(apiRequest);
  },

  // Alias for superadminApiRequest for backward compatibility
  authenticatedApiRequest: async (
    { request, superadminUser, backendUrl },
    use,
  ) => {
    const authenticatedApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
    };

    await use(authenticatedApiRequest);
  },

  prismaClient: async ({}, use: (prisma: PrismaClient) => Promise<void>) => {
    const prisma = new PrismaClient();
    await prisma.$connect();
    await use(prisma);
    await prisma.$disconnect();
  },

  rlsPrismaClient: async ({}, use: (prisma: PrismaClient) => Promise<void>) => {
    // Create a Prisma client that connects as app_user (non-superuser)
    // This client respects RLS policies unlike the postgres superuser

    // Replace postgres user with app_user in DATABASE_URL
    // Handles both formats:
    // - postgres:postgres@... (local with password)
    // - postgres@... (CI without password)
    const dbUrl =
      process.env.DATABASE_URL ||
      "postgresql://postgres@localhost:5432/nuvana_dev";
    const appUserUrl = dbUrl
      .replace("postgres:postgres@", "app_user:app_user_password@")
      .replace(
        /^postgresql:\/\/postgres@/,
        "postgresql://app_user:app_user_password@",
      );

    const rlsPrisma = new PrismaClient({
      datasources: {
        db: {
          url: appUserUrl,
        },
      },
    });
    await rlsPrisma.$connect();
    await use(rlsPrisma);
    await rlsPrisma.$disconnect();
  },

  superadminUser: async ({ prismaClient }, use) => {
    // Setup: Create superadmin user with SUPERADMIN role
    const userData = createUser();
    const user = await prismaClient.user.create({ data: userData });

    // Get SUPERADMIN role (must exist in database)
    const role = await prismaClient.role.findUnique({
      where: { code: "SUPERADMIN" },
    });
    if (!role) {
      throw new Error(
        "SUPERADMIN role not found in database. Run database seed first.",
      );
    }

    // Assign SUPERADMIN role to user
    // Use bypass client to avoid RLS restrictions during test setup
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
        },
      });
    });

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["SUPERADMIN"],
      permissions: ["*"], // Superadmin has all permissions
    });

    const superadminUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      roles: ["SUPERADMIN"],
      permissions: ["*"],
      token,
    };

    await use(superadminUser);

    // Cleanup: Delete user and roles
    await prismaClient.userRole.deleteMany({
      where: { user_id: user.user_id },
    });
    await prismaClient.user.delete({ where: { user_id: user.user_id } });
  },

  corporateAdminUser: async ({ prismaClient }, use) => {
    // Setup: Create corporate admin user with COMPANY scope role
    const userData = createUser({});
    const ownerUser = await prismaClient.user.create({
      data: createUser({ name: "Company Owner" }),
    });
    const companyData = createCompany({ owner_user_id: ownerUser.user_id });

    // Create company
    const company = await prismaClient.company.create({ data: companyData });

    // Create user
    const user = await prismaClient.user.create({ data: userData });

    // Get CORPORATE_ADMIN role (must exist in database)
    const role = await prismaClient.role.findUnique({
      where: { code: "CORPORATE_ADMIN" },
    });
    if (!role) {
      throw new Error(
        "CORPORATE_ADMIN role not found in database. Run database seed first.",
      );
    }

    // Assign CORPORATE_ADMIN role to user with company_id (COMPANY scope)
    // Use bypass client to avoid RLS restrictions during test setup
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
        },
      });
    });

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["CORPORATE_ADMIN"],
      permissions: [
        "USER_READ",
        "STORE_CREATE",
        "STORE_READ",
        "STORE_UPDATE",
        "STORE_DELETE",
        "SHIFT_READ",
        "TRANSACTION_CREATE",
        "TRANSACTION_READ",
      ],
    });

    const corporateAdminUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      company_id: company.company_id,
      roles: ["CORPORATE_ADMIN"],
      permissions: [
        "USER_READ",
        "STORE_CREATE",
        "STORE_READ",
        "STORE_UPDATE",
        "STORE_DELETE",
        "SHIFT_READ",
        "TRANSACTION_CREATE",
        "TRANSACTION_READ",
      ],
      token,
    };

    await use(corporateAdminUser);

    // Cleanup - Use bypass client to avoid RLS restrictions during test cleanup
    // Delete in correct order to respect foreign key constraints
    await withBypassClient(async (bypassClient) => {
      // 1. Delete transaction-related data FIRST (children of transactions)
      // Get all shifts for this user to find related transactions
      const userShifts = await bypassClient.shift.findMany({
        where: { cashier_id: user.user_id },
        select: { shift_id: true },
      });
      const shiftIds = userShifts.map((s) => s.shift_id);

      if (shiftIds.length > 0) {
        // Delete transaction payments (child of transaction)
        await bypassClient.transactionPayment.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });

        // Delete transaction line items (child of transaction)
        await bypassClient.transactionLineItem.deleteMany({
          where: { transaction: { shift_id: { in: shiftIds } } },
        });

        // Delete transactions (child of shift)
        await bypassClient.transaction.deleteMany({
          where: { shift_id: { in: shiftIds } },
        });
      }

      // 2. NOW delete shifts (after transactions are gone)
      await bypassClient.shift.deleteMany({
        where: { cashier_id: user.user_id },
      });

      // 2. Get all stores for this company to delete their user roles
      const stores = await bypassClient.store.findMany({
        where: { company_id: company.company_id },
        select: { store_id: true },
      });
      const storeIds = stores.map((s) => s.store_id);

      // 3. Delete ALL user roles related to this company (must be before user, store, and company due to onDelete: Restrict)
      // This includes roles for the user, company, and any stores under the company
      await bypassClient.userRole.deleteMany({
        where: {
          OR: [
            { user_id: user.user_id },
            { company_id: company.company_id },
            ...(storeIds.length > 0 ? [{ store_id: { in: storeIds } }] : []),
          ],
        },
      });

      // 4. Delete user
      await bypassClient.user.delete({ where: { user_id: user.user_id } });

      // 5. Delete stores under company (required due to onDelete: Restrict)
      await bypassClient.store.deleteMany({
        where: { company_id: company.company_id },
      });
      // 5. Delete company last
      await bypassClient.company.delete({
        where: { company_id: company.company_id },
      });
    });
  },

  storeManagerUser: async ({ prismaClient }, use) => {
    // Setup: Create store manager user with STORE scope role
    const userData = createUser({});
    const ownerUser = await prismaClient.user.create({
      data: createUser({ name: "Store Company Owner" }),
    });
    const companyData = createCompany({ owner_user_id: ownerUser.user_id });

    // Create company
    const company = await prismaClient.company.create({ data: companyData });

    // Create store
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Create user
    const user = await prismaClient.user.create({ data: userData });

    // Get STORE_MANAGER role (must exist in database)
    const role = await prismaClient.role.findUnique({
      where: { code: "STORE_MANAGER" },
    });
    if (!role) {
      throw new Error(
        "STORE_MANAGER role not found in database. Run database seed first.",
      );
    }

    // Assign STORE_MANAGER role to user with store_id (STORE scope)
    // Use bypass client to avoid RLS restrictions during test setup
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
          store_id: store.store_id,
        },
      });
    });

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["STORE_MANAGER"],
      permissions: [
        "STORE_READ",
        "SHIFT_OPEN",
        "SHIFT_CLOSE",
        "SHIFT_READ",
        "INVENTORY_READ",
        "TRANSACTION_READ",
      ],
    });

    const storeManagerUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      company_id: company.company_id,
      store_id: store.store_id,
      roles: ["STORE_MANAGER"],
      permissions: [
        "STORE_READ",
        "SHIFT_OPEN",
        "SHIFT_CLOSE",
        "SHIFT_READ",
        "INVENTORY_READ",
        "TRANSACTION_READ",
      ],
      token,
    };

    await use(storeManagerUser);

    // Cleanup - delete in correct order respecting foreign key constraints
    // 1. Delete shifts for the user (shifts reference user via cashier_id)
    await prismaClient.shift.deleteMany({
      where: { cashier_id: user.user_id },
    });
    // 2. Delete user roles for the user
    await prismaClient.userRole.deleteMany({
      where: { user_id: user.user_id },
    });
    // 3. Delete the store manager user
    await prismaClient.user.delete({ where: { user_id: user.user_id } });
    // 4. Delete store
    await prismaClient.store.delete({ where: { store_id: store.store_id } });
    // 5. Delete company
    await prismaClient.company.delete({
      where: { company_id: company.company_id },
    });
    // 6. Delete the owner user (created for company ownership)
    await prismaClient.user.delete({ where: { user_id: ownerUser.user_id } });
  },

  superadminApiRequest: async (
    { request, superadminUser, backendUrl },
    use,
  ) => {
    const superadminApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${superadminUser.token}`,
            ...options?.headers,
          },
        });
      },
    };

    await use(superadminApiRequest);
  },

  corporateAdminApiRequest: async (
    { request, corporateAdminUser, backendUrl },
    use,
  ) => {
    const corporateAdminApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${corporateAdminUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${corporateAdminUser.token}`,
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${corporateAdminUser.token}`,
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${corporateAdminUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${corporateAdminUser.token}`,
            ...options?.headers,
          },
        });
      },
    };

    await use(corporateAdminApiRequest);
  },

  storeManagerApiRequest: async (
    { request, storeManagerUser, backendUrl },
    use,
  ) => {
    const storeManagerApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${storeManagerUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${storeManagerUser.token}`,
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${storeManagerUser.token}`,
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${storeManagerUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${storeManagerUser.token}`,
            ...options?.headers,
          },
        });
      },
    };

    await use(storeManagerApiRequest);
  },

  clientUser: async ({ prismaClient }, use) => {
    // Setup: Create client user with CLIENT_OWNER role and own company/store
    // CLIENT_OWNER has full permissions including CLIENT_ROLE_MANAGE
    const userData = createClientUser();

    // Create user first (will be company owner)
    const user = await prismaClient.user.create({ data: userData });

    // Create company owned by this client user
    const companyData = createCompany({ owner_user_id: user.user_id });
    const company = await prismaClient.company.create({ data: companyData });

    // Create store for the company
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Get CLIENT_OWNER role (must exist in database)
    // CLIENT_OWNER has CLIENT_ROLE_MANAGE permission, CLIENT_USER does not
    const role = await prismaClient.role.findUnique({
      where: { code: "CLIENT_OWNER" },
    });
    if (!role) {
      throw new Error(
        "CLIENT_OWNER role not found in database. Run database seed first.",
      );
    }

    // Assign CLIENT_OWNER role to user
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: role.role_id,
          company_id: company.company_id,
        },
      });
    });

    // Assign default STORE scope roles to the company via CompanyAllowedRole
    // This is required for client role permission management (Story 2.92)
    const storeRoles = await prismaClient.role.findMany({
      where: { scope: "STORE", deleted_at: null },
    });
    await withBypassClient(async (bypassClient) => {
      await bypassClient.companyAllowedRole.createMany({
        data: storeRoles.map((storeRole) => ({
          company_id: company.company_id,
          role_id: storeRole.role_id,
          assigned_by: user.user_id,
        })),
        skipDuplicates: true,
      });
    });

    // Client Owner permissions - explicit list following least privilege principle
    // Does NOT include ADMIN_SYSTEM_CONFIG which is Super Admin only
    const clientPermissions = [
      "CLIENT_DASHBOARD_ACCESS",
      "CLIENT_EMPLOYEE_CREATE",
      "CLIENT_EMPLOYEE_READ",
      "CLIENT_EMPLOYEE_DELETE",
      "CLIENT_ROLE_MANAGE",
      "STORE_READ",
      "STORE_UPDATE",
    ];

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: ["CLIENT_OWNER"],
      permissions: clientPermissions,
    });

    const clientUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      company_id: company.company_id,
      store_id: store.store_id,
      roles: ["CLIENT_OWNER"],
      permissions: clientPermissions,
      token,
    };

    await use(clientUser);

    // Cleanup
    await withBypassClient(async (bypassClient) => {
      // Delete user roles
      await bypassClient.userRole.deleteMany({
        where: { user_id: user.user_id },
      });
      // Delete company allowed roles
      await bypassClient.companyAllowedRole.deleteMany({
        where: { company_id: company.company_id },
      });
      // Delete client role permissions (if any were created during tests)
      await bypassClient.clientRolePermission.deleteMany({
        where: { owner_user_id: user.user_id },
      });
      // Delete store
      await bypassClient.store.delete({ where: { store_id: store.store_id } });
      // Delete company
      await bypassClient.company.delete({
        where: { company_id: company.company_id },
      });
      // Delete user
      await bypassClient.user.delete({ where: { user_id: user.user_id } });
    });
  },

  regularUser: async ({ prismaClient }, use) => {
    // Setup: Create regular user WITHOUT CLIENT_EMPLOYEE permissions
    // Important: We create a custom role because system roles like CASHIER have CLIENT_EMPLOYEE_READ
    const userData = createUser({});
    const user = await prismaClient.user.create({ data: userData });

    // Create a company and store for context (user needs some context)
    const ownerUser = await prismaClient.user.create({
      data: createUser({ name: "Regular User Company Owner" }),
    });
    const company = await prismaClient.company.create({
      data: createCompany({ owner_user_id: ownerUser.user_id }),
    });
    const storeData = createStore({ company_id: company.company_id });
    const store = await prismaClient.store.create({
      data: {
        ...storeData,
        location_json: storeData.location_json as any,
      },
    });

    // Create a custom role with ONLY basic permissions (no CLIENT_EMPLOYEE_*)
    // This ensures the permission check via DB also fails
    const restrictedRole = await prismaClient.role.create({
      data: {
        code: `RESTRICTED_USER_${Date.now()}`,
        scope: "STORE",
        description:
          "Test role with restricted permissions for authorization tests",
        is_system_role: false,
      },
    });

    // Get permission IDs for the limited permissions we want to assign
    const shiftReadPermission = await prismaClient.permission.findUnique({
      where: { code: "SHIFT_READ" },
    });
    const inventoryReadPermission = await prismaClient.permission.findUnique({
      where: { code: "INVENTORY_READ" },
    });

    // Assign only basic permissions to the role (NOT CLIENT_EMPLOYEE_*)
    if (shiftReadPermission) {
      await prismaClient.rolePermission.create({
        data: {
          role_id: restrictedRole.role_id,
          permission_id: shiftReadPermission.permission_id,
        },
      });
    }
    if (inventoryReadPermission) {
      await prismaClient.rolePermission.create({
        data: {
          role_id: restrictedRole.role_id,
          permission_id: inventoryReadPermission.permission_id,
        },
      });
    }

    // Assign restricted role to user
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.create({
        data: {
          user_id: user.user_id,
          role_id: restrictedRole.role_id,
          company_id: company.company_id,
          store_id: store.store_id,
        },
      });
    });

    const token = createJWTAccessToken({
      user_id: user.user_id,
      email: user.email,
      roles: [restrictedRole.code],
      permissions: ["SHIFT_READ", "INVENTORY_READ"], // Must match DB role permissions
    });

    const regularUser = {
      user_id: user.user_id,
      email: user.email,
      name: user.name,
      roles: [restrictedRole.code],
      permissions: ["SHIFT_READ", "INVENTORY_READ"],
      token,
      _roleId: restrictedRole.role_id, // Store for cleanup
    };

    await use(regularUser);

    // Cleanup
    await withBypassClient(async (bypassClient) => {
      await bypassClient.userRole.deleteMany({
        where: { user_id: user.user_id },
      });
      await bypassClient.rolePermission.deleteMany({
        where: { role_id: restrictedRole.role_id },
      });
      await bypassClient.role.delete({
        where: { role_id: restrictedRole.role_id },
      });
      await bypassClient.user.delete({ where: { user_id: user.user_id } });
      await bypassClient.store.delete({ where: { store_id: store.store_id } });
      await bypassClient.company.delete({
        where: { company_id: company.company_id },
      });
      await bypassClient.user.delete({ where: { user_id: ownerUser.user_id } });
    });
  },

  clientUserApiRequest: async ({ request, clientUser, backendUrl }, use) => {
    const clientUserApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${clientUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${clientUser.token}`,
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${clientUser.token}`,
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${clientUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${clientUser.token}`,
            ...options?.headers,
          },
        });
      },
    };

    await use(clientUserApiRequest);
  },

  regularUserApiRequest: async ({ request, regularUser, backendUrl }, use) => {
    const regularUserApiRequest = {
      get: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.get(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${regularUser.token}`,
            ...options?.headers,
          },
        });
      },
      post: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.post(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${regularUser.token}`,
            ...options?.headers,
          },
        });
      },
      put: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.put(`${backendUrl}${path}`, {
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${regularUser.token}`,
            ...options?.headers,
          },
        });
      },
      delete: async (
        path: string,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.delete(`${backendUrl}${path}`, {
          headers: {
            Cookie: `access_token=${regularUser.token}`,
            ...options?.headers,
          },
        });
      },
      patch: async (
        path: string,
        data?: unknown,
        options?: { headers?: Record<string, string> },
      ) => {
        return request.fetch(`${backendUrl}${path}`, {
          method: "PATCH",
          data,
          headers: {
            "Content-Type": "application/json",
            Cookie: `access_token=${regularUser.token}`,
            ...options?.headers,
          },
        });
      },
    };

    await use(regularUserApiRequest);
  },

  superadminPage: async ({ page, superadminUser }, use) => {
    // Login as superadmin
    await page.goto(
      `${process.env.FRONTEND_URL || "http://localhost:3000"}/login`,
    );
    await page.context().addCookies([
      {
        name: "access_token",
        value: superadminUser.token,
        domain: "localhost",
        path: "/",
      },
    ]);
    await page.goto(
      `${process.env.FRONTEND_URL || "http://localhost:3000"}/dashboard`,
    );
    await use(page);
  },

  storeManagerPage: async ({ page, storeManagerUser }, use) => {
    // Setup: Set localStorage auth session (Header component reads from localStorage)
    await page.addInitScript(
      (userData: any) => {
        localStorage.setItem(
          "auth_session",
          JSON.stringify({
            id: userData.user_id,
            email: userData.email,
            name: userData.name,
            user_metadata: {
              email: userData.email,
              full_name: userData.name,
            },
          }),
        );
      },
      {
        user_id: storeManagerUser.user_id,
        email: storeManagerUser.email,
        name: storeManagerUser.name,
      },
    );

    // Intercept auth check endpoint
    await page.route("**/api/auth/me*", async (route) => {
      await route.fulfill({
        status: 200,
        contentType: "application/json",
        body: JSON.stringify({
          user: {
            id: storeManagerUser.user_id,
            email: storeManagerUser.email,
            name: storeManagerUser.name,
            roles: storeManagerUser.roles,
            permissions: storeManagerUser.permissions,
          },
        }),
      });
    });

    // Add authentication cookie
    await page.context().addCookies([
      {
        name: "access_token",
        value: storeManagerUser.token,
        domain: "localhost",
        path: "/",
      },
    ]);

    // Navigate to dashboard
    await page.goto(
      `${process.env.FRONTEND_URL || "http://localhost:3000"}/dashboard`,
    );

    await use(page);

    // Cleanup: Clear session state
    await page.context().clearCookies();
    await page.evaluate(() => {
      localStorage.clear();
      sessionStorage.clear();
    });
  },
});

export { expect } from "@playwright/test";

import { test, expect } from "../support/fixtures/rbac.fixture";
import { PrismaClient } from "@prisma/client";
import {
  createUser,
  createCompany,
  createStore,
} from "../support/factories/database.factory";

/**
 * Row-Level Security (RLS) Policies API Tests
 *
 * Tests for PostgreSQL RLS policies enforcing multi-tenant data isolation:
 * - Company-level isolation (users only see their assigned company data)
 * - Store-level isolation (users only see their assigned store data)
 * - System Admin bypass (can access all data)
 * - Corporate Admin access (can access all stores in their company)
 * - Store Manager access (can only access assigned store)
 * - Silent filtering (no errors, empty results for unauthorized access)
 * - Prisma ORM integration with RLS
 * - Direct SQL query RLS enforcement
 * - INSERT/UPDATE/DELETE policy enforcement
 *
 * Priority: P0 (Critical - Security feature)
 *
 * Quality Standards Applied:
 * - Deterministic: No hard waits, explicit assertions
 * - Isolated: Auto-cleanup via fixtures, unique test data
 * - Explicit: All assertions visible in test bodies
 * - Focused: Each test validates one concern (<300 lines)
 * - Fast: API-based setup, parallel-safe data
 */

/**
 * Helper: Set RLS context for a user
 * Pure function pattern - reusable across tests
 */
async function setRLSContext(
  prisma: PrismaClient,
  userId: string,
): Promise<void> {
  await prisma.$executeRawUnsafe(`SET LOCAL app.current_user_id = '${userId}'`);
}

/**
 * Helper: Create test companies with auto-cleanup tracking
 * Returns created company IDs for cleanup
 */
async function createTestCompanies(
  prisma: PrismaClient,
  count: number = 2,
): Promise<Array<{ company_id: string; name: string }>> {
  const companies = [];
  for (let i = 0; i < count; i++) {
    const company = await prisma.company.create({
      data: createCompany(), // Uses faker - unique each time
    });
    companies.push({ company_id: company.company_id, name: company.name });
  }
  return companies;
}

/**
 * Helper: Create test stores with auto-cleanup tracking
 */
async function createTestStores(
  prisma: PrismaClient,
  companyIds: string[],
  storesPerCompany: number = 1,
): Promise<Array<{ store_id: string; company_id: string; name: string }>> {
  const stores = [];
  for (const companyId of companyIds) {
    for (let i = 0; i < storesPerCompany; i++) {
      const store = await prisma.store.create({
        data: createStore({ company_id: companyId }), // Uses faker - unique each time
      });
      stores.push({
        store_id: store.store_id,
        company_id: store.company_id,
        name: store.name,
      });
    }
  }
  return stores;
}

test.describe("RLS Policies - Company-Level Isolation", () => {
  test("[P0] should filter Company table by user's assigned company_id", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Two companies exist and user is assigned to Company A
    const companies = await createTestCompanies(prismaClient, 2);
    const [companyA, companyB] = companies;

    // Update user's UserRole to have company_id = companyA.company_id
    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: companyA.company_id },
    });

    // Set RLS context
    await setRLSContext(prismaClient, corporateAdminUser.user_id);

    // WHEN: Querying Company table
    const result = await prismaClient.company.findMany();

    // THEN: User only sees Company A (their assigned company)
    expect(result, "User should only see their assigned company").toHaveLength(1);
    expect(result[0].company_id, "Returned company should be Company A").toBe(companyA.company_id);
    expect(result[0].name, "Company name should match Company A").toBe(companyA.name);
    // Explicit negative assertion: Company B should NOT be visible
    expect(result.some((c) => c.company_id === companyB.company_id), "Company B should not be visible to user assigned to Company A").toBe(false);

    // Cleanup: Fixture handles user cleanup, we clean test data
    await prismaClient.company.deleteMany({
      where: {
        company_id: { in: companies.map((c) => c.company_id) },
      },
    });
  });

  test("[P0] should filter Store table by user's assigned company_id", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Two companies with stores exist and user is assigned to Company A
    const companies = await createTestCompanies(prismaClient, 2);
    const [companyA, companyB] = companies;

    const stores = await createTestStores(prismaClient, [
      companyA.company_id,
      companyB.company_id,
    ]);
    const companyAStores = stores.filter((s) => s.company_id === companyA.company_id);
    const companyBStores = stores.filter((s) => s.company_id === companyB.company_id);

    // Update user's UserRole to have company_id = companyA.company_id
    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: companyA.company_id },
    });

    // Set RLS context
    await setRLSContext(prismaClient, corporateAdminUser.user_id);

    // WHEN: Querying Store table
    const result = await prismaClient.store.findMany();

    // THEN: User only sees stores from Company A
    expect(result, "User should only see stores from their assigned company").toHaveLength(companyAStores.length);
    const resultStoreIds = result.map((s) => s.store_id).sort();
    const expectedStoreIds = companyAStores.map((s) => s.store_id).sort();
    expect(resultStoreIds, "Store IDs should match Company A stores").toEqual(expectedStoreIds);
    // Explicit: All returned stores belong to Company A
    expect(result.every((s) => s.company_id === companyA.company_id), "All returned stores must belong to Company A").toBe(true);
    // Explicit negative: No stores from Company B
    expect(result.some((s) => companyBStores.some((bs) => bs.store_id === s.store_id)), "No stores from Company B should be visible").toBe(false);

    // Cleanup
    await prismaClient.store.deleteMany({
      where: { store_id: { in: stores.map((s) => s.store_id) } },
    });
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });

  test("[P0] should return empty result set when querying other company's data", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Two companies exist and user is assigned to Company A
    const companies = await createTestCompanies(prismaClient, 2);
    const [companyA, companyB] = companies;

    // Update user's UserRole to have company_id = companyA.company_id
    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: companyA.company_id },
    });

    // Set RLS context
    await setRLSContext(prismaClient, corporateAdminUser.user_id);

    // WHEN: Querying Company B directly
    const companyBResult = await prismaClient.company.findUnique({
      where: { company_id: companyB.company_id },
    });

    // THEN: Query returns null (empty result, no error)
    expect(companyBResult, "Querying unauthorized company should return null without error").toBeNull();
    // Explicit: No exception thrown (silent filtering)
    // Test passes if no error is thrown

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });

  test("[P1] should prevent INSERT into other company's data", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Two companies exist and user is assigned to Company A
    const companies = await createTestCompanies(prismaClient, 2);
    const [companyA, companyB] = companies;

    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: companyA.company_id },
    });

    await setRLSContext(prismaClient, corporateAdminUser.user_id);

    // WHEN: Attempting to create store for Company B
    // THEN: INSERT should fail (RLS policy prevents unauthorized inserts)
    await expect(
      prismaClient.store.create({
        data: createStore({ company_id: companyB.company_id }),
      }),
    ).rejects.toThrow();

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });

  test("[P1] should prevent UPDATE of other company's data", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Two companies exist and user is assigned to Company A
    const companies = await createTestCompanies(prismaClient, 2);
    const [companyA, companyB] = companies;

    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: companyA.company_id },
    });

    await setRLSContext(prismaClient, corporateAdminUser.user_id);

    // WHEN: Attempting to update Company B
    // THEN: UPDATE should fail (RLS policy prevents unauthorized updates)
    await expect(
      prismaClient.company.update({
        where: { company_id: companyB.company_id },
        data: { name: "Updated Name" },
      }),
    ).rejects.toThrow();

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });

  test("[P1] should prevent DELETE of other company's data", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Two companies exist and user is assigned to Company A
    const companies = await createTestCompanies(prismaClient, 2);
    const [companyA, companyB] = companies;

    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: companyA.company_id },
    });

    await setRLSContext(prismaClient, corporateAdminUser.user_id);

    // WHEN: Attempting to delete Company B
    // THEN: DELETE should fail (RLS policy prevents unauthorized deletes)
    await expect(
      prismaClient.company.delete({
        where: { company_id: companyB.company_id },
      }),
    ).rejects.toThrow();

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });
});

test.describe("RLS Policies - Store-Level Isolation", () => {
  test("[P0] should filter Shift table by user's assigned store_id", async ({
    prismaClient,
    storeManagerUser,
  }) => {
    // GIVEN: Two stores exist and user is assigned to Store 1
    const company = await prismaClient.company.create({
      data: createCompany(),
    });
    const stores = await createTestStores(prismaClient, [company.company_id], 2);
    const [store1, store2] = stores;

    // Create shifts for both stores
    const shift1 = await prismaClient.shift.create({
      data: {
        store_id: store1.store_id,
        opened_at: new Date(),
        opening_cash: 1000,
      },
    });
    const shift2 = await prismaClient.shift.create({
      data: {
        store_id: store2.store_id,
        opened_at: new Date(),
        opening_cash: 1000,
      },
    });

    // Update user's UserRole to have store_id = store1.store_id
    await prismaClient.userRole.updateMany({
      where: { user_id: storeManagerUser.user_id },
      data: { store_id: store1.store_id, company_id: company.company_id },
    });

    // Set RLS context
    await setRLSContext(prismaClient, storeManagerUser.user_id);

    // WHEN: Querying Shift table
    const shifts = await prismaClient.shift.findMany();

    // THEN: User only sees shifts from Store 1
    expect(shifts).toHaveLength(1);
    expect(shifts[0].shift_id).toBe(shift1.shift_id);
    expect(shifts[0].store_id).toBe(store1.store_id);
    // Explicit negative: Shift 2 should NOT be visible
    expect(shifts.some((s) => s.shift_id === shift2.shift_id)).toBe(false);

    // Cleanup
    await prismaClient.shift.deleteMany({
      where: { shift_id: { in: [shift1.shift_id, shift2.shift_id] } },
    });
    await prismaClient.store.deleteMany({
      where: { store_id: { in: stores.map((s) => s.store_id) } },
    });
    await prismaClient.company.delete({
      where: { company_id: company.company_id },
    });
  });

  test("[P0] should return empty result set when querying other store's data", async ({
    prismaClient,
    storeManagerUser,
  }) => {
    // GIVEN: Two stores exist and user is assigned to Store 1
    const company = await prismaClient.company.create({
      data: createCompany(),
    });
    const stores = await createTestStores(prismaClient, [company.company_id], 2);
    const [store1, store2] = stores;

    const shift2 = await prismaClient.shift.create({
      data: {
        store_id: store2.store_id,
        opened_at: new Date(),
        opening_cash: 1000,
      },
    });

    // Update user's UserRole to have store_id = store1.store_id
    await prismaClient.userRole.updateMany({
      where: { user_id: storeManagerUser.user_id },
      data: { store_id: store1.store_id, company_id: company.company_id },
    });

    // Set RLS context
    await setRLSContext(prismaClient, storeManagerUser.user_id);

    // WHEN: Querying Shift from Store 2 directly
    const shift2Result = await prismaClient.shift.findUnique({
      where: { shift_id: shift2.shift_id },
    });

    // THEN: Query returns null (empty result, no error)
    expect(shift2Result).toBeNull();
    // Explicit: No exception thrown (silent filtering)

    // Cleanup
    await prismaClient.shift.deleteMany({
      where: { shift_id: shift2.shift_id },
    });
    await prismaClient.store.deleteMany({
      where: { store_id: { in: stores.map((s) => s.store_id) } },
    });
    await prismaClient.company.delete({
      where: { company_id: company.company_id },
    });
  });
});

test.describe("RLS Policies - System Admin Bypass", () => {
  test("[P0] should allow System Admin to access all companies", async ({
    prismaClient,
    superadminUser,
  }) => {
    // GIVEN: Multiple companies exist
    const companies = await createTestCompanies(prismaClient, 3);
    const companyIds = companies.map((c) => c.company_id);

    // Set RLS context for System Admin
    await setRLSContext(prismaClient, superadminUser.user_id);

    // WHEN: System Admin queries Company table
    const result = await prismaClient.company.findMany({
      where: {
        company_id: { in: companyIds },
      },
    });

    // THEN: System Admin sees all companies (RLS bypass)
    expect(result.length).toBeGreaterThanOrEqual(3);
    const resultCompanyIds = result.map((c) => c.company_id);
    // Explicit: All test companies should be visible
    for (const companyId of companyIds) {
      expect(resultCompanyIds).toContain(companyId);
    }

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companyIds } },
    });
  });

  test("[P0] should allow System Admin to access all stores", async ({
    prismaClient,
    superadminUser,
  }) => {
    // GIVEN: Multiple stores in different companies exist
    const companies = await createTestCompanies(prismaClient, 2);
    const stores = await createTestStores(prismaClient, companies.map((c) => c.company_id), 1);
    const storeIds = stores.map((s) => s.store_id);

    // Set RLS context for System Admin
    await setRLSContext(prismaClient, superadminUser.user_id);

    // WHEN: System Admin queries Store table
    const result = await prismaClient.store.findMany({
      where: {
        store_id: { in: storeIds },
      },
    });

    // THEN: System Admin sees all stores (RLS bypass)
    expect(result).toHaveLength(stores.length);
    const resultStoreIds = result.map((s) => s.store_id);
    // Explicit: All test stores should be visible
    for (const storeId of storeIds) {
      expect(resultStoreIds).toContain(storeId);
    }

    // Cleanup
    await prismaClient.store.deleteMany({
      where: { store_id: { in: storeIds } },
    });
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });
});

test.describe("RLS Policies - Corporate Admin Company Access", () => {
  test("[P1] should allow Corporate Admin to access all stores in their company", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Company A has multiple stores and user is Corporate Admin for Company A
    const companies = await createTestCompanies(prismaClient, 2);
    const [companyA, companyB] = companies;

    const stores = await createTestStores(prismaClient, [
      companyA.company_id,
      companyB.company_id,
    ], 2);
    const companyAStores = stores.filter((s) => s.company_id === companyA.company_id);
    const companyBStores = stores.filter((s) => s.company_id === companyB.company_id);

    // Update user's UserRole to have company_id = companyA.company_id (COMPANY scope)
    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: companyA.company_id },
    });

    // Set RLS context
    await setRLSContext(prismaClient, corporateAdminUser.user_id);

    // WHEN: Corporate Admin queries Store table
    const result = await prismaClient.store.findMany();

    // THEN: Corporate Admin sees all stores in Company A, but not Company B
    const resultStoreIds = result.map((s) => s.store_id);
    // Explicit: All Company A stores should be visible
    for (const store of companyAStores) {
      expect(resultStoreIds).toContain(store.store_id);
    }
    // Explicit negative: No Company B stores should be visible
    for (const store of companyBStores) {
      expect(resultStoreIds).not.toContain(store.store_id);
    }

    // Cleanup
    await prismaClient.store.deleteMany({
      where: { store_id: { in: stores.map((s) => s.store_id) } },
    });
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });
});

test.describe("RLS Policies - Prisma ORM Integration", () => {
  test("[P0] should enforce RLS policies on Prisma queries", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Two companies exist and user is assigned to Company A
    const companies = await createTestCompanies(prismaClient, 2);
    const [companyA] = companies;

    // Update user's UserRole to have company_id = companyA.company_id
    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: companyA.company_id },
    });

    // Set RLS context via Prisma
    await setRLSContext(prismaClient, corporateAdminUser.user_id);

    // WHEN: Using Prisma query methods (findMany, findUnique, etc.)
    const result = await prismaClient.company.findMany();

    // THEN: Prisma queries respect RLS policies
    expect(result).toHaveLength(1);
    expect(result[0].company_id).toBe(companyA.company_id);
    // Explicit: Only assigned company is visible
    expect(result.every((c) => c.company_id === companyA.company_id)).toBe(true);

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });

  test("[P0] should enforce RLS policies on direct SQL queries", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Two companies exist and user is assigned to Company A
    const companies = await createTestCompanies(prismaClient, 2);
    const [companyA] = companies;

    // Update user's UserRole to have company_id = companyA.company_id
    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: companyA.company_id },
    });

    // Set RLS context
    await setRLSContext(prismaClient, corporateAdminUser.user_id);

    // WHEN: Using direct SQL query
    const result = await prismaClient.$queryRawUnsafe<Array<{ company_id: string; name: string }>>(
      `SELECT company_id, name FROM companies`,
    );

    // THEN: Direct SQL queries also respect RLS policies (cannot bypass)
    expect(result).toHaveLength(1);
    expect(result[0].company_id).toBe(companyA.company_id);
    // Explicit: RLS policies apply even to raw SQL

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });
});

test.describe("RLS Policies - Silent Filtering", () => {
  test("[P1] should return empty result set without errors for unauthorized access", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Company B exists and user is assigned to Company A
    const companies = await createTestCompanies(prismaClient, 2);
    const [companyA, companyB] = companies;

    // Update user's UserRole to have company_id = companyA.company_id
    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: companyA.company_id },
    });

    // Set RLS context
    await setRLSContext(prismaClient, corporateAdminUser.user_id);

    // WHEN: Querying Company B (user is not assigned to it)
    const companyBResult = await prismaClient.company.findUnique({
      where: { company_id: companyB.company_id },
    });

    // THEN: Query returns null (empty result) without throwing error
    expect(companyBResult).toBeNull();
    // Explicit: No error is thrown (silent filtering)
    // Test passes if no exception is thrown

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });

  test("[P1] should not leak information about existence of other companies", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Company B exists and user is assigned to Company A
    const companies = await createTestCompanies(prismaClient, 2);
    const [companyA, companyB] = companies;

    // Update user's UserRole to have company_id = companyA.company_id
    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: companyA.company_id },
    });

    // Set RLS context
    await setRLSContext(prismaClient, corporateAdminUser.user_id);

    // WHEN: Querying all companies
    const result = await prismaClient.company.findMany();

    // THEN: User only sees Company A (cannot detect Company B exists)
    expect(result).toHaveLength(1);
    expect(result[0].company_id).toBe(companyA.company_id);
    // Explicit: Company B should NOT be in results
    expect(result.every((c) => c.company_id !== companyB.company_id)).toBe(true);
    // Explicit: User cannot infer existence of other companies
    expect(result.length).toBe(1);

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });
});

test.describe("RLS Policies - Edge Cases", () => {
  test("[P1] should handle user with no assigned company_id (sees nothing)", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Companies exist but user has no company_id assigned
    const companies = await createTestCompanies(prismaClient, 2);

    // UserRole exists but company_id is null
    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: null },
    });

    await setRLSContext(prismaClient, corporateAdminUser.user_id);

    // WHEN: Querying companies
    const result = await prismaClient.company.findMany({
      where: {
        company_id: { in: companies.map((c) => c.company_id) },
      },
    });

    // THEN: User sees nothing (no company_id = no access)
    expect(result, "User with no company_id assignment should see no companies").toHaveLength(0);

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });

  test("[P1] should handle user with no roles (sees nothing)", async ({
    prismaClient,
  }) => {
    // GIVEN: Companies exist and user exists but has no roles
    const companies = await createTestCompanies(prismaClient, 2);
    const user = await prismaClient.user.create({
      data: createUser(),
    });

    // User has no UserRole records
    await setRLSContext(prismaClient, user.user_id);

    // WHEN: Querying companies
    const result = await prismaClient.company.findMany({
      where: {
        company_id: { in: companies.map((c) => c.company_id) },
      },
    });

    // THEN: User sees nothing (no roles = no access)
    expect(result, "User with no roles should see no companies").toHaveLength(0);

    // Cleanup
    await prismaClient.user.delete({ where: { user_id: user.user_id } });
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });
});

test.describe("RLS Policies - Security Tests", () => {
  test("[P0] should prevent SQL injection in RLS context user ID", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Companies exist and user is assigned to Company A
    const companies = await createTestCompanies(prismaClient, 2);
    const [companyA] = companies;

    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: companyA.company_id },
    });

    // WHEN: Attempting SQL injection in RLS context
    const maliciousUserId = `'; DROP TABLE companies; --`;
    
    // THEN: SQL injection should be prevented (either sanitized or error thrown)
    await expect(
      prismaClient.$executeRawUnsafe(`SET LOCAL app.current_user_id = '${maliciousUserId}'`),
    ).rejects.toThrow();

    // Verify companies still exist (not dropped)
    const companiesAfter = await prismaClient.company.findMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
    expect(companiesAfter, "Companies should not be deleted by SQL injection").toHaveLength(2);

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });

  test("[P0] should prevent unauthorized access without valid user context", async ({
    prismaClient,
  }) => {
    // GIVEN: Companies exist
    const companies = await createTestCompanies(prismaClient, 2);

    // WHEN: Querying without setting RLS context (no user context)
    // THEN: RLS policies should filter all rows (empty result)
    const result = await prismaClient.company.findMany({
      where: {
        company_id: { in: companies.map((c) => c.company_id) },
      },
    });

    expect(result, "Query without RLS context should return empty result").toHaveLength(0);

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });

  test("[P0] should prevent access with invalid user ID format", async ({
    prismaClient,
  }) => {
    // GIVEN: Companies exist
    const companies = await createTestCompanies(prismaClient, 2);

    // WHEN: Setting RLS context with invalid user ID (non-existent UUID)
    const invalidUserId = "00000000-0000-0000-0000-000000000000";
    await setRLSContext(prismaClient, invalidUserId);

    // THEN: Query should return empty result (user doesn't exist, no roles)
    const result = await prismaClient.company.findMany({
      where: {
        company_id: { in: companies.map((c) => c.company_id) },
      },
    });

    expect(result, "Query with invalid user ID should return empty result").toHaveLength(0);

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });

  test("[P0] should prevent data leakage through error messages", async ({
    prismaClient,
    corporateAdminUser,
  }) => {
    // GIVEN: Company B exists and user is assigned to Company A
    const companies = await createTestCompanies(prismaClient, 2);
    const [companyA, companyB] = companies;

    await prismaClient.userRole.updateMany({
      where: { user_id: corporateAdminUser.user_id },
      data: { company_id: companyA.company_id },
    });

    await setRLSContext(prismaClient, corporateAdminUser.user_id);

    // WHEN: Attempting to access Company B (unauthorized)
    // THEN: Should return null without revealing Company B exists
    const result = await prismaClient.company.findUnique({
      where: { company_id: companyB.company_id },
    });

    expect(result, "Unauthorized access should return null without error").toBeNull();
    // Verify no information leakage about Company B existence

    // Cleanup
    await prismaClient.company.deleteMany({
      where: { company_id: { in: companies.map((c) => c.company_id) } },
    });
  });
});

import { test, expect } from "../support/fixtures/rbac.fixture";
import {
  createTransaction,
  createTransactionLineItem,
  createTransactionPayment,
  createStore,
  createCompany,
  createUser,
  createJWTAccessToken,
} from "../support/factories";

/**
 * Transaction Data Models API Tests - Story 3.1
 *
 * STORY: As a developer, I want to create the transaction data models,
 * so that I can store transaction data with proper relationships for POS processing.
 *
 * TEST LEVEL: API (data model validation via Prisma)
 * PRIMARY GOAL: Verify Transaction, TransactionLineItem, TransactionPayment models
 *
 * ATDD: These tests are written BEFORE implementation (RED phase).
 * Tests will fail until Prisma models are created.
 */

// =============================================================================
// SECTION 1: P0 CRITICAL PATH TESTS
// =============================================================================

test.describe("Transaction Data Models - CRUD Operations", () => {
  test("[P0] should create Transaction with all required fields", async ({
    corporateAdminApiRequest,
    corporateAdminUser,
    prismaClient,
  }) => {
    // GIVEN: A store and shift exist (prerequisites)
    const store = await prismaClient.store.create({
      data: {
        company_id: corporateAdminUser.company_id,
        name: "Test Store",
        timezone: "America/New_York",
        status: "ACTIVE",
      },
    });

    // Create a shift for the transaction
    const shift = await prismaClient.shift.create({
      data: {
        store_id: store.store_id,
        cashier_id: corporateAdminUser.user_id,
        opening_amount: 100.00,
        status: "OPEN",
      },
    });

    const shiftId = shift.shift_id;
    const cashierId = corporateAdminUser.user_id;

    // WHEN: Creating a transaction via Prisma
    const transactionData = createTransaction({
      store_id: store.store_id,
      shift_id: shiftId,
      cashier_id: cashierId,
    });

    // This will fail until Transaction model is created
    const transaction = await prismaClient.transaction.create({
      data: {
        store_id: transactionData.store_id,
        shift_id: transactionData.shift_id,
        cashier_id: transactionData.cashier_id,
        subtotal: transactionData.subtotal,
        tax: transactionData.tax,
        discount: transactionData.discount,
        total: transactionData.total,
      },
    });

    // THEN: Transaction is created with all fields
    expect(transaction).toHaveProperty("transaction_id");
    expect(transaction.store_id).toBe(store.store_id);
    expect(transaction.shift_id).toBe(shiftId);
    expect(transaction.cashier_id).toBe(cashierId);
    expect(transaction.subtotal).toBeDefined();
    expect(transaction.tax).toBeDefined();
    expect(transaction.discount).toBeDefined();
    expect(transaction.total).toBeDefined();
    expect(transaction.timestamp).toBeDefined();
    expect(transaction.created_at).toBeDefined();
  });

  test("[P0] should create TransactionLineItems linked to Transaction", async ({
    corporateAdminUser,
    prismaClient,
  }) => {
    // GIVEN: A transaction exists
    const store = await prismaClient.store.create({
      data: {
        company_id: corporateAdminUser.company_id,
        name: "Test Store",
        timezone: "America/New_York",
        status: "ACTIVE",
      },
    });

    // Create a shift for the transaction
    const shift = await prismaClient.shift.create({
      data: {
        store_id: store.store_id,
        cashier_id: corporateAdminUser.user_id,
        opening_amount: 100.00,
        status: "OPEN",
      },
    });

    // Create transaction first
    const transaction = await prismaClient.transaction.create({
      data: {
        store_id: store.store_id,
        shift_id: shift.shift_id,
        cashier_id: corporateAdminUser.user_id,
        subtotal: 100.0,
        tax: 8.0,
        discount: 0,
        total: 108.0,
      },
    });

    // WHEN: Creating line items for the transaction
    const lineItemData = createTransactionLineItem({
      transaction_id: transaction.transaction_id,
    });

    const lineItem = await prismaClient.transactionLineItem.create({
      data: {
        transaction_id: lineItemData.transaction_id,
        product_id: lineItemData.product_id,
        sku: lineItemData.sku,
        name: lineItemData.name,
        quantity: lineItemData.quantity,
        unit_price: lineItemData.unit_price,
        discount: lineItemData.discount,
        line_total: lineItemData.line_total,
      },
    });

    // THEN: Line item is created and linked to transaction
    expect(lineItem).toHaveProperty("line_item_id");
    expect(lineItem.transaction_id).toBe(transaction.transaction_id);
    expect(lineItem.name).toBeDefined();
    expect(lineItem.quantity).toBeGreaterThan(0);
    expect(lineItem.unit_price).toBeDefined();
    expect(lineItem.line_total).toBeDefined();
    expect(lineItem.created_at).toBeDefined();
  });

  test("[P0] should create TransactionPayments linked to Transaction", async ({
    corporateAdminUser,
    prismaClient,
  }) => {
    // GIVEN: A transaction exists
    const store = await prismaClient.store.create({
      data: {
        company_id: corporateAdminUser.company_id,
        name: "Test Store",
        timezone: "America/New_York",
        status: "ACTIVE",
      },
    });

    // Create a shift for the transaction
    const shift = await prismaClient.shift.create({
      data: {
        store_id: store.store_id,
        cashier_id: corporateAdminUser.user_id,
        opening_amount: 100.00,
        status: "OPEN",
      },
    });

    const transaction = await prismaClient.transaction.create({
      data: {
        store_id: store.store_id,
        shift_id: shift.shift_id,
        cashier_id: corporateAdminUser.user_id,
        subtotal: 100.0,
        tax: 8.0,
        discount: 0,
        total: 108.0,
      },
    });

    // WHEN: Creating payment for the transaction
    const paymentData = createTransactionPayment({
      transaction_id: transaction.transaction_id,
      amount: 108.0,
    });

    const payment = await prismaClient.transactionPayment.create({
      data: {
        transaction_id: paymentData.transaction_id,
        method: paymentData.method,
        amount: paymentData.amount,
        reference: paymentData.reference,
      },
    });

    // THEN: Payment is created and linked to transaction
    expect(payment).toHaveProperty("payment_id");
    expect(payment.transaction_id).toBe(transaction.transaction_id);
    expect(payment.method).toBeDefined();
    expect(payment.amount).toBeDefined();
    expect(payment.created_at).toBeDefined();
  });

  test("[P0] should enforce foreign key constraint - store must exist", async ({
    corporateAdminUser,
    prismaClient,
  }) => {
    // GIVEN: A non-existent store ID
    const nonExistentStoreId = "00000000-0000-0000-0000-000000000000";
    const nonExistentShiftId = "00000000-0000-0000-0000-000000000001";

    // WHEN: Trying to create transaction with invalid store_id
    // THEN: Should throw foreign key constraint error
    await expect(
      prismaClient.transaction.create({
        data: {
          store_id: nonExistentStoreId,
          shift_id: nonExistentShiftId,
          cashier_id: corporateAdminUser.user_id,
          subtotal: 100.0,
          tax: 8.0,
          discount: 0,
          total: 108.0,
        },
      }),
    ).rejects.toThrow();
  });
});

// =============================================================================
// SECTION 2: P1 HIGH PRIORITY TESTS
// =============================================================================

test.describe("Transaction Data Models - Query Operations", () => {
  test("[P1] should query transactions by store_id", async ({
    corporateAdminUser,
    prismaClient,
  }) => {
    // GIVEN: Multiple transactions for a store
    const store = await prismaClient.store.create({
      data: {
        company_id: corporateAdminUser.company_id,
        name: "Test Store",
        timezone: "America/New_York",
        status: "ACTIVE",
      },
    });

    // Create a shift for the transactions
    const shift = await prismaClient.shift.create({
      data: {
        store_id: store.store_id,
        cashier_id: corporateAdminUser.user_id,
        opening_amount: 100.00,
        status: "OPEN",
      },
    });

    // Create 3 transactions
    for (let i = 0; i < 3; i++) {
      await prismaClient.transaction.create({
        data: {
          store_id: store.store_id,
          shift_id: shift.shift_id,
          cashier_id: corporateAdminUser.user_id,
          subtotal: 100.0 * (i + 1),
          tax: 8.0 * (i + 1),
          discount: 0,
          total: 108.0 * (i + 1),
        },
      });
    }

    // WHEN: Querying by store_id
    const transactions = await prismaClient.transaction.findMany({
      where: { store_id: store.store_id },
    });

    // THEN: All 3 transactions are returned
    expect(transactions).toHaveLength(3);
    transactions.forEach((t) => {
      expect(t.store_id).toBe(store.store_id);
    });
  });

  test("[P1] should query transactions by shift_id", async ({
    corporateAdminUser,
    prismaClient,
  }) => {
    // GIVEN: Transactions with specific shift_id
    const store = await prismaClient.store.create({
      data: {
        company_id: corporateAdminUser.company_id,
        name: "Test Store",
        timezone: "America/New_York",
        status: "ACTIVE",
      },
    });

    // Create two shifts
    const shift1 = await prismaClient.shift.create({
      data: {
        store_id: store.store_id,
        cashier_id: corporateAdminUser.user_id,
        opening_amount: 100.00,
        status: "OPEN",
      },
    });

    const shift2 = await prismaClient.shift.create({
      data: {
        store_id: store.store_id,
        cashier_id: corporateAdminUser.user_id,
        opening_amount: 100.00,
        status: "OPEN",
      },
    });

    // Create transactions for different shifts
    await prismaClient.transaction.create({
      data: {
        store_id: store.store_id,
        shift_id: shift1.shift_id,
        cashier_id: corporateAdminUser.user_id,
        subtotal: 100.0,
        tax: 8.0,
        discount: 0,
        total: 108.0,
      },
    });

    await prismaClient.transaction.create({
      data: {
        store_id: store.store_id,
        shift_id: shift2.shift_id,
        cashier_id: corporateAdminUser.user_id,
        subtotal: 200.0,
        tax: 16.0,
        discount: 0,
        total: 216.0,
      },
    });

    // WHEN: Querying by shift_id
    const transactions = await prismaClient.transaction.findMany({
      where: { shift_id: shift1.shift_id },
    });

    // THEN: Only shift1 transaction is returned
    expect(transactions).toHaveLength(1);
    expect(transactions[0].shift_id).toBe(shift1.shift_id);
  });

  test("[P1] should query transactions by timestamp range", async ({
    corporateAdminUser,
    prismaClient,
  }) => {
    // GIVEN: Transactions at different times
    const store = await prismaClient.store.create({
      data: {
        company_id: corporateAdminUser.company_id,
        name: "Test Store",
        timezone: "America/New_York",
        status: "ACTIVE",
      },
    });

    // Create a shift for the transaction
    const shift = await prismaClient.shift.create({
      data: {
        store_id: store.store_id,
        cashier_id: corporateAdminUser.user_id,
        opening_amount: 100.00,
        status: "OPEN",
      },
    });

    const now = new Date();
    const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000);

    await prismaClient.transaction.create({
      data: {
        store_id: store.store_id,
        shift_id: shift.shift_id,
        cashier_id: corporateAdminUser.user_id,
        timestamp: now,
        subtotal: 100.0,
        tax: 8.0,
        discount: 0,
        total: 108.0,
      },
    });

    // WHEN: Querying by timestamp range
    const transactions = await prismaClient.transaction.findMany({
      where: {
        timestamp: {
          gte: yesterday,
          lte: tomorrow,
        },
      },
    });

    // THEN: Transaction within range is returned
    expect(transactions.length).toBeGreaterThanOrEqual(1);
  });

  test("[P1] should load transaction with line items and payments (relationships)", async ({
    corporateAdminUser,
    prismaClient,
  }) => {
    // GIVEN: A transaction with line items and payments
    const store = await prismaClient.store.create({
      data: {
        company_id: corporateAdminUser.company_id,
        name: "Test Store",
        timezone: "America/New_York",
        status: "ACTIVE",
      },
    });

    // Create a shift for the transaction
    const shift = await prismaClient.shift.create({
      data: {
        store_id: store.store_id,
        cashier_id: corporateAdminUser.user_id,
        opening_amount: 100.00,
        status: "OPEN",
      },
    });

    const transaction = await prismaClient.transaction.create({
      data: {
        store_id: store.store_id,
        shift_id: shift.shift_id,
        cashier_id: corporateAdminUser.user_id,
        subtotal: 100.0,
        tax: 8.0,
        discount: 0,
        total: 108.0,
      },
    });

    // Create line items
    await prismaClient.transactionLineItem.create({
      data: {
        transaction_id: transaction.transaction_id,
        name: "Test Product",
        quantity: 2,
        unit_price: 50.0,
        discount: 0,
        line_total: 100.0,
      },
    });

    // Create payment
    await prismaClient.transactionPayment.create({
      data: {
        transaction_id: transaction.transaction_id,
        method: "CASH",
        amount: 108.0,
      },
    });

    // WHEN: Loading transaction with relationships
    const fullTransaction = await prismaClient.transaction.findUnique({
      where: { transaction_id: transaction.transaction_id },
      include: {
        line_items: true,
        payments: true,
      },
    });

    // THEN: Transaction includes related data
    expect(fullTransaction).toBeDefined();
    expect(fullTransaction?.line_items).toHaveLength(1);
    expect(fullTransaction?.payments).toHaveLength(1);
    expect(fullTransaction?.line_items[0].name).toBe("Test Product");
    expect(fullTransaction?.payments[0].method).toBe("CASH");
  });
});

// =============================================================================
// SECTION 3: P2 MEDIUM PRIORITY TESTS
// =============================================================================

test.describe("Transaction Data Models - Business Logic", () => {
  test("[P2] should verify transaction total matches line items sum", async ({
    corporateAdminUser,
    prismaClient,
  }) => {
    // GIVEN: A transaction with line items
    const store = await prismaClient.store.create({
      data: {
        company_id: corporateAdminUser.company_id,
        name: "Test Store",
        timezone: "America/New_York",
        status: "ACTIVE",
      },
    });

    // Create a shift for the transaction
    const shift = await prismaClient.shift.create({
      data: {
        store_id: store.store_id,
        cashier_id: corporateAdminUser.user_id,
        opening_amount: 100.00,
        status: "OPEN",
      },
    });

    const transaction = await prismaClient.transaction.create({
      data: {
        store_id: store.store_id,
        shift_id: shift.shift_id,
        cashier_id: corporateAdminUser.user_id,
        subtotal: 150.0,
        tax: 12.0,
        discount: 0,
        total: 162.0,
      },
    });

    // Create line items that sum to subtotal
    await prismaClient.transactionLineItem.createMany({
      data: [
        {
          transaction_id: transaction.transaction_id,
          name: "Product A",
          quantity: 2,
          unit_price: 50.0,
          discount: 0,
          line_total: 100.0,
        },
        {
          transaction_id: transaction.transaction_id,
          name: "Product B",
          quantity: 1,
          unit_price: 50.0,
          discount: 0,
          line_total: 50.0,
        },
      ],
    });

    // WHEN: Loading line items
    const lineItems = await prismaClient.transactionLineItem.findMany({
      where: { transaction_id: transaction.transaction_id },
    });

    // THEN: Sum of line totals matches transaction subtotal
    const lineItemsSum = lineItems.reduce(
      (sum, item) => sum + Number(item.line_total),
      0,
    );
    expect(lineItemsSum).toBe(150.0);
    expect(lineItemsSum).toBe(Number(transaction.subtotal));
  });

  test("[P2] should verify indexes exist for query performance", async ({
    prismaClient,
  }) => {
    // This test verifies that indexes were created correctly
    // by checking query execution plans (optional, database-specific)

    // WHEN: Querying the database for index information
    const result = await prismaClient.$queryRaw`
      SELECT indexname, tablename
      FROM pg_indexes
      WHERE tablename = 'transactions'
      AND indexname LIKE '%store_id%' OR indexname LIKE '%shift_id%' OR indexname LIKE '%timestamp%'
    `;

    // THEN: Expected indexes exist
    // Note: This test may need adjustment based on actual index naming
    expect(result).toBeDefined();
  });
});

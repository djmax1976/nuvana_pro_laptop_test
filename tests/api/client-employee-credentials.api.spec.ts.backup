// tests/api/client-employee-credentials.api.spec.ts
import { test, expect } from "../support/fixtures/rbac.fixture";
import { createCompany, createUser, createStore } from "../support/helpers";
import { createEmployeeRequest } from "../support/factories/client-employee.factory";

/**
 * Client Employee Credentials API Tests
 * 
 * Tests the employee credential management API endpoints (P0 - Critical).
 * 
 * API tests are THIRD in pyramid order (15-25% of tests)
 * 
 * ENDPOINTS TESTED:
 * - PUT /api/client/employees/:userId/email (P0 - Critical)
 * - PUT /api/client/employees/:userId/password (P0 - Critical)
 * 
 * PRIORITY: P0 (Critical) - Credential management is security-critical
 */

test.describe("Employee Email Update API", () => {
  test("[P0-AC-5] PUT /api/client/employees/:userId/email updates employee email", async ({
    clientUserApiRequest,
    clientUser,
    prismaClient,
  }) => {
    // GIVEN: A client owner with an employee
    // Get a STORE scope role for employee assignment
    const storeRole = await prismaClient.role.findFirst({
      where: { scope: "STORE" },
    });
    if (!storeRole) {
      throw new Error("No STORE scope role found in database");
    }

    // Create employee via API using factory pattern
    const employeeData = createEmployeeRequest({
      store_id: clientUser.store_id,
      role_id: storeRole.role_id,
    });
    
    const createResponse = await clientUserApiRequest.post("/api/client/employees", {
      email: employeeData.email,
      name: employeeData.name,
      store_id: employeeData.store_id,
      role_id: employeeData.role_id,
    });
    
    if (createResponse.status() !== 201) {
      const errorBody = await createResponse.json();
      throw new Error(`Employee creation failed: ${JSON.stringify(errorBody)}`);
    }
    
    const createBody = await createResponse.json();
    const employeeId = createBody.data.user_id;

    // Verify employee was created with correct store association
    // Wait a moment for database consistency
    await new Promise(resolve => setTimeout(resolve, 100));
    
    const employeeUser = await prismaClient.user.findUnique({
      where: { user_id: employeeId },
      include: {
        user_roles: {
          include: {
            store: {
              include: {
                company: true,
              },
            },
          },
        },
      },
    });
    expect(employeeUser).not.toBeNull();
    expect(employeeUser?.user_roles.length).toBeGreaterThan(0);
    // Verify the employee's store belongs to clientUser's company
    const employeeStore = employeeUser?.user_roles[0]?.store;
    expect(employeeStore).toBeDefined();
    expect(employeeStore?.company.owner_user_id).toBe(clientUser.user_id);

    const newEmail = `newemail-${Date.now()}@example.com`;

    // WHEN: Updating employee email
    const response = await clientUserApiRequest.put(
      `/api/client/employees/${employeeId}/email`,
      { email: newEmail },
    );

    // THEN: Returns success and email is updated
    if (response.status() !== 200) {
      const errorBody = await response.json();
      throw new Error(`Email update failed: Status ${response.status()}, Error: ${JSON.stringify(errorBody)}`);
    }
    const body = await response.json();
    expect(body.success).toBe(true);
    expect(body.data.email).toBe(newEmail);
    
    // Verify email was updated in database
    const updatedUser = await prismaClient.user.findUnique({
      where: { user_id: employeeId },
    });
    expect(updatedUser?.email).toBe(newEmail);
  });

  test("[P0-AC-5] PUT /api/client/employees/:userId/email validates email format", async ({
    clientUserApiRequest,
    clientUser,
    prismaClient,
  }) => {
    // GIVEN: A client owner with an employee
    const storeRole = await prismaClient.role.findFirst({
      where: { scope: "STORE" },
    });
    if (!storeRole) {
      throw new Error("No STORE scope role found in database");
    }

    const createResponse = await clientUserApiRequest.post("/api/client/employees", {
      email: `employee-${Date.now()}@example.com`,
      name: "Test Employee",
      store_id: clientUser.store_id,
      role_id: storeRole.role_id,
      password: "TestPassword123!",
    });
    
    if (createResponse.status() !== 201) {
      const errorBody = await createResponse.json();
      throw new Error(`Employee creation failed: ${JSON.stringify(errorBody)}`);
    }
    
    const createBody = await createResponse.json();
    const employeeId = createBody.data.user_id;

    // WHEN: Updating with invalid email format
    const response = await clientUserApiRequest.put(
      `/api/client/employees/${employeeId}/email`,
      { email: "invalid-email" },
    );

    // THEN: Returns validation error (400) or permission error (403 if employee doesn't belong)
    // If we get 403, it means the employee wasn't properly associated - that's a test setup issue
    if (response.status() === 403) {
      const errorBody = await response.json();
      throw new Error(`Employee not associated with clientUser stores: ${JSON.stringify(errorBody)}`);
    }
    expect(response.status()).toBe(400);
    const body = await response.json();
    expect(body.success).toBe(false);
    // Error can be string or object with message/code
    const errorMessage = typeof body.error === "object" ? body.error.message || body.error.code : body.error;
    expect(errorMessage).toBeTruthy();
  });

  test("[P0-AC-5] PUT /api/client/employees/:userId/email rejects duplicate email", async ({
    clientUserApiRequest,
    clientUser,
    prismaClient,
  }) => {
    // GIVEN: Two employees with different emails
    const storeRole = await prismaClient.role.findFirst({
      where: { scope: "STORE" },
    });
    if (!storeRole) {
      throw new Error("No STORE scope role found in database");
    }

    const employee1Data = createEmployeeRequest({
      store_id: clientUser.store_id,
      role_id: storeRole.role_id,
    });
    const create1Response = await clientUserApiRequest.post("/api/client/employees", {
      email: employee1Data.email,
      name: employee1Data.name,
      store_id: employee1Data.store_id,
      role_id: employee1Data.role_id,
    });
    if (create1Response.status() !== 201) {
      const errorBody = await create1Response.json();
      throw new Error(`Employee 1 creation failed: ${JSON.stringify(errorBody)}`);
    }
    const create1Body = await create1Response.json();
    const employee1Id = create1Body.data.user_id;

    const employee2Data = createEmployeeRequest({
      store_id: clientUser.store_id,
      role_id: storeRole.role_id,
    });
    const create2Response = await clientUserApiRequest.post("/api/client/employees", {
      email: employee2Data.email,
      name: employee2Data.name,
      store_id: employee2Data.store_id,
      role_id: employee2Data.role_id,
    });
    if (create2Response.status() !== 201) {
      const errorBody = await create2Response.json();
      throw new Error(`Employee 2 creation failed: ${JSON.stringify(errorBody)}`);
    }
    const create2Body = await create2Response.json();
    const employee2Id = create2Body.data.user_id;

    // WHEN: Trying to update employee2's email to employee1's email
    const response = await clientUserApiRequest.put(
      `/api/client/employees/${employee2Id}/email`,
      { email: employee1Data.email },
    );

    // THEN: Returns conflict error (409) or validation error (400)
    expect([409, 400]).toContain(response.status());
    const body = await response.json();
    expect(body.success).toBe(false);
  });

  test("[P0-AC-5] PUT /api/client/employees/:userId/email enforces RLS - owner can only update own employees", async ({
    clientUserApiRequest,
    clientUser,
    prismaClient,
  }) => {
    // GIVEN: Another client owner with their own employee
    const owner2 = await createUser(prismaClient);
    const company2 = await createCompany(prismaClient, {
      owner_user_id: owner2.user_id,
    });
    const store2 = await createStore(prismaClient, {
      company_id: company2.company_id,
    });
    
    // Create employee for owner2's company (not accessible by clientUser)
    const storeRole = await prismaClient.role.findFirst({
      where: { scope: "STORE" },
    });
    if (!storeRole) {
      throw new Error("No STORE scope role found in database");
    }
    
    // Create employee directly in database for owner2's store
    const employee2 = await prismaClient.user.create({
      data: {
        email: `employee2-${Date.now()}@example.com`,
        name: "Employee 2",
        public_id: `USR${Date.now()}`,
        status: "ACTIVE",
        is_client_user: true,
      },
    });
    
    await prismaClient.userRole.create({
      data: {
        user_id: employee2.user_id,
        role_id: storeRole.role_id,
        store_id: store2.store_id,
        company_id: company2.company_id,
        assigned_by: owner2.user_id,
      },
    });

    // WHEN: clientUser (owner1) tries to update owner2's employee
    const response = await clientUserApiRequest.put(
      `/api/client/employees/${employee2.user_id}/email`,
      { email: "hacked@example.com" },
    );

    // THEN: Returns 403 Forbidden or 404 Not Found
    expect([403, 404]).toContain(response.status());
    
    // Cleanup
    await prismaClient.userRole.deleteMany({
      where: { user_id: employee2.user_id },
    });
    await prismaClient.user.delete({ where: { user_id: employee2.user_id } });
    await prismaClient.store.delete({ where: { store_id: store2.store_id } });
    await prismaClient.company.delete({ where: { company_id: company2.company_id } });
    await prismaClient.user.delete({ where: { user_id: owner2.user_id } });
  });
});

test.describe("Employee Password Reset API", () => {
  test("[P0-AC-6] PUT /api/client/employees/:userId/password resets employee password", async ({
    clientUserApiRequest,
    clientUser,
    prismaClient,
  }) => {
    // GIVEN: A client owner with an employee
    const storeRole = await prismaClient.role.findFirst({
      where: { scope: "STORE" },
    });
    if (!storeRole) {
      throw new Error("No STORE scope role found in database");
    }

    const createResponse = await clientUserApiRequest.post("/api/client/employees", {
      email: `employee-${Date.now()}@example.com`,
      name: "Test Employee",
      store_id: clientUser.store_id,
      role_id: storeRole.role_id,
      password: "TestPassword123!",
    });
    
    if (createResponse.status() !== 201) {
      const errorBody = await createResponse.json();
      throw new Error(`Employee creation failed: ${JSON.stringify(errorBody)}`);
    }
    
    const createBody = await createResponse.json();
    const employeeId = createBody.data.user_id;

    const newPassword = "NewSecurePass123!";

    // WHEN: Resetting employee password
    const response = await clientUserApiRequest.put(
      `/api/client/employees/${employeeId}/password`,
      { password: newPassword },
    );

    // THEN: Returns success and password is updated
    expect(response.status()).toBe(200);
    const body = await response.json();
    expect(body.success).toBe(true);
    
    // Verify password was updated in database (check that hash changed)
    const updatedUser = await prismaClient.user.findUnique({
      where: { user_id: employeeId },
      select: { password_hash: true },
    });
    expect(updatedUser?.password_hash).toBeDefined();
    expect(updatedUser?.password_hash).not.toBeNull();
  });

  test("[P0-AC-6] PUT /api/client/employees/:userId/password validates password strength", async ({
    clientUserApiRequest,
    clientUser,
    prismaClient,
  }) => {
    // GIVEN: A client owner with an employee
    const storeRole = await prismaClient.role.findFirst({
      where: { scope: "STORE" },
    });
    if (!storeRole) {
      throw new Error("No STORE scope role found in database");
    }

    const createResponse = await clientUserApiRequest.post("/api/client/employees", {
      email: `employee-${Date.now()}@example.com`,
      name: "Test Employee",
      store_id: clientUser.store_id,
      role_id: storeRole.role_id,
      password: "TestPassword123!",
    });
    
    if (createResponse.status() !== 201) {
      const errorBody = await createResponse.json();
      throw new Error(`Employee creation failed: ${JSON.stringify(errorBody)}`);
    }
    
    const createBody = await createResponse.json();
    const employeeId = createBody.data.user_id;

    // WHEN: Resetting with weak password
    const response = await clientUserApiRequest.put(
      `/api/client/employees/${employeeId}/password`,
      { password: "weak" },
    );

    // THEN: Returns validation error
    expect(response.status()).toBe(400);
    const body = await response.json();
    expect(body.success).toBe(false);
    // Error can be string or object with message/code
    const errorMessage = typeof body.error === "object" ? body.error.message || body.error.code : body.error;
    expect(errorMessage).toBeTruthy();
  });

  test("[P0-AC-6] PUT /api/client/employees/:userId/password enforces RLS - owner can only reset own employees", async ({
    clientUserApiRequest,
    clientUser,
    prismaClient,
  }) => {
    // GIVEN: Another client owner with their own employee
    const owner2 = await createUser(prismaClient);
    const company2 = await createCompany(prismaClient, {
      owner_user_id: owner2.user_id,
    });
    const store2 = await createStore(prismaClient, {
      company_id: company2.company_id,
    });
    
    // Create employee for owner2's company (not accessible by clientUser)
    const storeRole = await prismaClient.role.findFirst({
      where: { scope: "STORE" },
    });
    if (!storeRole) {
      throw new Error("No STORE scope role found in database");
    }
    
    // Create employee directly in database for owner2's store
    const employee2 = await prismaClient.user.create({
      data: {
        email: `employee2-${Date.now()}@example.com`,
        name: "Employee 2",
        public_id: `USR${Date.now()}`,
        status: "ACTIVE",
        is_client_user: true,
      },
    });
    
    await prismaClient.userRole.create({
      data: {
        user_id: employee2.user_id,
        role_id: storeRole.role_id,
        store_id: store2.store_id,
        company_id: company2.company_id,
        assigned_by: owner2.user_id,
      },
    });

    // WHEN: clientUser (owner1) tries to reset owner2's employee password
    const response = await clientUserApiRequest.put(
      `/api/client/employees/${employee2.user_id}/password`,
      { password: "HackedPass123!" },
    );

    // THEN: Returns 403 Forbidden or 404 Not Found
    expect([403, 404]).toContain(response.status());
    
    // Cleanup
    await prismaClient.userRole.deleteMany({
      where: { user_id: employee2.user_id },
    });
    await prismaClient.user.delete({ where: { user_id: employee2.user_id } });
    await prismaClient.store.delete({ where: { store_id: store2.store_id } });
    await prismaClient.company.delete({ where: { company_id: company2.company_id } });
    await prismaClient.user.delete({ where: { user_id: owner2.user_id } });
  });
});

import { test, expect } from "../support/fixtures/rbac.fixture";
import { createCompany, createClient } from "../support/factories";

/**
 * Company-Client Linking API Tests (Story 2.7)
 *
 * Tests for updating Company Management to link to Client:
 * - Create company requires client_id (AC #1)
 * - Company list includes client information (AC #2)
 * - Company filtering by client_id (AC #3)
 * - RLS policy enforcement for client-company visibility (AC #4)
 * - Audit logging for client_id changes (AC #5)
 *
 * Priority: P0 (Critical - Multi-tenant hierarchy)
 */

test.describe("2.7-API: Company-Client Linking - Create with client_id (AC #1)", () => {
  test("[P0] 2.7-API-001: POST /api/companies - should create company with valid client_id", async ({
    superadminApiRequest,
    prismaClient,
  }) => {
    // GIVEN: I am authenticated as a System Admin with a valid client
    const clientData = createClient();
    const client = await prismaClient.client.create({ data: clientData });

    const companyData = createCompany({
      name: "Company with Client",
      status: "ACTIVE",
    });

    // WHEN: Creating a company with valid client_id
    const response = await superadminApiRequest.post("/api/companies", {
      client_id: client.client_id,
      name: companyData.name,
      status: companyData.status,
    });

    // THEN: Company is created with client_id
    expect(response.status()).toBe(201);
    const body = await response.json();
    expect(body).toHaveProperty("company_id");
    expect(body).toHaveProperty("client_id", client.client_id);
    expect(body).toHaveProperty("name", companyData.name);
    expect(body).toHaveProperty("status", companyData.status);

    // AND: Company record has client_id in database
    const company = await prismaClient.company.findUnique({
      where: { company_id: body.company_id },
    });
    expect(company).not.toBeNull();
    expect(company?.client_id).toBe(client.client_id);

    // Cleanup
    await prismaClient.company.delete({ where: { company_id: body.company_id } });
    await prismaClient.client.delete({ where: { client_id: client.client_id } });
  });

  test("[P0] 2.7-API-002: POST /api/companies - should fail without client_id", async ({
    superadminApiRequest,
  }) => {
    // GIVEN: I am authenticated as a System Admin
    const companyData = createCompany({
      name: "Company without Client",
      status: "ACTIVE",
    });

    // WHEN: Creating a company without client_id
    const response = await superadminApiRequest.post("/api/companies", {
      name: companyData.name,
      status: companyData.status,
      // client_id is missing
    });

    // THEN: Validation error is returned
    expect(response.status()).toBe(400);
    const body = await response.json();
    expect(body).toHaveProperty("error");
    expect(body.message.toLowerCase()).toContain("client_id");
  });

  test("[P0] 2.7-API-003: POST /api/companies - should fail with invalid client_id", async ({
    superadminApiRequest,
  }) => {
    // GIVEN: I am authenticated as a System Admin with invalid client_id
    const companyData = createCompany({
      name: "Company with Invalid Client",
      status: "ACTIVE",
    });

    // WHEN: Creating a company with non-existent client_id
    const response = await superadminApiRequest.post("/api/companies", {
      client_id: "00000000-0000-0000-0000-000000000000",
      name: companyData.name,
      status: companyData.status,
    });

    // THEN: Validation error is returned
    expect(response.status()).toBe(400);
    const body = await response.json();
    expect(body).toHaveProperty("error");
    expect(body.message.toLowerCase()).toContain("client");
  });

  test("[P0] 2.7-API-004: POST /api/companies - should fail with empty string client_id", async ({
    superadminApiRequest,
  }) => {
    // GIVEN: I am authenticated as a System Admin
    const companyData = createCompany({
      name: "Company with Empty Client",
      status: "ACTIVE",
    });

    // WHEN: Creating a company with empty string client_id
    const response = await superadminApiRequest.post("/api/companies", {
      client_id: "",
      name: companyData.name,
      status: companyData.status,
    });

    // THEN: Validation error is returned
    expect(response.status()).toBe(400);
    const body = await response.json();
    expect(body).toHaveProperty("error");
  });
});

test.describe("2.7-API: Company-Client Linking - List includes client info (AC #2)", () => {
  test("[P1] 2.7-API-005: GET /api/companies - should return client_id and client_name", async ({
    superadminApiRequest,
    prismaClient,
  }) => {
    // GIVEN: I am authenticated as a System Admin and companies with clients exist
    const clientData = createClient({ name: "Test Client Organization" });
    const client = await prismaClient.client.create({ data: clientData });

    const companyData = createCompany({ name: "Company with Client Info" });
    const company = await prismaClient.company.create({
      data: {
        ...companyData,
        client_id: client.client_id,
      },
    });

    // WHEN: Retrieving all companies
    const response = await superadminApiRequest.get("/api/companies");

    // THEN: Response includes client_id and client_name for each company
    expect(response.status()).toBe(200);
    const body = await response.json();
    expect(body).toHaveProperty("data");
    expect(Array.isArray(body.data)).toBe(true);

    const createdCompany = body.data.find(
      (c: any) => c.company_id === company.company_id
    );
    expect(createdCompany).toBeDefined();
    expect(createdCompany).toHaveProperty("client_id", client.client_id);
    expect(createdCompany).toHaveProperty("client_name", client.name);

    // Cleanup
    await prismaClient.company.delete({ where: { company_id: company.company_id } });
    await prismaClient.client.delete({ where: { client_id: client.client_id } });
  });
});

test.describe("2.7-API: Company-Client Linking - Filter by client (AC #3)", () => {
  test("[P0] 2.7-API-006: GET /api/companies?clientId=xxx - should filter by client_id", async ({
    superadminApiRequest,
    prismaClient,
  }) => {
    // GIVEN: I am authenticated as a System Admin with companies in different clients
    const client1 = await prismaClient.client.create({
      data: createClient({ name: "Client 1" }),
    });
    const client2 = await prismaClient.client.create({
      data: createClient({ name: "Client 2" }),
    });

    const company1 = await prismaClient.company.create({
      data: {
        ...createCompany({ name: "Company in Client 1" }),
        client_id: client1.client_id,
      },
    });
    const company2 = await prismaClient.company.create({
      data: {
        ...createCompany({ name: "Company in Client 2" }),
        client_id: client2.client_id,
      },
    });

    // WHEN: Filtering companies by client_id
    const response = await superadminApiRequest.get(
      `/api/companies?clientId=${client1.client_id}`
    );

    // THEN: Only companies belonging to that client are returned
    expect(response.status()).toBe(200);
    const body = await response.json();
    expect(body).toHaveProperty("data");

    const companyIds = body.data.map((c: any) => c.company_id);
    expect(companyIds).toContain(company1.company_id);
    expect(companyIds).not.toContain(company2.company_id);

    // AND: All returned companies have the filtered client_id
    body.data.forEach((c: any) => {
      expect(c.client_id).toBe(client1.client_id);
    });

    // Cleanup
    await prismaClient.company.delete({ where: { company_id: company1.company_id } });
    await prismaClient.company.delete({ where: { company_id: company2.company_id } });
    await prismaClient.client.delete({ where: { client_id: client1.client_id } });
    await prismaClient.client.delete({ where: { client_id: client2.client_id } });
  });

  test("[P0] 2.7-API-007: GET /api/companies - without filter should return all companies", async ({
    superadminApiRequest,
    prismaClient,
  }) => {
    // GIVEN: I am authenticated as a System Admin with companies in different clients
    const client1 = await prismaClient.client.create({
      data: createClient({ name: "Client A" }),
    });
    const client2 = await prismaClient.client.create({
      data: createClient({ name: "Client B" }),
    });

    const company1 = await prismaClient.company.create({
      data: {
        ...createCompany({ name: "Company A" }),
        client_id: client1.client_id,
      },
    });
    const company2 = await prismaClient.company.create({
      data: {
        ...createCompany({ name: "Company B" }),
        client_id: client2.client_id,
      },
    });

    // WHEN: Retrieving companies without filter
    const response = await superadminApiRequest.get("/api/companies");

    // THEN: All companies are returned
    expect(response.status()).toBe(200);
    const body = await response.json();
    expect(body).toHaveProperty("data");

    const companyIds = body.data.map((c: any) => c.company_id);
    expect(companyIds).toContain(company1.company_id);
    expect(companyIds).toContain(company2.company_id);

    // Cleanup
    await prismaClient.company.delete({ where: { company_id: company1.company_id } });
    await prismaClient.company.delete({ where: { company_id: company2.company_id } });
    await prismaClient.client.delete({ where: { client_id: client1.client_id } });
    await prismaClient.client.delete({ where: { client_id: client2.client_id } });
  });
});

test.describe("2.7-API: Company-Client Linking - RLS enforcement (AC #4)", () => {
  test("[P0] 2.7-API-008: System Admin should see all companies across clients", async ({
    superadminApiRequest,
    prismaClient,
  }) => {
    // GIVEN: Companies exist in different clients
    const client1 = await prismaClient.client.create({
      data: createClient({ name: "Client X" }),
    });
    const client2 = await prismaClient.client.create({
      data: createClient({ name: "Client Y" }),
    });

    const company1 = await prismaClient.company.create({
      data: {
        ...createCompany({ name: "Company X" }),
        client_id: client1.client_id,
      },
    });
    const company2 = await prismaClient.company.create({
      data: {
        ...createCompany({ name: "Company Y" }),
        client_id: client2.client_id,
      },
    });

    // WHEN: System Admin retrieves companies
    const response = await superadminApiRequest.get("/api/companies");

    // THEN: All companies are visible
    expect(response.status()).toBe(200);
    const body = await response.json();
    const companyIds = body.data.map((c: any) => c.company_id);
    expect(companyIds).toContain(company1.company_id);
    expect(companyIds).toContain(company2.company_id);

    // Cleanup
    await prismaClient.company.delete({ where: { company_id: company1.company_id } });
    await prismaClient.company.delete({ where: { company_id: company2.company_id } });
    await prismaClient.client.delete({ where: { client_id: client1.client_id } });
    await prismaClient.client.delete({ where: { client_id: client2.client_id } });
  });

  // Note: RLS tests for non-admin users require more complex fixture setup
  // These will be added as the RLS policies are implemented
});

test.describe("2.7-API: Company-Client Linking - Audit logging (AC #5)", () => {
  test("[P0] 2.7-API-009: PUT /api/companies/:id - should log client_id change in audit", async ({
    superadminApiRequest,
    prismaClient,
  }) => {
    // GIVEN: A company exists with one client and another client exists
    const client1 = await prismaClient.client.create({
      data: createClient({ name: "Original Client" }),
    });
    const client2 = await prismaClient.client.create({
      data: createClient({ name: "New Client" }),
    });

    const company = await prismaClient.company.create({
      data: {
        ...createCompany({ name: "Company to Update" }),
        client_id: client1.client_id,
      },
    });

    // WHEN: Updating company's client_id
    const response = await superadminApiRequest.put(
      `/api/companies/${company.company_id}`,
      {
        client_id: client2.client_id,
      }
    );

    // THEN: Update succeeds
    expect(response.status()).toBe(200);
    const body = await response.json();
    expect(body.client_id).toBe(client2.client_id);

    // AND: Audit log contains old and new client_id values
    const auditLog = await prismaClient.auditLog.findFirst({
      where: {
        table_name: "companies",
        record_id: company.company_id,
        action: "UPDATE",
      },
      orderBy: { timestamp: "desc" },
    });

    expect(auditLog).not.toBeNull();
    expect(auditLog?.old_values).toBeDefined();
    expect(auditLog?.new_values).toBeDefined();

    const oldValues = auditLog?.old_values as any;
    const newValues = auditLog?.new_values as any;
    expect(oldValues.client_id).toBe(client1.client_id);
    expect(newValues.client_id).toBe(client2.client_id);

    // Cleanup
    await prismaClient.company.delete({ where: { company_id: company.company_id } });
    await prismaClient.client.delete({ where: { client_id: client1.client_id } });
    await prismaClient.client.delete({ where: { client_id: client2.client_id } });
  });

  test("[P0] 2.7-API-010: POST /api/companies - should include client_id in audit new_values", async ({
    superadminApiRequest,
    prismaClient,
  }) => {
    // GIVEN: I am authenticated as a System Admin with a valid client
    const client = await prismaClient.client.create({
      data: createClient({ name: "Audit Test Client" }),
    });

    // WHEN: Creating a company with client_id
    const response = await superadminApiRequest.post("/api/companies", {
      client_id: client.client_id,
      name: "Audit Test Company",
      status: "ACTIVE",
    });

    expect(response.status()).toBe(201);
    const body = await response.json();

    // THEN: Audit log includes client_id in new_values
    const auditLog = await prismaClient.auditLog.findFirst({
      where: {
        table_name: "companies",
        record_id: body.company_id,
        action: "CREATE",
      },
    });

    expect(auditLog).not.toBeNull();
    expect(auditLog?.new_values).toBeDefined();

    const newValues = auditLog?.new_values as any;
    expect(newValues.client_id).toBe(client.client_id);

    // Cleanup
    await prismaClient.company.delete({ where: { company_id: body.company_id } });
    await prismaClient.client.delete({ where: { client_id: client.client_id } });
  });
});

test.describe("2.7-API: Company-Client Linking - Client Dropdown Endpoint (AC #1, #3)", () => {
  test("[P1] 2.7-API-011: GET /api/clients/dropdown - should return minimal client data", async ({
    superadminApiRequest,
    prismaClient,
  }) => {
    // GIVEN: Clients exist in the system
    const client = await prismaClient.client.create({
      data: createClient({ name: "Dropdown Test Client" }),
    });

    // WHEN: Retrieving clients for dropdown
    const response = await superadminApiRequest.get("/api/clients/dropdown");

    // THEN: Response contains minimal client data (id and name only)
    expect(response.status()).toBe(200);
    const body = await response.json();
    expect(body).toHaveProperty("data");
    expect(Array.isArray(body.data)).toBe(true);

    const clientItem = body.data.find(
      (c: any) => c.client_id === client.client_id
    );
    expect(clientItem).toBeDefined();
    expect(clientItem).toHaveProperty("client_id", client.client_id);
    expect(clientItem).toHaveProperty("name", client.name);

    // AND: Response does NOT include unnecessary fields
    expect(clientItem).not.toHaveProperty("metadata");
    expect(clientItem).not.toHaveProperty("created_at");
    expect(clientItem).not.toHaveProperty("updated_at");

    // Cleanup
    await prismaClient.client.delete({ where: { client_id: client.client_id } });
  });
});
